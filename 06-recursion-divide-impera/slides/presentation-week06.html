<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SÄƒptÄƒmÃ¢na 6: Cozi (Queues) - ATP</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-yellow: #d29922;
            --accent-red: #f85149;
            --accent-purple: #a371f7;
            --border-color: #30363d;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow: hidden;
        }
        
        /* Progress Bar */
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            transition: width 0.3s ease;
            z-index: 1000;
        }
        
        /* Slide Container */
        .slides-container {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }
        
        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 60px 80px;
            display: none;
            opacity: 0;
            transition: opacity 0.4s ease;
            overflow-y: auto;
        }
        
        .slide.active {
            display: flex;
            flex-direction: column;
            opacity: 1;
        }
        
        /* Typography */
        h1 {
            font-size: 2.8rem;
            font-weight: 700;
            margin-bottom: 20px;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        h2 {
            font-size: 2.2rem;
            font-weight: 600;
            margin-bottom: 30px;
            color: var(--accent-blue);
        }
        
        h3 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--accent-green);
        }
        
        p, li {
            font-size: 1.25rem;
            margin-bottom: 12px;
            color: var(--text-primary);
        }
        
        ul, ol {
            margin-left: 30px;
            margin-bottom: 20px;
        }
        
        li {
            margin-bottom: 10px;
        }
        
        /* Code Blocks */
        .code-block {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin: 20px 0;
            overflow: hidden;
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        
        .lang-badge {
            background: var(--accent-blue);
            color: var(--bg-primary);
            padding: 2px 10px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.8rem;
        }
        
        pre {
            margin: 0;
            padding: 20px;
            overflow-x: auto;
        }
        
        code {
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            font-size: 0.95rem;
        }
        
        /* Boxes */
        .info-box {
            background: var(--bg-secondary);
            border-left: 4px solid var(--accent-blue);
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .warning-box {
            background: rgba(210, 153, 34, 0.1);
            border-left: 4px solid var(--accent-yellow);
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .success-box {
            background: rgba(63, 185, 80, 0.1);
            border-left: 4px solid var(--accent-green);
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .error-box {
            background: rgba(248, 81, 73, 0.1);
            border-left: 4px solid var(--accent-red);
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        
        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            padding: 12px 15px;
            text-align: left;
            border: 1px solid var(--border-color);
        }
        
        th {
            background: var(--bg-tertiary);
            color: var(--accent-blue);
            font-weight: 600;
        }
        
        tr:nth-child(even) {
            background: var(--bg-secondary);
        }
        
        /* ASCII Art / Diagrams */
        .diagram {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 8px;
            white-space: pre;
            font-size: 0.9rem;
            line-height: 1.4;
            overflow-x: auto;
            margin: 20px 0;
            color: var(--accent-green);
        }
        
        /* Grid Layouts */
        .two-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 20px 0;
        }
        
        .three-columns {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .column {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        
        /* Title Slide */
        .title-slide {
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        
        .title-slide h1 {
            font-size: 4rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 2rem;
            color: var(--text-secondary);
            margin-bottom: 30px;
        }
        
        .institution {
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-top: 50px;
        }
        
        /* Navigation */
        .nav-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        .nav-btn {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 8px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .nav-btn:hover {
            background: var(--accent-blue);
            color: var(--bg-primary);
        }
        
        .slide-counter {
            position: fixed;
            bottom: 25px;
            left: 30px;
            font-size: 1rem;
            color: var(--text-secondary);
            z-index: 100;
        }
        
        /* Feature Cards */
        .feature-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 25px;
            margin: 10px 0;
            transition: transform 0.2s ease, border-color 0.2s ease;
        }
        
        .feature-card:hover {
            transform: translateY(-3px);
            border-color: var(--accent-blue);
        }
        
        .feature-card h4 {
            color: var(--accent-purple);
            font-size: 1.2rem;
            margin-bottom: 10px;
        }
        
        /* Emphasis */
        .highlight {
            color: var(--accent-yellow);
            font-weight: 600;
        }
        
        .keyword {
            color: var(--accent-purple);
            font-family: monospace;
            background: var(--bg-tertiary);
            padding: 2px 8px;
            border-radius: 4px;
        }
        
        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .slide.active > * {
            animation: fadeIn 0.5s ease forwards;
        }
        
        .slide.active > *:nth-child(2) { animation-delay: 0.1s; }
        .slide.active > *:nth-child(3) { animation-delay: 0.2s; }
        .slide.active > *:nth-child(4) { animation-delay: 0.3s; }
        .slide.active > *:nth-child(5) { animation-delay: 0.4s; }
        
        /* Responsive */
        @media (max-width: 1024px) {
            .slide { padding: 40px; }
            h1 { font-size: 2.2rem; }
            h2 { font-size: 1.8rem; }
            .two-columns, .three-columns { grid-template-columns: 1fr; }
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-blue);
        }
    </style>
</head>
<body>
    <div class="progress-bar" id="progressBar"></div>
    
    <div class="slides-container">
        <!-- Slide 1: Title -->
        <div class="slide title-slide active" data-slide="1">
            <p style="font-size: 1.5rem; color: var(--text-secondary);">Algoritmi È™i Tehnici de Programare</p>
            <h1>SÄƒptÄƒmÃ¢na 6</h1>
            <div class="subtitle">Cozi (Queues)</div>
            <p style="font-size: 1.3rem; color: var(--accent-green);">FIFO â€¢ Circular Buffer â€¢ Priority Queue</p>
            <div class="institution">
                Academia de Studii Economice din BucureÈ™ti<br>
                Facultatea de CiberneticÄƒ, StatisticÄƒ È™i InformaticÄƒ EconomicÄƒ
            </div>
        </div>

        <!-- Slide 2: Learning Objectives -->
        <div class="slide" data-slide="2">
            <h2>ğŸ¯ Obiective de ÃnvÄƒÈ›are</h2>
            <div class="two-columns">
                <div>
                    <div class="feature-card">
                        <h4>ğŸ“– CunoaÈ™tere</h4>
                        <p>Definirea structurii queue È™i enumerarea operaÈ›iilor fundamentale</p>
                    </div>
                    <div class="feature-card">
                        <h4>ğŸ§  ÃnÈ›elegere</h4>
                        <p>Explicarea principiului FIFO È™i diferenÈ›ele faÈ›Äƒ de stack (LIFO)</p>
                    </div>
                    <div class="feature-card">
                        <h4>âš™ï¸ Aplicare</h4>
                        <p>Implementarea queue folosind array È™i linked list</p>
                    </div>
                </div>
                <div>
                    <div class="feature-card">
                        <h4>ğŸ” AnalizÄƒ</h4>
                        <p>Compararea complexitÄƒÈ›ilor diferitelor implementÄƒri</p>
                    </div>
                    <div class="feature-card">
                        <h4>âš–ï¸ Evaluare</h4>
                        <p>Selectarea implementÄƒrii optime pentru context specific</p>
                    </div>
                    <div class="feature-card">
                        <h4>ğŸš€ Creare</h4>
                        <p>Proiectarea unui sistem de task scheduling cu priority queue</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 3: Historical Context -->
        <div class="slide" data-slide="3">
            <h2>ğŸ“œ Context Istoric</h2>
            <div class="two-columns">
                <div>
                    <h3>Originea Teoriei Cozilor</h3>
                    <p>Conceptul de <span class="keyword">queue</span> Ã®È™i are originea Ã®n <span class="highlight">teoria cozilor de aÈ™teptare</span> (queueing theory), dezvoltatÄƒ la Ã®nceputul secolului XX.</p>
                    <div class="info-box">
                        <strong>1909:</strong> Agner Krarup Erlang publicÄƒ primul studiu matematic despre congestia Ã®n reÈ›elele telefonice.
                    </div>
                    <div class="info-box">
                        <strong>1961:</strong> MIT dezvoltÄƒ CTSS, primul sistem de time-sharing care foloseÈ™te queue-uri pentru job scheduling.
                    </div>
                </div>
                <div>
                    <h3>EvoluÈ›ia ImplementÄƒrilor</h3>
                    <div class="diagram">
1909: Teoria matematicÄƒ (Erlang)
  â”‚
  â–¼
1950s: ImplementÄƒri hardware
  â”‚
  â–¼
1960s: Queue-uri Ã®n sisteme OS
  â”‚
  â–¼
1970s: Circular buffers Ã®n DSP
  â”‚
  â–¼
1990s: Message queues distribuite
  â”‚
  â–¼
2000s+: Event loops, async I/O</div>
                </div>
            </div>
        </div>

        <!-- Slide 4: Key Figure -->
        <div class="slide" data-slide="4">
            <h2>ğŸ‘¤ Personalitate Cheie</h2>
            <div class="two-columns">
                <div style="display: flex; flex-direction: column; align-items: center;">
                    <div style="width: 200px; height: 200px; border-radius: 50%; background: var(--bg-tertiary); display: flex; align-items: center; justify-content: center; font-size: 4rem; margin-bottom: 20px;">
                        ğŸ“Š
                    </div>
                    <h3 style="text-align: center;">Agner Krarup Erlang</h3>
                    <p style="text-align: center; color: var(--text-secondary);">1878 - 1929</p>
                </div>
                <div>
                    <div class="feature-card">
                        <h4>ContribuÈ›ii Majore</h4>
                        <ul>
                            <li><strong>Formula Erlang B</strong> - probabilitatea de blocare Ã®n sisteme cu pierderi</li>
                            <li><strong>Formula Erlang C</strong> - timpul de aÈ™teptare Ã®n cozi</li>
                            <li>Unitatea <span class="keyword">erlang</span> pentru intensitatea traficului</li>
                        </ul>
                    </div>
                    <div class="success-box">
                        <strong>ğŸ’¬ Citat celebru:</strong><br>
                        <em>"Calculele care stau la baza reÈ›elelor telefonice pot fi aplicate oricÄƒrui sistem Ã®n care entitÄƒÈ›ile aÈ™teaptÄƒ sÄƒ fie servite."</em>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 5: What is a Queue -->
        <div class="slide" data-slide="5">
            <h2>ğŸ“¦ Ce este o Queue?</h2>
            <div class="info-box">
                <strong>DefiniÈ›ie:</strong> O <span class="keyword">queue</span> (coadÄƒ) este o structurÄƒ de date liniarÄƒ care urmeazÄƒ principiul <span class="highlight">FIFO</span> (First In, First Out) - primul element adÄƒugat este primul eliminat.
            </div>
            <div class="diagram">
        ENQUEUE (inserare)                                    DEQUEUE (extragere)
              â”‚                                                      â”‚
              â–¼                                                      â–¼
           â•”â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•—
           â•‘  E   â•‘  D   â•‘  C   â•‘  B   â•‘  A   â•‘
           â•šâ•â•â•â•â•â•â•©â•â•â•â•â•â•â•©â•â•â•â•â•â•â•©â•â•â•â•â•â•â•©â•â•â•â•â•â•â•
             REAR                         FRONT
           (spate)                       (faÈ›Äƒ)
           
        Ordine sosire:  A â†’ B â†’ C â†’ D â†’ E
        Ordine ieÈ™ire:  A â†’ B â†’ C â†’ D â†’ E  (aceeaÈ™i!)</div>
            <div class="two-columns" style="margin-top: 20px;">
                <div class="success-box">
                    <strong>âœ… Analogie din viaÈ›a realÄƒ:</strong><br>
                    Coada la casÄƒ, coada la ATM, lista de aÈ™teptare
                </div>
                <div class="info-box">
                    <strong>ğŸ“Œ CaracteristicÄƒ esenÈ›ialÄƒ:</strong><br>
                    Echitabil - cine vine primul, este servit primul
                </div>
            </div>
        </div>

        <!-- Slide 6: FIFO vs LIFO -->
        <div class="slide" data-slide="6">
            <h2>âš–ï¸ FIFO vs LIFO</h2>
            <div class="two-columns">
                <div class="column">
                    <h3 style="color: var(--accent-blue);">Queue (FIFO)</h3>
                    <div class="diagram" style="font-size: 0.85rem;">
    Enqueue: â†’ [A][B][C][D] â†’ Dequeue
    
    Push A: [A]
    Push B: [A][B]
    Push C: [A][B][C]
    Pop:    [B][C] â†’ returneazÄƒ A
    Pop:    [C] â†’ returneazÄƒ B</div>
                    <div class="info-box">
                        <strong>UtilizÄƒri:</strong>
                        <ul>
                            <li>Job scheduling</li>
                            <li>Print spooler</li>
                            <li>BFS traversal</li>
                            <li>Buffer I/O</li>
                        </ul>
                    </div>
                </div>
                <div class="column">
                    <h3 style="color: var(--accent-purple);">Stack (LIFO)</h3>
                    <div class="diagram" style="font-size: 0.85rem;">
    Push/Pop: â†“â†‘ [D]
                  [C]
                  [B]
                  [A]
    
    Push A: [A]
    Push B: [A][B]
    Push C: [A][B][C]
    Pop:    [A][B] â†’ returneazÄƒ C
    Pop:    [A] â†’ returneazÄƒ B</div>
                    <div class="info-box">
                        <strong>UtilizÄƒri:</strong>
                        <ul>
                            <li>Call stack</li>
                            <li>Undo operations</li>
                            <li>DFS traversal</li>
                            <li>Expression evaluation</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 7: Operations -->
        <div class="slide" data-slide="7">
            <h2>ğŸ”§ OperaÈ›ii Fundamentale</h2>
            <table>
                <thead>
                    <tr>
                        <th>OperaÈ›ie</th>
                        <th>Descriere</th>
                        <th>Timp</th>
                        <th>SpaÈ›iu</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><span class="keyword">enqueue(x)</span></td>
                        <td>AdaugÄƒ elementul x la rear (spate)</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                    </tr>
                    <tr>
                        <td><span class="keyword">dequeue()</span></td>
                        <td>EliminÄƒ È™i returneazÄƒ elementul din front</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                    </tr>
                    <tr>
                        <td><span class="keyword">peek() / front()</span></td>
                        <td>ReturneazÄƒ front fÄƒrÄƒ eliminare</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                    </tr>
                    <tr>
                        <td><span class="keyword">isEmpty()</span></td>
                        <td>VerificÄƒ dacÄƒ queue este goalÄƒ</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                    </tr>
                    <tr>
                        <td><span class="keyword">isFull()</span></td>
                        <td>VerificÄƒ dacÄƒ queue este plinÄƒ (array)</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                    </tr>
                    <tr>
                        <td><span class="keyword">size()</span></td>
                        <td>ReturneazÄƒ numÄƒrul de elemente</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                    </tr>
                </tbody>
            </table>
            <div class="success-box">
                <strong>ğŸ¯ ObservaÈ›ie cheie:</strong> Toate operaÈ›iile au complexitate <strong>O(1)</strong> - aceasta este puterea structurii queue cÃ¢nd este implementatÄƒ corect!
            </div>
        </div>

        <!-- Slide 8: ADT Definition -->
        <div class="slide" data-slide="8">
            <h2>ğŸ“‹ Abstract Data Type (ADT)</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>SpecificaÈ›ie ADT Queue</span>
                    <span class="lang-badge">Pseudocode</span>
                </div>
                <pre><code class="language-plaintext">ADT Queue
    Data:
        - ColecÈ›ie ordonatÄƒ de elemente de tip T
        - Pointer/index la front (primul element)
        - Pointer/index la rear (ultimul element)
        - Contor de elemente (opÈ›ional)
    
    Operations:
        create()        â†’ Queue         // CreeazÄƒ queue goalÄƒ
        destroy(q)      â†’ void          // ElibereazÄƒ memoria
        enqueue(q, x)   â†’ void          // AdaugÄƒ x la rear
        dequeue(q)      â†’ T             // EliminÄƒ È™i returneazÄƒ front
        front(q)        â†’ T             // ReturneazÄƒ front (fÄƒrÄƒ eliminare)
        isEmpty(q)      â†’ boolean       // True dacÄƒ queue goalÄƒ
        isFull(q)       â†’ boolean       // True dacÄƒ queue plinÄƒ
        size(q)         â†’ integer       // NumÄƒrul de elemente
    
    Axioms:
        - isEmpty(create()) = true
        - isEmpty(enqueue(q, x)) = false
        - front(enqueue(create(), x)) = x
        - dequeue(enqueue(create(), x)) = create()</code></pre>
            </div>
        </div>

        <!-- Slide 9: Array Implementation Intro -->
        <div class="slide" data-slide="9">
            <h2>ğŸ“Š Implementare cu Array</h2>
            <h3>Problema NaivÄƒ</h3>
            <div class="diagram">
    Stare iniÈ›ialÄƒ (capacitate 6):
    Index:    0     1     2     3     4     5
           â•”â•â•â•â•â•â•¦â•â•â•â•â•â•¦â•â•â•â•â•â•¦â•â•â•â•â•â•¦â•â•â•â•â•â•¦â•â•â•â•â•â•—
           â•‘  A  â•‘  B  â•‘  C  â•‘     â•‘     â•‘     â•‘
           â•šâ•â•â•â•â•â•©â•â•â•â•â•â•©â•â•â•â•â•â•©â•â•â•â•â•â•©â•â•â•â•â•â•©â•â•â•â•â•â•
             front=0            rear=3

    DupÄƒ dequeue() - PROBLEMÄ‚!
           â•”â•â•â•â•â•â•¦â•â•â•â•â•â•¦â•â•â•â•â•â•¦â•â•â•â•â•â•¦â•â•â•â•â•â•¦â•â•â•â•â•â•—
           â•‘     â•‘  B  â•‘  C  â•‘     â•‘     â•‘     â•‘
           â•šâ•â•â•â•â•â•©â•â•â•â•â•â•©â•â•â•â•â•â•©â•â•â•â•â•â•©â•â•â•â•â•â•©â•â•â•â•â•â•
                   front=1       rear=3
    
    âŒ SpaÈ›iul de la index 0 este pierdut!</div>
            <div class="error-box">
                <strong>âš ï¸ Problema:</strong> DupÄƒ multiple operaÈ›ii dequeue, spaÈ›iul de la Ã®nceputul array-ului rÄƒmÃ¢ne nefolosit. SoluÈ›ii posibile:
                <ul>
                    <li><strong>Mutare elemente</strong> - O(n) pentru dequeue âŒ</li>
                    <li><strong>Circular Buffer</strong> - O(1) pentru toate operaÈ›iile âœ…</li>
                </ul>
            </div>
        </div>

        <!-- Slide 10: Circular Buffer Concept -->
        <div class="slide" data-slide="10">
            <h2>ğŸ”„ Circular Buffer - Concept</h2>
            <div class="info-box">
                <strong>Ideea:</strong> TratÄƒm array-ul ca pe un cerc - dupÄƒ ultimul index urmeazÄƒ primul index!
            </div>
            <div class="two-columns">
                <div class="diagram">
    Vizualizare liniarÄƒ:
    
    Index:  0   1   2   3   4   5
         â•”â•â•â•â•¦â•â•â•â•¦â•â•â•â•¦â•â•â•â•¦â•â•â•â•¦â•â•â•â•—
         â•‘ D â•‘ E â•‘   â•‘   â•‘ B â•‘ C â•‘
         â•šâ•â•â•â•©â•â•â•â•©â•â•â•â•©â•â•â•â•©â•â•â•â•©â•â•â•â•
               â†‘       â†‘
             rear    front
    
    Formula magicÄƒ:
    next = (current + 1) % capacity</div>
                <div class="diagram">
    Vizualizare circularÄƒ:
    
              [0] D
            â†—       â†˜
         [5] C        [1] E
           |           |
         [4] B        [2] (gol)
            â†–       â†™
              [3] (gol)
              
    front = 4, rear = 2
    Elemente: B â†’ C â†’ D â†’ E</div>
            </div>
        </div>

        <!-- Slide 11: Circular Buffer Structure -->
        <div class="slide" data-slide="11">
            <h2>ğŸ—ï¸ Structura Circular Buffer Ã®n C</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Definirea structurii</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">#define QUEUE_CAPACITY 100

typedef struct {
    int data[QUEUE_CAPACITY];   // Array-ul de stocare
    int front;                   // Index primul element
    int rear;                    // Index poziÈ›ie liberÄƒ urmÄƒtoare
    int count;                   // NumÄƒr elemente curente
} Queue;

// Varianta alternativÄƒ (fÄƒrÄƒ count):
typedef struct {
    int data[QUEUE_CAPACITY + 1];  // +1 pentru a distinge plin/gol
    int front;
    int rear;
    // Plin: (rear + 1) % cap == front
    // Gol:  rear == front
} QueueAlt;</code></pre>
            </div>
            <div class="warning-box">
                <strong>ğŸ’¡ Design Decision:</strong> Cu <span class="keyword">count</span> - uÈ™or de verificat plin/gol dar necesitÄƒ sincronizare extra Ã®n cod multi-threaded. FÄƒrÄƒ count - sacrificÄƒm 1 poziÈ›ie dar atomic-safe.
            </div>
        </div>

        <!-- Slide 12: Enqueue Operation -->
        <div class="slide" data-slide="12">
            <h2>â• OperaÈ›ia enqueue</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Implementare enqueue</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/**
 * AdaugÄƒ un element la sfÃ¢rÈ™itul queue-ului
 * @param q    Pointer la queue
 * @param item Elementul de adÄƒugat
 * @return     1 dacÄƒ succes, 0 dacÄƒ queue plinÄƒ
 */
int queue_enqueue(Queue *q, int item) {
    // VerificÄƒm dacÄƒ queue-ul este plin
    if (q->count >= QUEUE_CAPACITY) {
        fprintf(stderr, "Eroare: Queue overflow!\n");
        return 0;  // EÈ™ec - queue plinÄƒ
    }
    
    // AdÄƒugÄƒm elementul la poziÈ›ia rear
    q->data[q->rear] = item;
    
    // AvansÄƒm rear circular
    q->rear = (q->rear + 1) % QUEUE_CAPACITY;
    
    // IncrementÄƒm contorul
    q->count++;
    
    return 1;  // Succes
}</code></pre>
            </div>
            <div class="diagram">
    Ãnainte:  [A][B][C][ ][ ][ ]    front=0, rear=3, count=3
    enqueue(D)
    DupÄƒ:     [A][B][C][D][ ][ ]    front=0, rear=4, count=4</div>
        </div>

        <!-- Slide 13: Dequeue Operation -->
        <div class="slide" data-slide="13">
            <h2>â– OperaÈ›ia dequeue</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Implementare dequeue</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/**
 * EliminÄƒ È™i returneazÄƒ elementul din faÈ›a queue-ului
 * @param q      Pointer la queue
 * @param result Pointer pentru stocarea rezultatului
 * @return       1 dacÄƒ succes, 0 dacÄƒ queue goalÄƒ
 */
int queue_dequeue(Queue *q, int *result) {
    // VerificÄƒm dacÄƒ queue-ul este gol
    if (q->count == 0) {
        fprintf(stderr, "Eroare: Queue underflow!\n");
        return 0;  // EÈ™ec - queue goalÄƒ
    }
    
    // SalvÄƒm elementul din front
    *result = q->data[q->front];
    
    // AvansÄƒm front circular
    q->front = (q->front + 1) % QUEUE_CAPACITY;
    
    // DecrementÄƒm contorul
    q->count--;
    
    return 1;  // Succes
}</code></pre>
            </div>
            <div class="diagram">
    Ãnainte:  [A][B][C][D][ ][ ]    front=0, rear=4, count=4
    dequeue() â†’ returneazÄƒ A
    DupÄƒ:     [ ][B][C][D][ ][ ]    front=1, rear=4, count=3</div>
        </div>

        <!-- Slide 14: Circular Wrap-Around -->
        <div class="slide" data-slide="14">
            <h2>ğŸ”„ Wrap-Around Ã®n AcÈ›iune</h2>
            <div class="diagram" style="font-size: 0.85rem;">
    Capacitate: 6

    Stare 1 (dupÄƒ mai multe operaÈ›ii):
    Index:    0     1     2     3     4     5
           â•”â•â•â•â•â•â•¦â•â•â•â•â•â•¦â•â•â•â•â•â•¦â•â•â•â•â•â•¦â•â•â•â•â•â•¦â•â•â•â•â•â•—
           â•‘     â•‘     â•‘     â•‘  X  â•‘  Y  â•‘  Z  â•‘
           â•šâ•â•â•â•â•â•©â•â•â•â•â•â•©â•â•â•â•â•â•©â•â•â•â•â•â•©â•â•â•â•â•â•©â•â•â•â•â•â•
                               â†‘front      rearâ†‘ (ar fi 6, dar devine 0!)

    enqueue('W') - rear = (5 + 1) % 6 = 0
    Index:    0     1     2     3     4     5
           â•”â•â•â•â•â•â•¦â•â•â•â•â•â•¦â•â•â•â•â•â•¦â•â•â•â•â•â•¦â•â•â•â•â•â•¦â•â•â•â•â•â•—
           â•‘  W  â•‘     â•‘     â•‘  X  â•‘  Y  â•‘  Z  â•‘
           â•šâ•â•â•â•â•â•©â•â•â•â•â•â•©â•â•â•â•â•â•©â•â•â•â•â•â•©â•â•â•â•â•â•©â•â•â•â•â•â•
             rearâ†‘             â†‘front

    enqueue('V') - rear = (0 + 1) % 6 = 1
    Index:    0     1     2     3     4     5
           â•”â•â•â•â•â•â•¦â•â•â•â•â•â•¦â•â•â•â•â•â•¦â•â•â•â•â•â•¦â•â•â•â•â•â•¦â•â•â•â•â•â•—
           â•‘  W  â•‘  V  â•‘     â•‘  X  â•‘  Y  â•‘  Z  â•‘
           â•šâ•â•â•â•â•â•©â•â•â•â•â•â•©â•â•â•â•â•â•©â•â•â•â•â•â•©â•â•â•â•â•â•©â•â•â•â•â•â•
                   rearâ†‘       â†‘front

    Ordinea logicÄƒ: X â†’ Y â†’ Z â†’ W â†’ V (FIFO pÄƒstrat!)</div>
        </div>

        <!-- Slide 15: Helper Functions -->
        <div class="slide" data-slide="15">
            <h2>ğŸ› ï¸ FuncÈ›ii Auxiliare</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>FuncÈ›ii helper pentru queue</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">// CreeazÄƒ È™i iniÈ›ializeazÄƒ o queue nouÄƒ
Queue* queue_create(void) {
    Queue *q = (Queue*)malloc(sizeof(Queue));
    if (q != NULL) {
        q->front = 0;
        q->rear = 0;
        q->count = 0;
    }
    return q;
}

// ElibereazÄƒ memoria
void queue_destroy(Queue *q) {
    free(q);
}

// VerificÄƒ dacÄƒ queue-ul este gol
int queue_is_empty(const Queue *q) {
    return q->count == 0;
}

// VerificÄƒ dacÄƒ queue-ul este plin
int queue_is_full(const Queue *q) {
    return q->count >= QUEUE_CAPACITY;
}

// ReturneazÄƒ numÄƒrul de elemente
int queue_size(const Queue *q) {
    return q->count;
}

// ReturneazÄƒ elementul din faÈ›Äƒ fÄƒrÄƒ eliminare (peek)
int queue_front(const Queue *q, int *result) {
    if (q->count == 0) return 0;
    *result = q->data[q->front];
    return 1;
}</code></pre>
            </div>
        </div>

        <!-- Slide 16: Linked List Queue -->
        <div class="slide" data-slide="16">
            <h2>ğŸ”— Implementare cu Linked List</h2>
            <div class="diagram">
    front                                              rear
      â”‚                                                  â”‚
      â–¼                                                  â–¼
    â•”â•â•â•â•â•â•â•â•â•â•â•â•—    â•”â•â•â•â•â•â•â•â•â•â•â•â•—    â•”â•â•â•â•â•â•â•â•â•â•â•â•—    â•”â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘ data: 'A' â•‘    â•‘ data: 'B' â•‘    â•‘ data: 'C' â•‘    â•‘ data: 'D' â•‘
    â•‘ next: â”€â”€â”€â”€â•«â”€â”€â”€â–ºâ•‘ next: â”€â”€â”€â”€â•«â”€â”€â”€â–ºâ•‘ next: â”€â”€â”€â”€â•«â”€â”€â”€â–ºâ•‘ next: NULLâ•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•    â•šâ•â•â•â•â•â•â•â•â•â•â•â•    â•šâ•â•â•â•â•â•â•â•â•â•â•â•    â•šâ•â•â•â•â•â•â•â•â•â•â•â•

    enqueue('E'):   Se adaugÄƒ la rear, rear->next = newNode, rear = newNode
    dequeue():      temp = front, front = front->next, free(temp), return data</div>
            <div class="code-block">
                <div class="code-header">
                    <span>Structura pentru linked list queue</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">typedef struct Node {
    int data;
    struct Node *next;
} Node;

typedef struct {
    Node *front;    // Pointer la primul nod
    Node *rear;     // Pointer la ultimul nod
    int count;      // NumÄƒr de elemente
} LinkedQueue;</code></pre>
            </div>
        </div>

        <!-- Slide 17: Linked Queue Operations -->
        <div class="slide" data-slide="17">
            <h2>ğŸ”— OperaÈ›ii Linked List Queue</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Enqueue È™i Dequeue pentru linked list</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">int lqueue_enqueue(LinkedQueue *q, int item) {
    Node *newNode = (Node*)malloc(sizeof(Node));
    if (newNode == NULL) return 0;  // Alocare eÈ™uatÄƒ
    
    newNode->data = item;
    newNode->next = NULL;
    
    if (q->rear == NULL) {
        // Queue goalÄƒ - noul nod devine È™i front È™i rear
        q->front = q->rear = newNode;
    } else {
        // AdÄƒugÄƒm la sfÃ¢rÈ™itul listei
        q->rear->next = newNode;
        q->rear = newNode;
    }
    q->count++;
    return 1;
}

int lqueue_dequeue(LinkedQueue *q, int *result) {
    if (q->front == NULL) return 0;  // Queue goalÄƒ
    
    Node *temp = q->front;
    *result = temp->data;
    q->front = q->front->next;
    
    if (q->front == NULL) {
        q->rear = NULL;  // Queue devine goalÄƒ
    }
    
    free(temp);
    q->count--;
    return 1;
}</code></pre>
            </div>
        </div>

        <!-- Slide 18: Comparison Table -->
        <div class="slide" data-slide="18">
            <h2>ğŸ“Š ComparaÈ›ie: Array vs Linked List</h2>
            <table>
                <thead>
                    <tr>
                        <th>Criteriu</th>
                        <th>Circular Buffer</th>
                        <th>Linked List</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Memorie per element</td>
                        <td style="color: var(--accent-green);">sizeof(T)</td>
                        <td style="color: var(--accent-yellow);">sizeof(T) + sizeof(pointer)</td>
                    </tr>
                    <tr>
                        <td>Capacitate</td>
                        <td style="color: var(--accent-yellow);">FixÄƒ (predefinitÄƒ)</td>
                        <td style="color: var(--accent-green);">DinamicÄƒ</td>
                    </tr>
                    <tr>
                        <td>Cache locality</td>
                        <td style="color: var(--accent-green);">ExcelentÄƒ</td>
                        <td style="color: var(--accent-red);">SlabÄƒ</td>
                    </tr>
                    <tr>
                        <td>Fragmentare memorie</td>
                        <td style="color: var(--accent-green);">Nu</td>
                        <td style="color: var(--accent-yellow);">Da</td>
                    </tr>
                    <tr>
                        <td>Overhead alocare</td>
                        <td style="color: var(--accent-green);">O singurÄƒ datÄƒ</td>
                        <td style="color: var(--accent-red);">Per operaÈ›ie</td>
                    </tr>
                    <tr>
                        <td>Complexitate cod</td>
                        <td style="color: var(--accent-green);">SimplÄƒ</td>
                        <td style="color: var(--accent-yellow);">ModeratÄƒ</td>
                    </tr>
                </tbody>
            </table>
            <div class="two-columns" style="margin-top: 20px;">
                <div class="success-box">
                    <strong>âœ… FoloseÈ™te Circular Buffer cÃ¢nd:</strong><br>
                    Dimensiunea maximÄƒ este cunoscutÄƒ, embedded systems, buffere I/O
                </div>
                <div class="info-box">
                    <strong>âœ… FoloseÈ™te Linked List cÃ¢nd:</strong><br>
                    Dimensiunea variazÄƒ mult, memorie limitatÄƒ, message queues
                </div>
            </div>
        </div>

        <!-- Slide 19: Deque Introduction -->
        <div class="slide" data-slide="19">
            <h2>â†”ï¸ Double-Ended Queue (Deque)</h2>
            <div class="info-box">
                <strong>DefiniÈ›ie:</strong> Un <span class="keyword">deque</span> (pronounced "deck") permite inserare È™i È™tergere la <em>ambele</em> capete.
            </div>
            <div class="diagram">
                       enqueueFront              enqueueRear
                            â”‚                        â”‚
                            â–¼                        â–¼
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘                    [ A ][ B ][ C ][ D ]                  â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            â–²                        â–²
                            â”‚                        â”‚
                       dequeueFront              dequeueRear</div>
            <table style="margin-top: 20px;">
                <thead>
                    <tr>
                        <th>OperaÈ›ie</th>
                        <th>Descriere</th>
                        <th>Echivalent</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><span class="keyword">enqueueFront(x)</span></td>
                        <td>AdaugÄƒ x la front</td>
                        <td>Stack push</td>
                    </tr>
                    <tr>
                        <td><span class="keyword">enqueueRear(x)</span></td>
                        <td>AdaugÄƒ x la rear</td>
                        <td>Queue enqueue</td>
                    </tr>
                    <tr>
                        <td><span class="keyword">dequeueFront()</span></td>
                        <td>EliminÄƒ de la front</td>
                        <td>Queue dequeue / Stack pop</td>
                    </tr>
                    <tr>
                        <td><span class="keyword">dequeueRear()</span></td>
                        <td>EliminÄƒ de la rear</td>
                        <td>-</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Slide 20: Priority Queue -->
        <div class="slide" data-slide="20">
            <h2>â­ Priority Queue</h2>
            <div class="info-box">
                <strong>DefiniÈ›ie:</strong> O <span class="keyword">priority queue</span> este o queue Ã®n care fiecare element are asociatÄƒ o prioritate. Elementul cu prioritatea cea mai mare (sau micÄƒ) este extras primul.
            </div>
            <div class="two-columns">
                <div>
                    <h3>ImplementÄƒri Posibile</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>Implementare</th>
                                <th>Insert</th>
                                <th>Extract</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Array nesortat</td>
                                <td style="color: var(--accent-green);">O(1)</td>
                                <td style="color: var(--accent-red);">O(n)</td>
                            </tr>
                            <tr>
                                <td>Array sortat</td>
                                <td style="color: var(--accent-red);">O(n)</td>
                                <td style="color: var(--accent-green);">O(1)</td>
                            </tr>
                            <tr>
                                <td style="color: var(--accent-green);">Heap</td>
                                <td style="color: var(--accent-green);">O(log n)</td>
                                <td style="color: var(--accent-green);">O(log n)</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <div>
                    <h3>AplicaÈ›ii</h3>
                    <ul>
                        <li>Dijkstra's algorithm</li>
                        <li>Huffman coding</li>
                        <li>Task scheduling (OS)</li>
                        <li>Event-driven simulation</li>
                        <li>A* pathfinding</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 21: Simple Priority Queue Implementation -->
        <div class="slide" data-slide="21">
            <h2>â­ Priority Queue SimplÄƒ (Array de Queues)</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Implementare cu nivele de prioritate</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">#define NUM_PRIORITIES 4
#define PRIORITY_CRITICAL 0
#define PRIORITY_HIGH     1
#define PRIORITY_NORMAL   2
#define PRIORITY_LOW      3

typedef struct {
    Queue levels[NUM_PRIORITIES];  // 4 queue-uri separate
} PriorityQueue;

void pq_enqueue(PriorityQueue *pq, int item, int priority) {
    if (priority < 0 || priority >= NUM_PRIORITIES) {
        priority = PRIORITY_NORMAL;
    }
    queue_enqueue(&pq->levels[priority], item);
}

int pq_dequeue(PriorityQueue *pq, int *result) {
    // CÄƒutÄƒm de la prioritatea cea mai mare
    for (int i = 0; i < NUM_PRIORITIES; i++) {
        if (!queue_is_empty(&pq->levels[i])) {
            return queue_dequeue(&pq->levels[i], result);
        }
    }
    return 0;  // Toate queue-urile goale
}</code></pre>
            </div>
        </div>

        <!-- Slide 22: BFS with Queue -->
        <div class="slide" data-slide="22">
            <h2>ğŸŒ AplicaÈ›ie: BFS (Breadth-First Search)</h2>
            <div class="two-columns">
                <div>
                    <div class="diagram" style="font-size: 0.8rem;">
    Graf:
              1
            / | \
           2  3  4
          /|     |
         5 6     7

    BFS de la nodul 1:
    
    Queue: [1] â†’ ProcesÄƒm 1
    Queue: [2,3,4] â†’ ProcesÄƒm 2
    Queue: [3,4,5,6] â†’ ProcesÄƒm 3
    Queue: [4,5,6] â†’ ProcesÄƒm 4
    Queue: [5,6,7] â†’ ProcesÄƒm 5
    Queue: [6,7] â†’ ProcesÄƒm 6
    Queue: [7] â†’ ProcesÄƒm 7
    
    Ordine vizitare: 1â†’2â†’3â†’4â†’5â†’6â†’7
    (nivel cu nivel!)</div>
                </div>
                <div>
                    <div class="code-block">
                        <div class="code-header">
                            <span>BFS Algorithm</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">void bfs(Graph *g, int start) {
    Queue q;
    queue_init(&q);
    bool visited[MAX] = {false};
    
    queue_enqueue(&q, start);
    visited[start] = true;
    
    while (!queue_is_empty(&q)) {
        int curr;
        queue_dequeue(&q, &curr);
        printf("%d ", curr);
        
        // AdaugÄƒ vecinii nevizitaÈ›i
        for (int i = 0; i < g->adj_count[curr]; i++) {
            int neighbor = g->adj[curr][i];
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                queue_enqueue(&q, neighbor);
            }
        }
    }
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 23: Producer-Consumer Pattern -->
        <div class="slide" data-slide="23">
            <h2>ğŸ­ Pattern: Producer-Consumer</h2>
            <div class="diagram">
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—                                    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘   PRODUCER    â•‘                                    â•‘   CONSUMER    â•‘
    â•‘               â•‘    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—     â•‘               â•‘
    â•‘  GenereazÄƒ    â•‘â”€â”€â”€â–ºâ•‘      MESSAGE QUEUE     â•‘â”€â”€â”€â”€â–ºâ•‘  ProceseazÄƒ   â•‘
    â•‘  date/events  â•‘    â•‘  [M1][M2][M3][M4]...   â•‘     â•‘  date/events  â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•     â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    Avantaje:
    â€¢ Decuplare Ã®ntre producer È™i consumer
    â€¢ Buffering pentru diferenÈ›e de vitezÄƒ
    â€¢ Scalabilitate (multiple producers/consumers)</div>
            <div class="code-block">
                <div class="code-header">
                    <span>Exemplu simplificat</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">// Thread-safe queue ar necesita mutex/semaphore
// Aceasta este o versiune simplificatÄƒ pentru demonstraÈ›ie

void producer(Queue *q) {
    for (int i = 0; i < 100; i++) {
        int data = generate_data();
        while (queue_is_full(q)) {
            sleep_ms(10);  // AÈ™teptÄƒm sÄƒ se elibereze spaÈ›iu
        }
        queue_enqueue(q, data);
    }
}

void consumer(Queue *q) {
    while (1) {
        int data;
        while (queue_is_empty(q)) {
            sleep_ms(10);  // AÈ™teptÄƒm date
        }
        queue_dequeue(q, &data);
        process_data(data);
    }
}</code></pre>
            </div>
        </div>

        <!-- Slide 24: Common Mistakes -->
        <div class="slide" data-slide="24">
            <h2>âš ï¸ GreÈ™eli Frecvente</h2>
            <div class="two-columns">
                <div>
                    <div class="error-box">
                        <strong>âŒ GreÈ™eala 1: Uitarea operatorului modulo</strong>
                        <pre style="background: #1a0000; padding: 10px; margin-top: 10px;"><code class="language-c">// GREÈ˜IT:
q->rear = q->rear + 1;
// rear poate depÄƒÈ™i capacitatea!

// CORECT:
q->rear = (q->rear + 1) % CAPACITY;</code></pre>
                    </div>
                    <div class="error-box">
                        <strong>âŒ GreÈ™eala 2: Confuzie plin vs gol</strong>
                        <pre style="background: #1a0000; padding: 10px; margin-top: 10px;"><code class="language-c">// FÄƒrÄƒ count, ambele condiÈ›ii pot avea
// front == rear!

// SoluÈ›ie: count sau sacrificare poziÈ›ie</code></pre>
                    </div>
                </div>
                <div>
                    <div class="error-box">
                        <strong>âŒ GreÈ™eala 3: Memory leak Ã®n linked list</strong>
                        <pre style="background: #1a0000; padding: 10px; margin-top: 10px;"><code class="language-c">// GREÈ˜IT:
q->front = q->front->next;
// Nodul vechi e pierdut!

// CORECT:
Node *temp = q->front;
q->front = q->front->next;
free(temp);</code></pre>
                    </div>
                    <div class="error-box">
                        <strong>âŒ GreÈ™eala 4: NULL pointer</strong>
                        <pre style="background: #1a0000; padding: 10px; margin-top: 10px;"><code class="language-c">// DupÄƒ ultimul dequeue:
if (q->front == NULL) {
    q->rear = NULL; // Nu uitaÈ›i!
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 25: Memory Model -->
        <div class="slide" data-slide="25">
            <h2>ğŸ§  Model de Memorie</h2>
            <div class="diagram">
    STACK (variabile locale)           HEAP (alocare dinamicÄƒ)
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                     â”‚           â”‚                                 â”‚
    â”‚  Queue q;           â”‚           â”‚  Node pentru Linked Queue:      â”‚
    â”‚  â”œâ”€â”€ front: 0       â”‚           â”‚                                 â”‚
    â”‚  â”œâ”€â”€ rear: 3        â”‚           â”‚  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—              â”‚
    â”‚  â”œâ”€â”€ count: 3       â”‚           â”‚  â•‘ Node 0x1000   â•‘              â”‚
    â”‚  â””â”€â”€ data[100]:     â”‚           â”‚  â•‘ data: 10      â•‘              â”‚
    â”‚      [0]: 42        â”‚           â”‚  â•‘ next: 0x1020 â”€â•«â”€â”€â”€â”€â”€â”€â”       â”‚
    â”‚      [1]: 17        â”‚           â”‚  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•      â”‚       â”‚
    â”‚      [2]: 99        â”‚           â”‚                         â–¼       â”‚
    â”‚      [3]: ?         â”‚           â”‚  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—              â”‚
    â”‚      ...            â”‚           â”‚  â•‘ Node 0x1020   â•‘              â”‚
    â”‚                     â”‚           â”‚  â•‘ data: 20      â•‘              â”‚
    â”‚  LinkedQueue lq;    â”‚           â”‚  â•‘ next: NULL    â•‘              â”‚
    â”‚  â”œâ”€â”€ front: 0x1000 â”€â•«â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ•‘  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•              â”‚
    â”‚  â”œâ”€â”€ rear: 0x1020 â”€â”€â•«â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
    â”‚  â””â”€â”€ count: 2       â”‚           â”‚                                 â”‚
    â”‚                     â”‚           â”‚                                 â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</div>
        </div>

        <!-- Slide 26: Debugging with GDB -->
        <div class="slide" data-slide="26">
            <h2>ğŸ› Debugging cu GDB</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Comenzi GDB utile pentru queue</span>
                    <span class="lang-badge">Bash</span>
                </div>
                <pre><code class="language-bash"># Compilare cu simboluri de debug
gcc -g -Wall -o program program.c

# Pornire GDB
gdb ./program

# Setare breakpoint
(gdb) break queue_enqueue
(gdb) break queue_dequeue

# Rulare
(gdb) run

# Inspectare queue (circular buffer)
(gdb) print q->front
(gdb) print q->rear
(gdb) print q->count
(gdb) print q->data[0]@10    # Primele 10 elemente

# Inspectare linked queue
(gdb) print *q->front        # Primul nod
(gdb) print *q->front->next  # Al doilea nod

# Pas cu pas
(gdb) next    # UrmÄƒtoarea linie
(gdb) step    # IntrÄƒ Ã®n funcÈ›ie

# Watch pentru modificÄƒri
(gdb) watch q->count</code></pre>
            </div>
        </div>

        <!-- Slide 27: Valgrind Memory Check -->
        <div class="slide" data-slide="27">
            <h2>ğŸ” Verificare Memorie cu Valgrind</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Utilizare Valgrind</span>
                    <span class="lang-badge">Bash</span>
                </div>
                <pre><code class="language-bash"># Verificare memory leaks
valgrind --leak-check=full ./program

# Output tipic pentru memory leak:
# ==12345== LEAK SUMMARY:
# ==12345==    definitely lost: 32 bytes in 2 blocks

# Verificare acces invalid
valgrind --track-origins=yes ./program

# Output pentru acces invalid:
# ==12345== Invalid read of size 4
# ==12345==    at 0x401234: queue_dequeue (queue.c:45)

# Generare raport complet
valgrind --leak-check=full --show-leak-kinds=all \
         --track-origins=yes --log-file=valgrind.log ./program</code></pre>
            </div>
            <div class="success-box">
                <strong>âœ… Obiectiv:</strong> 0 bytes lost, 0 errors - asta Ã®nseamnÄƒ cod corect!
            </div>
        </div>

        <!-- Slide 28: Best Practices -->
        <div class="slide" data-slide="28">
            <h2>âœ… Best Practices</h2>
            <div class="two-columns">
                <div>
                    <h3 style="color: var(--accent-green);">âœ“ DO</h3>
                    <ul>
                        <li>VerificÄƒ <span class="keyword">isEmpty()</span> Ã®nainte de dequeue</li>
                        <li>VerificÄƒ <span class="keyword">isFull()</span> Ã®nainte de enqueue (array)</li>
                        <li>FoloseÈ™te <span class="keyword">const</span> pentru funcÈ›ii read-only</li>
                        <li>ElibereazÄƒ toatÄƒ memoria Ã®n destroy</li>
                        <li>DocumenteazÄƒ complexitÄƒÈ›ile</li>
                        <li>TesteazÄƒ edge cases (0, 1, MAX elemente)</li>
                        <li>FoloseÈ™te typedef pentru claritate</li>
                    </ul>
                </div>
                <div>
                    <h3 style="color: var(--accent-red);">âœ— DON'T</h3>
                    <ul>
                        <li>Nu ignora valoarea de return</li>
                        <li>Nu presupune cÄƒ alocarea reuÈ™eÈ™te</li>
                        <li>Nu amesteca logica queue cu alte responsabilitÄƒÈ›i</li>
                        <li>Nu uita operatorul modulo</li>
                        <li>Nu accesa memoria dupÄƒ free</li>
                        <li>Nu hardcoda capacitatea Ã®n cod</li>
                        <li>Nu neglija thread safety dacÄƒ e necesar</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 29: Standard Library -->
        <div class="slide" data-slide="29">
            <h2>ğŸ“š Queue Ã®n Biblioteci Standard</h2>
            <div class="two-columns">
                <div>
                    <h3>C++ STL</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>std::queue</span>
                            <span class="lang-badge">C++</span>
                        </div>
                        <pre><code class="language-cpp">#include &lt;queue&gt;

std::queue&lt;int&gt; q;
q.push(10);      // enqueue
q.push(20);
int x = q.front(); // peek
q.pop();         // dequeue
bool empty = q.empty();
size_t size = q.size();</code></pre>
                    </div>
                    <h3>Java</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>java.util.Queue</span>
                            <span class="lang-badge">Java</span>
                        </div>
                        <pre><code class="language-java">Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();
q.offer(10);     // enqueue
q.offer(20);
int x = q.peek(); // peek
int y = q.poll(); // dequeue
boolean empty = q.isEmpty();</code></pre>
                    </div>
                </div>
                <div>
                    <h3>Python</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>collections.deque</span>
                            <span class="lang-badge">Python</span>
                        </div>
                        <pre><code class="language-python">from collections import deque

q = deque()
q.append(10)     # enqueue
q.append(20)
x = q[0]         # peek
y = q.popleft()  # dequeue
empty = len(q) == 0</code></pre>
                    </div>
                    <h3>JavaScript</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Array as Queue</span>
                            <span class="lang-badge">JS</span>
                        </div>
                        <pre><code class="language-javascript">const q = [];
q.push(10);      // enqueue
q.push(20);
const x = q[0];  // peek
const y = q.shift(); // dequeue (O(n)!)
const empty = q.length === 0;</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 30: Real-World Applications -->
        <div class="slide" data-slide="30">
            <h2>ğŸŒ AplicaÈ›ii Ã®n Lumea RealÄƒ</h2>
            <div class="three-columns">
                <div class="feature-card">
                    <h4>ğŸ–¨ï¸ Print Spooler</h4>
                    <p>Documentele sunt tipÄƒrite Ã®n ordinea trimiterii. Queue FIFO asigurÄƒ echitate.</p>
                </div>
                <div class="feature-card">
                    <h4>ğŸµ Playlist</h4>
                    <p>Melodiile sunt redate Ã®n ordine. UrmÄƒtoarea melodie = dequeue().</p>
                </div>
                <div class="feature-card">
                    <h4>ğŸ“§ Email Server</h4>
                    <p>Mesajele sunt procesate Ã®n ordinea primirii pentru delivery.</p>
                </div>
            </div>
            <div class="three-columns">
                <div class="feature-card">
                    <h4>ğŸ® Game Events</h4>
                    <p>Input-ul utilizatorului este pus Ã®n queue È™i procesat frame by frame.</p>
                </div>
                <div class="feature-card">
                    <h4>ğŸš— Traffic Light</h4>
                    <p>MaÈ™inile aÈ™teaptÄƒ È™i trec Ã®n ordinea sosirii la semafor.</p>
                </div>
                <div class="feature-card">
                    <h4>ğŸ“± Message Broker</h4>
                    <p>RabbitMQ, Kafka - sisteme distribuite bazate pe queue-uri.</p>
                </div>
            </div>
            <div class="three-columns">
                <div class="feature-card">
                    <h4>ğŸ’¾ Disk I/O</h4>
                    <p>Cererile de citire/scriere sunt planificate folosind queue-uri.</p>
                </div>
                <div class="feature-card">
                    <h4>ğŸŒ Web Server</h4>
                    <p>Request-urile HTTP sunt puse Ã®n queue cÃ¢nd serverul e ocupat.</p>
                </div>
                <div class="feature-card">
                    <h4>ğŸ”„ Task Scheduler</h4>
                    <p>Procesele OS sunt planificate folosind queue-uri cu prioritÄƒÈ›i.</p>
                </div>
            </div>
        </div>

        <!-- Slide 31: Time Complexity Summary -->
        <div class="slide" data-slide="31">
            <h2>â±ï¸ Sumar ComplexitÄƒÈ›i</h2>
            <table>
                <thead>
                    <tr>
                        <th>OperaÈ›ie</th>
                        <th>Circular Buffer</th>
                        <th>Linked List</th>
                        <th>Array (naiv)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>enqueue</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                        <td style="color: var(--accent-green);">O(1)*</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                    </tr>
                    <tr>
                        <td>dequeue</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                        <td style="color: var(--accent-red);">O(n)</td>
                    </tr>
                    <tr>
                        <td>peek/front</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                    </tr>
                    <tr>
                        <td>isEmpty</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                    </tr>
                    <tr>
                        <td>size</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                        <td style="color: var(--accent-green);">O(1)</td>
                    </tr>
                    <tr>
                        <td>SpaÈ›iu total</td>
                        <td>O(capacity)</td>
                        <td>O(n)</td>
                        <td>O(capacity)</td>
                    </tr>
                </tbody>
            </table>
            <div class="info-box">
                <strong>* NotÄƒ:</strong> Linked list enqueue este O(1) doar dacÄƒ pÄƒstrÄƒm pointer la rear. Altfel ar fi O(n) pentru a parcurge lista.
            </div>
        </div>

        <!-- Slide 32: Lab Exercise Preview -->
        <div class="slide" data-slide="32">
            <h2>ğŸ”¬ Previzualizare Laborator</h2>
            <div class="two-columns">
                <div class="feature-card">
                    <h4>ExerciÈ›iul 1: Circular Buffer pentru Comenzi</h4>
                    <ul>
                        <li>Structura <span class="keyword">Order</span> (id, client, items, timestamp)</li>
                        <li>Circular buffer cu capacitate configurabilÄƒ</li>
                        <li>OperaÈ›ii: add_order, process_order, peek_next</li>
                        <li>Statistici: timp mediu aÈ™teptare</li>
                    </ul>
                    <div class="warning-box">
                        <strong>TODO markers:</strong> 8-12 locuri de completat
                    </div>
                </div>
                <div class="feature-card">
                    <h4>ExerciÈ›iul 2: Priority Queue pentru Tasks</h4>
                    <ul>
                        <li>4 nivele de prioritate (CRITICAL â†’ LOW)</li>
                        <li>Structura <span class="keyword">Task</span> (id, priority, description)</li>
                        <li>Array de 4 linked-list queues</li>
                        <li>Round-robin Ã®ntre task-uri egale</li>
                    </ul>
                    <div class="warning-box">
                        <strong>TODO markers:</strong> 10-15 locuri de completat
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 33: Interview Questions -->
        <div class="slide" data-slide="33">
            <h2>ğŸ’¼ ÃntrebÄƒri de Interviu</h2>
            <div class="feature-card">
                <h4>Q1: Cum implementezi o queue folosind douÄƒ stacks?</h4>
                <p><em>Hint: Un stack pentru enqueue, altul pentru dequeue. Transfer la dequeue dacÄƒ stack-ul de dequeue e gol.</em></p>
            </div>
            <div class="feature-card">
                <h4>Q2: Cum detectezi dacÄƒ un circular buffer este plin sau gol?</h4>
                <p><em>RÄƒspuns: (1) Counter separat, sau (2) SacrificÄƒ o poziÈ›ie - plin cÃ¢nd (rear+1)%cap == front</em></p>
            </div>
            <div class="feature-card">
                <h4>Q3: Care este diferenÈ›a Ã®ntre queue È™i deque?</h4>
                <p><em>RÄƒspuns: Queue: inserare la rear, eliminare la front. Deque: ambele operaÈ›ii la ambele capete.</em></p>
            </div>
            <div class="feature-card">
                <h4>Q4: Cum ai implementa un LRU Cache?</h4>
                <p><em>Hint: CombinaÈ›ie de Hash Table + Double Linked List (sau Deque). Access = move to front.</em></p>
            </div>
        </div>

        <!-- Slide 34: Key Takeaways -->
        <div class="slide" data-slide="34">
            <h2>ğŸ¯ Concluzii Cheie</h2>
            <div class="three-columns">
                <div class="success-box">
                    <strong>1. FIFO</strong><br>
                    Queue = First In, First Out. Echitabil È™i predictibil.
                </div>
                <div class="success-box">
                    <strong>2. O(1) Toate OperaÈ›iile</strong><br>
                    Circular buffer È™i linked list oferÄƒ O(1) constant.
                </div>
                <div class="success-box">
                    <strong>3. Formula MagicÄƒ</strong><br>
                    next = (current + 1) % capacity
                </div>
            </div>
            <div class="three-columns">
                <div class="success-box">
                    <strong>4. Trade-offs</strong><br>
                    Array: cache-friendly, fix. List: dinamic, fragmentat.
                </div>
                <div class="success-box">
                    <strong>5. Priority Queue</strong><br>
                    Heap oferÄƒ O(log n) pentru ambele operaÈ›ii.
                </div>
                <div class="success-box">
                    <strong>6. BFS</strong><br>
                    Queue este esenÈ›ialÄƒ pentru parcurgerea pe nivele.
                </div>
            </div>
        </div>

        <!-- Slide 35: Resources -->
        <div class="slide" data-slide="35">
            <h2>ğŸ“– Resurse Recomandate</h2>
            <div class="two-columns">
                <div>
                    <h3>CÄƒrÈ›i</h3>
                    <ul>
                        <li><strong>CLRS</strong> - Introduction to Algorithms, Cap. 10</li>
                        <li><strong>Sedgewick</strong> - Algorithms, Cap. 1.3</li>
                        <li><strong>K&R</strong> - The C Programming Language</li>
                    </ul>
                    <h3>DocumentaÈ›ii</h3>
                    <ul>
                        <li>Linux kernel kfifo implementation</li>
                        <li>POSIX message queues (mq_overview)</li>
                        <li>C++ STL std::queue documentation</li>
                    </ul>
                </div>
                <div>
                    <h3>Resurse Online</h3>
                    <ul>
                        <li><a href="https://visualgo.net" style="color: var(--accent-blue);">VisuAlgo</a> - VizualizÄƒri interactive</li>
                        <li><a href="https://www.geeksforgeeks.org" style="color: var(--accent-blue);">GeeksforGeeks</a> - Tutoriale È™i probleme</li>
                        <li><a href="https://leetcode.com" style="color: var(--accent-blue);">LeetCode</a> - Probleme de practicÄƒ</li>
                    </ul>
                    <h3>Video</h3>
                    <ul>
                        <li>MIT OpenCourseWare - 6.006</li>
                        <li>Computerphile - Data Structures</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 36: Next Week Preview -->
        <div class="slide" data-slide="36">
            <h2>ğŸ”® SÄƒptÄƒmÃ¢na Viitoare: Arbori Binari</h2>
            <div class="diagram">
              Binary Tree
              
                    1
                   / \
                  2   3
                 / \   \
                4   5   6
                
              Terminologie:
              â€¢ RÄƒdÄƒcinÄƒ (root): nodul 1
              â€¢ Frunze (leaves): nodurile 4, 5, 6
              â€¢ ÃnÄƒlÈ›ime (height): 2
              â€¢ Nivel (level): 0, 1, 2</div>
            <div class="two-columns">
                <div class="info-box">
                    <strong>Subiecte principale:</strong>
                    <ul>
                        <li>Reprezentare Ã®n memorie</li>
                        <li>Parcurgeri: preorder, inorder, postorder</li>
                        <li>Level-order traversal (cu queue!)</li>
                        <li>Binary Search Trees (BST)</li>
                    </ul>
                </div>
                <div class="success-box">
                    <strong>ğŸ”— Conexiune cu queue:</strong><br>
                    Parcurgerea <em>level-order</em> (BFS pe arbori) foloseÈ™te exact structura queue pe care am studiat-o!
                </div>
            </div>
        </div>

        <!-- Slide 37: Questions -->
        <div class="slide title-slide" data-slide="37">
            <h1>â“ ÃntrebÄƒri?</h1>
            <div class="subtitle">MulÈ›umesc pentru atenÈ›ie!</div>
            <div style="margin-top: 50px;">
                <p style="font-size: 1.3rem; color: var(--text-secondary);">SÄƒptÄƒmÃ¢na 6: Cozi (Queues)</p>
                <p style="font-size: 1.1rem; color: var(--accent-green);">FIFO â€¢ Circular Buffer â€¢ Priority Queue â€¢ BFS</p>
            </div>
            <div class="institution">
                Academia de Studii Economice din BucureÈ™ti<br>
                Algoritmi È™i Tehnici de Programare
            </div>
        </div>
    </div>

    <!-- Navigation -->
    <div class="slide-counter">
        <span id="currentSlide">1</span> / <span id="totalSlides">37</span>
    </div>
    
    <div class="nav-controls">
        <button class="nav-btn" onclick="goToSlide(1)" title="Prima paginÄƒ">â®</button>
        <button class="nav-btn" onclick="prevSlide()" title="Ãnapoi">â—€</button>
        <button class="nav-btn" onclick="nextSlide()" title="Ãnainte">â–¶</button>
        <button class="nav-btn" onclick="goToSlide(totalSlides)" title="Ultima paginÄƒ">â­</button>
    </div>

    <script>
        let currentSlide = 1;
        const slides = document.querySelectorAll('.slide');
        const totalSlides = slides.length;
        
        document.getElementById('totalSlides').textContent = totalSlides;

        function updateProgress() {
            const progress = (currentSlide / totalSlides) * 100;
            document.getElementById('progressBar').style.width = progress + '%';
            document.getElementById('currentSlide').textContent = currentSlide;
        }

        function showSlide(n) {
            slides.forEach(slide => slide.classList.remove('active'));
            currentSlide = n;
            if (currentSlide > totalSlides) currentSlide = 1;
            if (currentSlide < 1) currentSlide = totalSlides;
            slides[currentSlide - 1].classList.add('active');
            updateProgress();
        }

        function nextSlide() {
            showSlide(currentSlide + 1);
        }

        function prevSlide() {
            showSlide(currentSlide - 1);
        }

        function goToSlide(n) {
            showSlide(n);
        }

        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            switch(e.key) {
                case 'ArrowRight':
                case ' ':
                case 'PageDown':
                    e.preventDefault();
                    nextSlide();
                    break;
                case 'ArrowLeft':
                case 'PageUp':
                    e.preventDefault();
                    prevSlide();
                    break;
                case 'Home':
                    e.preventDefault();
                    goToSlide(1);
                    break;
                case 'End':
                    e.preventDefault();
                    goToSlide(totalSlides);
                    break;
            }
        });

        // Initialize
        hljs.highlightAll();
        updateProgress();
    </script>
</body>
</html>
