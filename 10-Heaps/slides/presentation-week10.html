<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SÄƒptÄƒmÃ¢na 10: Heap-uri È™i Cozi cu PrioritÄƒÈ›i | ATP</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-yellow: #d29922;
            --accent-red: #f85149;
            --accent-purple: #a371f7;
            --border-color: #30363d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        /* Progress Bar */
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            transition: width 0.3s ease;
            z-index: 1000;
        }

        /* Slide Container */
        .slides-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 60px 80px;
            display: flex;
            flex-direction: column;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
            overflow-y: auto;
        }

        .slide.active {
            opacity: 1;
            visibility: visible;
        }

        /* Typography */
        h1 {
            font-size: 2.8rem;
            color: var(--accent-blue);
            margin-bottom: 1.5rem;
            border-bottom: 3px solid var(--accent-purple);
            padding-bottom: 0.5rem;
        }

        h2 {
            font-size: 2.2rem;
            color: var(--accent-green);
            margin-bottom: 1.2rem;
        }

        h3 {
            font-size: 1.6rem;
            color: var(--accent-yellow);
            margin-bottom: 1rem;
        }

        p {
            font-size: 1.3rem;
            line-height: 1.8;
            margin-bottom: 1rem;
        }

        ul, ol {
            font-size: 1.25rem;
            line-height: 1.9;
            margin-left: 2rem;
            margin-bottom: 1rem;
        }

        li {
            margin-bottom: 0.6rem;
        }

        /* Code Blocks */
        .code-block {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin: 1rem 0;
            overflow: hidden;
        }

        .code-header {
            background-color: var(--bg-tertiary);
            padding: 8px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
        }

        .code-header span {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .lang-badge {
            background-color: var(--accent-blue);
            color: var(--bg-primary);
            padding: 2px 10px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.8rem !important;
        }

        .code-block pre {
            margin: 0;
            padding: 16px;
            overflow-x: auto;
        }

        .code-block code {
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            font-size: 0.95rem;
            line-height: 1.5;
        }

        /* Boxes */
        .info-box {
            background-color: rgba(88, 166, 255, 0.1);
            border-left: 4px solid var(--accent-blue);
            padding: 1rem 1.5rem;
            margin: 1rem 0;
            border-radius: 0 8px 8px 0;
        }

        .warning-box {
            background-color: rgba(210, 153, 34, 0.1);
            border-left: 4px solid var(--accent-yellow);
            padding: 1rem 1.5rem;
            margin: 1rem 0;
            border-radius: 0 8px 8px 0;
        }

        .error-box {
            background-color: rgba(248, 81, 73, 0.1);
            border-left: 4px solid var(--accent-red);
            padding: 1rem 1.5rem;
            margin: 1rem 0;
            border-radius: 0 8px 8px 0;
        }

        .success-box {
            background-color: rgba(63, 185, 80, 0.1);
            border-left: 4px solid var(--accent-green);
            padding: 1rem 1.5rem;
            margin: 1rem 0;
            border-radius: 0 8px 8px 0;
        }

        /* Grid Layouts */
        .two-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 1rem 0;
        }

        .three-columns {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 1.5rem;
            margin: 1rem 0;
        }

        .column {
            background-color: var(--bg-secondary);
            padding: 1.2rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        /* Diagram */
        .diagram {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            line-height: 1.4;
            white-space: pre;
            overflow-x: auto;
            margin: 1rem 0;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            font-size: 1.1rem;
        }

        th, td {
            padding: 12px 16px;
            text-align: left;
            border: 1px solid var(--border-color);
        }

        th {
            background-color: var(--bg-tertiary);
            color: var(--accent-blue);
            font-weight: 600;
        }

        tr:nth-child(even) {
            background-color: var(--bg-secondary);
        }

        /* Quote */
        blockquote {
            border-left: 4px solid var(--accent-purple);
            padding-left: 1.5rem;
            margin: 1.5rem 0;
            font-style: italic;
            color: var(--text-secondary);
            font-size: 1.3rem;
        }

        /* Navigation */
        .navigation {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }

        .nav-btn {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s ease;
        }

        .nav-btn:hover {
            background-color: var(--accent-blue);
            color: var(--bg-primary);
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Slide Counter */
        .slide-counter {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background-color: var(--bg-secondary);
            padding: 8px 16px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            font-size: 0.95rem;
            z-index: 1000;
        }

        /* Title Slide */
        .title-slide {
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .title-slide h1 {
            font-size: 3.5rem;
            border: none;
            margin-bottom: 1rem;
        }

        .title-slide .subtitle {
            font-size: 2rem;
            color: var(--accent-purple);
            margin-bottom: 2rem;
        }

        .title-slide .meta {
            color: var(--text-secondary);
            font-size: 1.2rem;
        }

        /* Summary boxes */
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin: 1rem 0;
        }

        .summary-item {
            background-color: var(--bg-secondary);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            text-align: center;
        }

        .summary-item .icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        /* Complexity badge */
        .complexity {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .complexity.good {
            background-color: rgba(63, 185, 80, 0.2);
            color: var(--accent-green);
        }

        .complexity.moderate {
            background-color: rgba(210, 153, 34, 0.2);
            color: var(--accent-yellow);
        }

        .complexity.bad {
            background-color: rgba(248, 81, 73, 0.2);
            color: var(--accent-red);
        }

        /* Keyboard hints */
        kbd {
            background-color: var(--bg-tertiary);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            font-family: monospace;
            font-size: 0.9rem;
        }

        /* Highlight */
        .highlight {
            color: var(--accent-yellow);
            font-weight: 600;
        }

        /* Figure styling */
        .figure {
            text-align: center;
            margin: 1.5rem 0;
        }

        .figure img {
            max-width: 80%;
            border-radius: 8px;
        }

        .figure figcaption {
            color: var(--text-secondary);
            font-size: 1rem;
            margin-top: 0.5rem;
        }

        /* Animation for lists */
        .slide.active ul li,
        .slide.active ol li {
            animation: fadeInUp 0.5s ease forwards;
            opacity: 0;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .slide.active ul li:nth-child(1) { animation-delay: 0.1s; }
        .slide.active ul li:nth-child(2) { animation-delay: 0.2s; }
        .slide.active ul li:nth-child(3) { animation-delay: 0.3s; }
        .slide.active ul li:nth-child(4) { animation-delay: 0.4s; }
        .slide.active ul li:nth-child(5) { animation-delay: 0.5s; }
        .slide.active ul li:nth-child(6) { animation-delay: 0.6s; }
        .slide.active ul li:nth-child(7) { animation-delay: 0.7s; }
        .slide.active ul li:nth-child(8) { animation-delay: 0.8s; }

        /* Responsive */
        @media (max-width: 1200px) {
            .slide {
                padding: 40px 50px;
            }
            h1 { font-size: 2.2rem; }
            h2 { font-size: 1.8rem; }
            p, li { font-size: 1.1rem; }
        }
    </style>
</head>
<body>
    <div class="progress-bar" id="progressBar"></div>

    <div class="slides-container">
        <!-- Slide 1: Title -->
        <div class="slide title-slide active" data-slide="1">
            <h1>ğŸ”º Heap-uri È™i Cozi cu PrioritÄƒÈ›i</h1>
            <p class="subtitle">SÄƒptÄƒmÃ¢na 10 | Algoritmi È™i Tehnici de Programare</p>
            <p class="meta">
                Academia de Studii Economice BucureÈ™ti<br>
                Facultatea de CiberneticÄƒ, StatisticÄƒ È™i InformaticÄƒ EconomicÄƒ<br><br>
                <kbd>â†</kbd> <kbd>â†’</kbd> pentru navigare | <kbd>Home</kbd> <kbd>End</kbd> pentru Ã®nceput/sfÃ¢rÈ™it
            </p>
        </div>

        <!-- Slide 2: Learning Objectives -->
        <div class="slide" data-slide="2">
            <h1>ğŸ¯ Obiective de ÃnvÄƒÈ›are</h1>
            <ul>
                <li><strong>MemoraÈ›i</strong> proprietÄƒÈ›ile fundamentale ale heap-urilor (max-heap È™i min-heap)</li>
                <li><strong>ÃnÈ›elegeÈ›i</strong> diferenÈ›ele dintre heap-uri, arbori binari de cÄƒutare È™i cozi cu prioritÄƒÈ›i</li>
                <li><strong>AplicaÈ›i</strong> operaÈ›iile de bazÄƒ: inserare, extragere, heapify</li>
                <li><strong>AnalizaÈ›i</strong> complexitatea temporalÄƒ a operaÈ›iilor pe heap</li>
                <li><strong>EvaluaÈ›i</strong> eficienÈ›a diferitelor implementÄƒri È™i alegeri de design</li>
                <li><strong>CreaÈ›i</strong> aplicaÈ›ii complete utilizÃ¢nd heap-uri pentru probleme reale</li>
            </ul>
        </div>

        <!-- Slide 3: Historical Context -->
        <div class="slide" data-slide="3">
            <h1>ğŸ“œ Context Istoric</h1>
            <div class="two-columns">
                <div class="column">
                    <h3>Cronologie</h3>
                    <ul>
                        <li><strong>1964</strong> - J.W.J. Williams inventeazÄƒ heap-ul binar È™i Heap Sort</li>
                        <li><strong>1964</strong> - Robert Floyd optimizeazÄƒ construcÈ›ia heap-ului la O(n)</li>
                        <li><strong>1978</strong> - Floyd primeÈ™te Premiul Turing</li>
                        <li><strong>1984</strong> - Fibonacci Heap (Fredman & Tarjan)</li>
                        <li><strong>1996</strong> - Brodal Queue - primul heap cu operaÈ›ii worst-case O(1)</li>
                    </ul>
                </div>
                <div class="column">
                    <h3>Impact Ã®n Industrie</h3>
                    <ul>
                        <li>Planificarea proceselor Ã®n UNIX (anii 1970)</li>
                        <li>Algoritmi fundamentali: Dijkstra, Prim, Huffman</li>
                        <li>Baze de date È™i sisteme de indexare</li>
                        <li>SimulÄƒri discrete È™i game engines</li>
                        <li>Streaming de date È™i analizÄƒ Ã®n timp real</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 4: Key Figure -->
        <div class="slide" data-slide="4">
            <h1>ğŸ‘¤ Figura Cheie: J.W.J. Williams</h1>
            <div class="two-columns">
                <div class="column">
                    <h3>John William Joseph Williams (1930-2012)</h3>
                    <p>Informatician britanic, pionier Ã®n algoritmicÄƒ</p>
                    <ul>
                        <li>A lucrat la UK Atomic Energy Authority</li>
                        <li>Profesor la University of Sussex</li>
                        <li>Creator al heap-ului binar (1964)</li>
                        <li>Inventator al algoritmului Heap Sort</li>
                    </ul>
                </div>
                <div class="column">
                    <blockquote>
                        "Simplitatea structurii heap derivÄƒ din exploatarea elegantÄƒ a proprietÄƒÈ›ilor arborilor binari compleÈ›i - o demonstraÈ›ie cÄƒ cele mai puternice abstractizÄƒri sunt adesea cele mai simple."
                    </blockquote>
                    <p style="text-align: right; color: var(--text-secondary);">â€” J.W.J. Williams</p>
                </div>
            </div>
        </div>

        <!-- Slide 5: What is a Heap? -->
        <div class="slide" data-slide="5">
            <h1>ğŸ“š Ce este un Heap?</h1>
            <div class="info-box">
                <p>Un <strong>heap binar</strong> este un arbore binar complet care satisface <strong>proprietatea heap</strong>.</p>
            </div>
            <div class="two-columns">
                <div class="column">
                    <h3>ğŸ”¼ Max-Heap</h3>
                    <p>Pentru orice nod <code>i</code> diferit de rÄƒdÄƒcinÄƒ:</p>
                    <p style="text-align: center; font-size: 1.5rem; color: var(--accent-green);">
                        <code>A[parent(i)] â‰¥ A[i]</code>
                    </p>
                    <p>RÄƒdÄƒcina conÈ›ine <strong>valoarea maximÄƒ</strong></p>
                </div>
                <div class="column">
                    <h3>ğŸ”½ Min-Heap</h3>
                    <p>Pentru orice nod <code>i</code> diferit de rÄƒdÄƒcinÄƒ:</p>
                    <p style="text-align: center; font-size: 1.5rem; color: var(--accent-blue);">
                        <code>A[parent(i)] â‰¤ A[i]</code>
                    </p>
                    <p>RÄƒdÄƒcina conÈ›ine <strong>valoarea minimÄƒ</strong></p>
                </div>
            </div>
            <div class="warning-box">
                <p><strong>Proprietatea de formÄƒ:</strong> Un heap este Ã®ntotdeauna un arbore binar <em>complet</em> - toate nivelurile sunt pline, cu excepÈ›ia posibilÄƒ a ultimului, care este umplut de la stÃ¢nga la dreapta.</p>
            </div>
        </div>

        <!-- Slide 6: Heap vs BST -->
        <div class="slide" data-slide="6">
            <h1>ğŸ”„ Heap vs. Binary Search Tree</h1>
            <table>
                <tr>
                    <th>CaracteristicÄƒ</th>
                    <th>Heap</th>
                    <th>Binary Search Tree</th>
                </tr>
                <tr>
                    <td>Proprietate de ordine</td>
                    <td>ParÈ›ialÄƒ (pÄƒrinte vs. copii)</td>
                    <td>TotalÄƒ (stÃ¢nga < rÄƒdÄƒcinÄƒ < dreapta)</td>
                </tr>
                <tr>
                    <td>Forma arborelui</td>
                    <td>Ãntotdeauna complet</td>
                    <td>Poate fi dezechilibrat</td>
                </tr>
                <tr>
                    <td>GÄƒsire min/max</td>
                    <td><span class="complexity good">O(1)</span></td>
                    <td><span class="complexity moderate">O(log n) - O(n)</span></td>
                </tr>
                <tr>
                    <td>CÄƒutare element arbitrar</td>
                    <td><span class="complexity bad">O(n)</span></td>
                    <td><span class="complexity good">O(log n)</span> (dacÄƒ echilibrat)</td>
                </tr>
                <tr>
                    <td>Reprezentare Ã®n memorie</td>
                    <td>Array (compactÄƒ)</td>
                    <td>Pointeri (overhead)</td>
                </tr>
            </table>
        </div>

        <!-- Slide 7: Array Representation -->
        <div class="slide" data-slide="7">
            <h1>ğŸ“Š Reprezentarea Ã®n Array</h1>
            <div class="diagram">
              Max-Heap ca Arbore                     Reprezentare Ã®n Array

                    â”Œâ”€â”€â”€â”€â”                    Index:   0    1    2    3    4    5    6
                    â”‚ 90 â”‚                    Array: [ 90 | 85 | 80 | 70 | 60 | 50 | 30 ]
                    â””â”€â”€â”¬â”€â”˜                              â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”                        â””â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”´â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”´â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”˜
             â”Œâ”€â”´â”€â”           â”Œâ”€â”´â”€â”                           â”‚         â”‚         â”‚
             â”‚85 â”‚           â”‚80 â”‚                      Nivel 0    Nivel 1    Nivel 2
             â””â”€â”¬â”€â”˜           â””â”€â”¬â”€â”˜
          â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
        â”Œâ”€â”´â”€â”    â”Œâ”€â”€â”´â”€â” â”Œâ”€â”´â”€â”    â”Œâ”€â”€â”´â”€â”
        â”‚70 â”‚    â”‚ 60 â”‚ â”‚50 â”‚    â”‚ 30 â”‚
        â””â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”˜
            </div>
            <div class="info-box">
                <h3>Formule de Navigare (indexare de la 0):</h3>
                <ul>
                    <li><code>parent(i) = (i - 1) / 2</code></li>
                    <li><code>left_child(i) = 2 * i + 1</code></li>
                    <li><code>right_child(i) = 2 * i + 2</code></li>
                </ul>
            </div>
        </div>

        <!-- Slide 8: Navigation Functions -->
        <div class="slide" data-slide="8">
            <h1>ğŸ§­ FuncÈ›ii de Navigare Ã®n C</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>Macros pentru navigare Ã®n heap</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/* Indexare de la 0 */
#define PARENT(i)      (((i) - 1) / 2)
#define LEFT_CHILD(i)  ((2 * (i)) + 1)
#define RIGHT_CHILD(i) ((2 * (i)) + 2)

/* Exemplu de utilizare */
int arr[] = {90, 85, 80, 70, 60, 50, 30};

/* Pentru nodul cu index 1 (valoarea 85):
 * - PARENT(1) = 0     â†’ arr[0] = 90
 * - LEFT_CHILD(1) = 3 â†’ arr[3] = 70
 * - RIGHT_CHILD(1) = 4 â†’ arr[4] = 60
 */

/* Verificare dacÄƒ un index are copii */
#define HAS_LEFT(i, n)  (LEFT_CHILD(i) < (n))
#define HAS_RIGHT(i, n) (RIGHT_CHILD(i) < (n))</code></pre>
            </div>
            <div class="success-box">
                <p><strong>Avantaj:</strong> Nu avem nevoie de pointeri! NavigÄƒm prin calcule aritmetice simple.</p>
            </div>
        </div>

        <!-- Slide 9: Heapify Operation -->
        <div class="slide" data-slide="9">
            <h1>ğŸ”§ OperaÈ›ia Heapify (Sift-Down)</h1>
            <p><strong>Scop:</strong> RestaureazÄƒ proprietatea max-heap pentru un subarbore, presupunÃ¢nd cÄƒ subarborii sunt deja heap-uri valide.</p>
            <div class="code-block">
                <div class="code-header">
                    <span>Implementare max_heapify</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void max_heapify(int arr[], int n, int i) {
    int largest = i;
    int left = LEFT_CHILD(i);
    int right = RIGHT_CHILD(i);

    /* ComparÄƒ cu copilul stÃ¢ng */
    if (left < n && arr[left] > arr[largest])
        largest = left;

    /* ComparÄƒ cu copilul drept */
    if (right < n && arr[right] > arr[largest])
        largest = right;

    /* DacÄƒ cel mai mare nu este rÄƒdÄƒcina */
    if (largest != i) {
        swap(&arr[i], &arr[largest]);
        max_heapify(arr, n, largest);  /* Recursie */
    }
}</code></pre>
            </div>
            <p><strong>Complexitate:</strong> <span class="complexity good">O(log n)</span> - cel mult h paÈ™i, unde h = Ã®nÄƒlÈ›imea arborelui</p>
        </div>

        <!-- Slide 10: Heapify Visualization -->
        <div class="slide" data-slide="10">
            <h1>ğŸ“ˆ Vizualizare Heapify</h1>
            <div class="diagram">
  Pas 0: ÃncÄƒlcare          Pas 1: Swap cu 90           Pas 2: Swap cu 85           Rezultat Final
  la rÄƒdÄƒcinÄƒ
                                                                                    
       â”Œâ”€â”€â”€â”                     â”Œâ”€â”€â”€â”                      â”Œâ”€â”€â”€â”                      â”Œâ”€â”€â”€â”
       â”‚20 â”‚ â† Ã®ncÄƒlcare         â”‚90 â”‚                      â”‚90 â”‚                      â”‚90 â”‚
       â””â”€â”¬â”€â”˜                     â””â”€â”¬â”€â”˜                      â””â”€â”¬â”€â”˜                      â””â”€â”¬â”€â”˜
      â”Œâ”€â”€â”´â”€â”€â”                   â”Œâ”€â”€â”´â”€â”€â”                    â”Œâ”€â”€â”´â”€â”€â”                    â”Œâ”€â”€â”´â”€â”€â”
    â”Œâ”€â”´â”€â” â”Œâ”€â”´â”€â”               â”Œâ”€â”´â”€â” â”Œâ”€â”´â”€â”                â”Œâ”€â”´â”€â” â”Œâ”€â”´â”€â”                â”Œâ”€â”´â”€â” â”Œâ”€â”´â”€â”
    â”‚90 â”‚ â”‚80 â”‚               â”‚20 â”‚ â”‚80 â”‚ â† Ã®ncÄƒlcare    â”‚85 â”‚ â”‚80 â”‚                â”‚85 â”‚ â”‚80 â”‚
    â””â”€â”¬â”€â”˜ â””â”€â”€â”€â”˜               â””â”€â”¬â”€â”˜ â””â”€â”€â”€â”˜                â””â”€â”¬â”€â”˜ â””â”€â”€â”€â”˜                â””â”€â”¬â”€â”˜ â””â”€â”€â”€â”˜
   â”Œâ”€â”€â”´â”€â”€â”                   â”Œâ”€â”€â”´â”€â”€â”                    â”Œâ”€â”€â”´â”€â”€â”                    â”Œâ”€â”€â”´â”€â”€â”
 â”Œâ”€â”´â”€â” â”Œâ”€â”´â”€â”               â”Œâ”€â”´â”€â” â”Œâ”€â”´â”€â”                â”Œâ”€â”´â”€â” â”Œâ”€â”´â”€â”                â”Œâ”€â”´â”€â” â”Œâ”€â”´â”€â”
 â”‚85 â”‚ â”‚70 â”‚               â”‚85 â”‚ â”‚70 â”‚                â”‚20 â”‚ â”‚70 â”‚ âœ“              â”‚70 â”‚ â”‚20 â”‚ âœ“
 â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜               â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜                â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜                â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜
            </div>
            <div class="info-box">
                <p>Valoarea 20 â€scufundÄƒ" pÃ¢nÄƒ gÄƒseÈ™te poziÈ›ia corectÄƒ unde este mai mare decÃ¢t ambii copii (sau devine frunzÄƒ).</p>
            </div>
        </div>

        <!-- Slide 11: Build Heap -->
        <div class="slide" data-slide="11">
            <h1>ğŸ—ï¸ Construirea Heap-ului (Build-Heap)</h1>
            <p>TransformÄƒ un array arbitrar Ã®ntr-un heap valid Ã®n timp <span class="complexity good">O(n)</span>.</p>
            <div class="code-block">
                <div class="code-header">
                    <span>Algoritmul Build-Heap (Floyd)</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void build_max_heap(int arr[], int n) {
    /* Ãncepem de la ultimul nod non-frunzÄƒ */
    /* Frunzele sunt de la n/2 pÃ¢nÄƒ la n-1 */
    int start_idx = (n / 2) - 1;

    /* Heapify de jos Ã®n sus */
    for (int i = start_idx; i >= 0; i--) {
        max_heapify(arr, n, i);
    }
}

/* Utilizare */
int arr[] = {4, 10, 3, 5, 1, 8, 7};
int n = 7;
build_max_heap(arr, n);
/* Rezultat: {10, 5, 8, 4, 1, 3, 7} */</code></pre>
            </div>
            <div class="warning-box">
                <p><strong>De ce O(n) È™i nu O(n log n)?</strong> Majoritatea nodurilor sunt la niveluri joase È™i necesitÄƒ puÈ›ini paÈ™i. Analiza matematicÄƒ aratÄƒ cÄƒ suma totalÄƒ este liniarÄƒ.</p>
            </div>
        </div>

        <!-- Slide 12: Build Heap Complexity Proof -->
        <div class="slide" data-slide="12">
            <h1>ğŸ“ DemonstraÈ›ie: Build-Heap este O(n)</h1>
            <div class="two-columns">
                <div class="column">
                    <h3>DistribuÈ›ia Nodurilor</h3>
                    <table>
                        <tr>
                            <th>Nivel h</th>
                            <th>Nr. Noduri</th>
                            <th>PaÈ™i Heapify</th>
                        </tr>
                        <tr>
                            <td>0 (frunze)</td>
                            <td>â‰¤ n/2</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>â‰¤ n/4</td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td>â‰¤ n/8</td>
                            <td>2</td>
                        </tr>
                        <tr>
                            <td>...</td>
                            <td>...</td>
                            <td>...</td>
                        </tr>
                        <tr>
                            <td>log n</td>
                            <td>1</td>
                            <td>log n</td>
                        </tr>
                    </table>
                </div>
                <div class="column">
                    <h3>Calcul Total</h3>
                    <p>Suma operaÈ›iilor:</p>
                    <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px; font-family: monospace;">
                        T(n) = Î£(h=0 la log n) âŒˆn/2^(h+1)âŒ‰ Â· O(h)<br><br>
                        = O(n Â· Î£(h=0 la âˆ) h/2^h)<br><br>
                        = O(n Â· 2) = <strong style="color: var(--accent-green);">O(n)</strong>
                    </div>
                    <div class="success-box" style="margin-top: 1rem;">
                        <p>Seria Î£ h/2^h converge la 2!</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 13: Heap Sort Algorithm -->
        <div class="slide" data-slide="13">
            <h1>ğŸ”¢ Algoritmul Heap Sort</h1>
            <div class="info-box">
                <p><strong>Ideea principalÄƒ:</strong> ConstruieÈ™te un max-heap, apoi extrage repetat maximul È™i pune-l la sfÃ¢rÈ™itul array-ului.</p>
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>Implementare Heap Sort</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void heap_sort(int arr[], int n) {
    /* Pas 1: ConstruieÈ™te max-heap - O(n) */
    build_max_heap(arr, n);

    /* Pas 2: Extrage elementele unul cÃ¢te unul - O(n log n) */
    for (int i = n - 1; i > 0; i--) {
        /* MutÄƒ rÄƒdÄƒcina (maximul) la sfÃ¢rÈ™it */
        swap(&arr[0], &arr[i]);

        /* Heapify pe heap-ul redus */
        max_heapify(arr, i, 0);
    }
}

/* Complexitate totalÄƒ: O(n) + O(n log n) = O(n log n) */</code></pre>
            </div>
        </div>

        <!-- Slide 14: Heap Sort Visualization -->
        <div class="slide" data-slide="14">
            <h1>ğŸ“Š Vizualizare Heap Sort</h1>
            <div class="diagram">
  Array iniÈ›ial: [4, 10, 3, 5, 1]

  Build Heap:    [10, 5, 3, 4, 1]     â† Max-heap construit

  IteraÈ›ia 1:    [1, 5, 3, 4 | 10]   â† Swap 10â†”1, heapify
                 [5, 4, 3, 1 | 10]   â† DupÄƒ heapify

  IteraÈ›ia 2:    [1, 4, 3 | 5, 10]   â† Swap 5â†”1, heapify
                 [4, 1, 3 | 5, 10]   â† DupÄƒ heapify

  IteraÈ›ia 3:    [3, 1 | 4, 5, 10]   â† Swap 4â†”3, heapify
                 [3, 1 | 4, 5, 10]   â† DupÄƒ heapify

  IteraÈ›ia 4:    [1 | 3, 4, 5, 10]   â† Swap 3â†”1

  Rezultat:      [1, 3, 4, 5, 10]    â† Array sortat!
            </div>
            <div class="success-box">
                <p><strong>Sortare in-place!</strong> Nu necesitÄƒ memorie auxiliarÄƒ (doar O(1) pentru variabile temporare).</p>
            </div>
        </div>

        <!-- Slide 15: Heap Sort Properties -->
        <div class="slide" data-slide="15">
            <h1>âš–ï¸ ProprietÄƒÈ›ile Heap Sort</h1>
            <table>
                <tr>
                    <th>Proprietate</th>
                    <th>Heap Sort</th>
                    <th>Quick Sort</th>
                    <th>Merge Sort</th>
                </tr>
                <tr>
                    <td>Timp Best Case</td>
                    <td><span class="complexity moderate">O(n log n)</span></td>
                    <td><span class="complexity good">O(n log n)</span></td>
                    <td><span class="complexity moderate">O(n log n)</span></td>
                </tr>
                <tr>
                    <td>Timp Worst Case</td>
                    <td><span class="complexity good">O(n log n)</span></td>
                    <td><span class="complexity bad">O(nÂ²)</span></td>
                    <td><span class="complexity good">O(n log n)</span></td>
                </tr>
                <tr>
                    <td>SpaÈ›iu Auxiliar</td>
                    <td><span class="complexity good">O(1)</span></td>
                    <td><span class="complexity moderate">O(log n)</span></td>
                    <td><span class="complexity bad">O(n)</span></td>
                </tr>
                <tr>
                    <td>Stabilitate</td>
                    <td><span class="complexity bad">Instabil</span></td>
                    <td><span class="complexity bad">Instabil</span></td>
                    <td><span class="complexity good">Stabil</span></td>
                </tr>
                <tr>
                    <td>Cache-friendly</td>
                    <td><span class="complexity bad">Nu</span></td>
                    <td><span class="complexity good">Da</span></td>
                    <td><span class="complexity moderate">ParÈ›ial</span></td>
                </tr>
            </table>
            <div class="warning-box">
                <p><strong>De ce Heap Sort nu este stabil?</strong> OperaÈ›ia de swap la extragere poate modifica ordinea relativÄƒ a elementelor egale.</p>
            </div>
        </div>

        <!-- Slide 16: Priority Queue Concept -->
        <div class="slide" data-slide="16">
            <h1>ğŸ“‹ Priority Queue - Concept</h1>
            <div class="info-box">
                <p>O <strong>priority queue</strong> este o structurÄƒ de date abstractÄƒ care permite inserarea elementelor cu prioritÄƒÈ›i È™i extragerea elementului cu cea mai mare (sau mai micÄƒ) prioritate.</p>
            </div>
            <div class="two-columns">
                <div class="column">
                    <h3>OperaÈ›ii de BazÄƒ</h3>
                    <ul>
                        <li><code>insert(element, priority)</code> - AdaugÄƒ element</li>
                        <li><code>extract_max()</code> - Scoate È™i returneazÄƒ max</li>
                        <li><code>peek()</code> - ReturneazÄƒ max fÄƒrÄƒ a-l scoate</li>
                        <li><code>increase_key(i, new_key)</code> - MÄƒreÈ™te prioritate</li>
                        <li><code>is_empty()</code> - VerificÄƒ dacÄƒ e goalÄƒ</li>
                    </ul>
                </div>
                <div class="column">
                    <h3>ImplementÄƒri Posibile</h3>
                    <table>
                        <tr>
                            <th>Implementare</th>
                            <th>Insert</th>
                            <th>Extract</th>
                        </tr>
                        <tr>
                            <td>Array nesortat</td>
                            <td><span class="complexity good">O(1)</span></td>
                            <td><span class="complexity bad">O(n)</span></td>
                        </tr>
                        <tr>
                            <td>Array sortat</td>
                            <td><span class="complexity bad">O(n)</span></td>
                            <td><span class="complexity good">O(1)</span></td>
                        </tr>
                        <tr>
                            <td><strong>Heap</strong></td>
                            <td><span class="complexity good">O(log n)</span></td>
                            <td><span class="complexity good">O(log n)</span></td>
                        </tr>
                    </table>
                </div>
            </div>
        </div>

        <!-- Slide 17: Priority Queue Insert -->
        <div class="slide" data-slide="17">
            <h1>â• Priority Queue: Inserare (Sift-Up)</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>Inserare Ã®n Max-Heap</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void pq_insert(PriorityQueue *pq, int key) {
    /* VerificÄƒ capacitatea */
    if (pq->size >= pq->capacity) {
        pq_resize(pq, pq->capacity * 2);
    }

    /* AdaugÄƒ la sfÃ¢rÈ™itul heap-ului */
    int i = pq->size;
    pq->data[i] = key;
    pq->size++;

    /* Sift-up: urcÄƒ pÃ¢nÄƒ la poziÈ›ia corectÄƒ */
    while (i > 0 && pq->data[PARENT(i)] < pq->data[i]) {
        swap(&pq->data[i], &pq->data[PARENT(i)]);
        i = PARENT(i);
    }
}</code></pre>
            </div>
            <div class="diagram" style="font-size: 0.9rem;">
  Inserare 95 Ã®n heap:      DupÄƒ sift-up:

       â”Œâ”€â”€â”€â”                     â”Œâ”€â”€â”€â”
       â”‚90 â”‚                     â”‚95 â”‚ â† 95 a urcat
       â””â”€â”¬â”€â”˜                     â””â”€â”¬â”€â”˜
      â”Œâ”€â”€â”´â”€â”€â”                   â”Œâ”€â”€â”´â”€â”€â”
    â”Œâ”€â”´â”€â” â”Œâ”€â”´â”€â”               â”Œâ”€â”´â”€â” â”Œâ”€â”´â”€â”
    â”‚85 â”‚ â”‚80 â”‚               â”‚90 â”‚ â”‚80 â”‚
    â””â”€â”¬â”€â”˜ â””â”€â”€â”€â”˜               â””â”€â”¬â”€â”˜ â””â”€â”€â”€â”˜
  â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”                 â”Œâ”€â”€â”´â”€â”€â”€â”
â”Œâ”€â”´â”€â”   â”Œâ”€â”€â”´â”€â”             â”Œâ”€â”´â”€â” â”Œâ”€â”€â”´â”€â”
â”‚70 â”‚   â”‚ 95 â”‚ â† nou       â”‚70 â”‚ â”‚ 85 â”‚
â””â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”˜             â””â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜
            </div>
        </div>

        <!-- Slide 18: Priority Queue Extract -->
        <div class="slide" data-slide="18">
            <h1>â– Priority Queue: Extragere Maximum</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>Extract-Max din Heap</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">int pq_extract_max(PriorityQueue *pq) {
    if (pq->size == 0) {
        fprintf(stderr, "Eroare: Priority queue goalÄƒ!\n");
        exit(EXIT_FAILURE);
    }

    int max = pq->data[0];  /* SalveazÄƒ maximul */

    /* MutÄƒ ultimul element la rÄƒdÄƒcinÄƒ */
    pq->data[0] = pq->data[pq->size - 1];
    pq->size--;

    /* RestaureazÄƒ proprietatea heap */
    if (pq->size > 0) {
        max_heapify(pq->data, pq->size, 0);
    }

    return max;
}</code></pre>
            </div>
            <p><strong>Complexitate:</strong> <span class="complexity good">O(log n)</span> - heapify de la rÄƒdÄƒcinÄƒ Ã®n jos.</p>
        </div>

        <!-- Slide 19: Complete Priority Queue Structure -->
        <div class="slide" data-slide="19">
            <h1>ğŸ›ï¸ Structura CompletÄƒ Priority Queue</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>DefiniÈ›ia structurii</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">typedef struct {
    int *data;       /* Array-ul de elemente */
    int size;        /* NumÄƒrul curent de elemente */
    int capacity;    /* Capacitatea alocatÄƒ */
} PriorityQueue;

/* FuncÈ›ii de gestionare a memoriei */
PriorityQueue* pq_create(int initial_capacity) {
    PriorityQueue *pq = malloc(sizeof(PriorityQueue));
    if (!pq) return NULL;
    
    pq->data = malloc(initial_capacity * sizeof(int));
    if (!pq->data) {
        free(pq);
        return NULL;
    }
    
    pq->size = 0;
    pq->capacity = initial_capacity;
    return pq;
}

void pq_destroy(PriorityQueue *pq) {
    if (pq) {
        free(pq->data);
        free(pq);
    }
}</code></pre>
            </div>
        </div>

        <!-- Slide 20: Increase Key -->
        <div class="slide" data-slide="20">
            <h1>â¬†ï¸ OperaÈ›ia Increase-Key</h1>
            <p>MÄƒreÈ™te valoarea unui element È™i restaureazÄƒ proprietatea heap.</p>
            <div class="code-block">
                <div class="code-header">
                    <span>Increase-Key cu sift-up</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void pq_increase_key(PriorityQueue *pq, int i, int new_key) {
    if (new_key < pq->data[i]) {
        fprintf(stderr, "Eroare: Cheia nouÄƒ este mai micÄƒ!\n");
        return;
    }

    pq->data[i] = new_key;

    /* Sift-up: urcÄƒ pÃ¢nÄƒ proprietatea heap e satisfÄƒcutÄƒ */
    while (i > 0 && pq->data[PARENT(i)] < pq->data[i]) {
        swap(&pq->data[i], &pq->data[PARENT(i)]);
        i = PARENT(i);
    }
}

/* Complexitate: O(log n) - cel mult h paÈ™i Ã®n sus */</code></pre>
            </div>
            <div class="info-box">
                <p><strong>Utilizare:</strong> EsenÈ›ialÄƒ Ã®n algoritmul Dijkstra cÃ¢nd descoperim un drum mai scurt cÄƒtre un nod.</p>
            </div>
        </div>

        <!-- Slide 21: Delete Operation -->
        <div class="slide" data-slide="21">
            <h1>ğŸ—‘ï¸ OperaÈ›ia Delete</h1>
            <p>È˜terge un element arbitrar din heap.</p>
            <div class="code-block">
                <div class="code-header">
                    <span>È˜tergere element din heap</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void pq_delete(PriorityQueue *pq, int i) {
    if (i < 0 || i >= pq->size) {
        fprintf(stderr, "Eroare: Index invalid!\n");
        return;
    }

    /* CreÈ™te la +infinit È™i extrage */
    pq->data[i] = INT_MAX;
    
    /* Sift-up la rÄƒdÄƒcinÄƒ */
    while (i > 0) {
        swap(&pq->data[i], &pq->data[PARENT(i)]);
        i = PARENT(i);
    }
    
    /* Extrage maximul (elementul nostru) */
    pq_extract_max(pq);
}

/* Alternativ: Ã®nlocuieÈ™te cu ultimul È™i heapify */</code></pre>
            </div>
            <p><strong>Complexitate:</strong> <span class="complexity good">O(log n)</span></p>
        </div>

        <!-- Slide 22: Min-Heap Implementation -->
        <div class="slide" data-slide="22">
            <h1>ğŸ”½ Min-Heap: ModificÄƒri Necesare</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>DiferenÈ›e faÈ›Äƒ de Max-Heap</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/* Min-Heapify: inversÄƒm comparaÈ›iile */
void min_heapify(int arr[], int n, int i) {
    int smallest = i;  /* NU largest */
    int left = LEFT_CHILD(i);
    int right = RIGHT_CHILD(i);

    if (left < n && arr[left] < arr[smallest])  /* < NU > */
        smallest = left;

    if (right < n && arr[right] < arr[smallest]) /* < NU > */
        smallest = right;

    if (smallest != i) {
        swap(&arr[i], &arr[smallest]);
        min_heapify(arr, n, smallest);
    }
}

/* Insert: comparaÈ›ie inversatÄƒ pentru sift-up */
while (i > 0 && pq->data[PARENT(i)] > pq->data[i]) { /* > NU < */
    swap(&pq->data[i], &pq->data[PARENT(i)]);
    i = PARENT(i);
}</code></pre>
            </div>
        </div>

        <!-- Slide 23: Common Mistakes -->
        <div class="slide" data-slide="23">
            <h1>âš ï¸ GreÈ™eli Frecvente</h1>
            <div class="error-box">
                <h3>âŒ GreÈ™eala 1: Indexare greÈ™itÄƒ</h3>
                <pre><code class="language-c">/* GREÈ˜IT - indexare de la 1 cu array de la 0 */
int parent = i / 2;  /* FuncÈ›ioneazÄƒ doar pentru indexare de la 1! */

/* CORECT - indexare de la 0 */
int parent = (i - 1) / 2;</code></pre>
            </div>
            <div class="error-box">
                <h3>âŒ GreÈ™eala 2: Build-heap de sus Ã®n jos</h3>
                <pre><code class="language-c">/* GREÈ˜IT - nu garanteazÄƒ proprietatea heap */
for (int i = 0; i < n; i++) heapify(arr, n, i);

/* CORECT - de jos Ã®n sus */
for (int i = n/2 - 1; i >= 0; i--) heapify(arr, n, i);</code></pre>
            </div>
            <div class="error-box">
                <h3>âŒ GreÈ™eala 3: Uitarea verificÄƒrii limitelor</h3>
                <pre><code class="language-c">/* GREÈ˜IT - poate accesa Ã®n afara array-ului */
if (arr[left] > arr[largest]) ...

/* CORECT - verificÄƒ mai Ã®ntÃ¢i dacÄƒ copilul existÄƒ */
if (left < n && arr[left] > arr[largest]) ...</code></pre>
            </div>
        </div>

        <!-- Slide 24: More Common Mistakes -->
        <div class="slide" data-slide="24">
            <h1>âš ï¸ GreÈ™eli Frecvente (continuare)</h1>
            <div class="error-box">
                <h3>âŒ GreÈ™eala 4: Memory leak la resize</h3>
                <pre><code class="language-c">/* GREÈ˜IT - pierde pointer-ul original dacÄƒ realloc eÈ™ueazÄƒ */
pq->data = realloc(pq->data, new_capacity * sizeof(int));

/* CORECT - verificÄƒ rezultatul */
int *new_data = realloc(pq->data, new_capacity * sizeof(int));
if (new_data) {
    pq->data = new_data;
    pq->capacity = new_capacity;
}</code></pre>
            </div>
            <div class="error-box">
                <h3>âŒ GreÈ™eala 5: Heap sort cu heap incorect</h3>
                <pre><code class="language-c">/* GREÈ˜IT - heapify pe toÈ›i indicii */
for (int i = n - 1; i >= 0; i--) heapify(arr, i, 0);

/* CORECT - heapify de la rÄƒdÄƒcinÄƒ, cu dimensiune redusÄƒ */
for (int i = n - 1; i > 0; i--) {
    swap(&arr[0], &arr[i]);
    heapify(arr, i, 0);  /* i este noua dimensiune */
}</code></pre>
            </div>
        </div>

        <!-- Slide 25: Debugging with GDB -->
        <div class="slide" data-slide="25">
            <h1>ğŸ” Debugging cu GDB</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>Comenzi utile GDB pentru heap</span>
                    <span class="lang-badge">Bash</span>
                </div>
                <pre><code class="language-bash"># Compilare cu simboluri debug
gcc -g -Wall -Wextra -std=c11 -o heap heap.c

# Pornire GDB
gdb ./heap

# Comenzi Ã®n GDB:
(gdb) break max_heapify        # Breakpoint la funcÈ›ie
(gdb) run                       # RuleazÄƒ programul
(gdb) print arr[0]@10          # AfiÈ™eazÄƒ primele 10 elemente
(gdb) print *pq                # AfiÈ™eazÄƒ structura
(gdb) watch pq->size           # OpreÈ™te cÃ¢nd size se schimbÄƒ
(gdb) backtrace                # Stack trace la crash

# AfiÈ™are array ca heap
(gdb) define print_heap
    set $i = 0
    while $i < $arg1
        printf "[%d]=%d ", $i, $arg0[$i]
        set $i = $i + 1
    end
    printf "\n"
end
(gdb) print_heap arr n</code></pre>
            </div>
        </div>

        <!-- Slide 26: Valgrind Memory Check -->
        <div class="slide" data-slide="26">
            <h1>ğŸ§ª Verificare Memorie cu Valgrind</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>Verificare memory leaks</span>
                    <span class="lang-badge">Bash</span>
                </div>
                <pre><code class="language-bash"># Verificare completÄƒ
valgrind --leak-check=full --show-leak-kinds=all ./heap

# Output ideal (fÄƒrÄƒ leak-uri):
==12345== HEAP SUMMARY:
==12345==     in use at exit: 0 bytes in 0 blocks
==12345==   total heap usage: 42 allocs, 42 frees, 8,192 bytes allocated
==12345== All heap blocks were freed -- no leaks are possible

# Verificare accese invalide
valgrind --track-origins=yes ./heap

# Eroare tipicÄƒ pentru heap:
==12345== Invalid read of size 4
==12345==    at 0x401234: max_heapify (heap.c:45)
==12345==  Address 0x1234 is 4 bytes after a block of size 40</code></pre>
            </div>
            <div class="success-box">
                <p><strong>RegulÄƒ de aur:</strong> NumÄƒrul de <code>allocs</code> trebuie sÄƒ fie egal cu numÄƒrul de <code>frees</code>!</p>
            </div>
        </div>

        <!-- Slide 27: Application - Dijkstra -->
        <div class="slide" data-slide="27">
            <h1>ğŸ—ºï¸ AplicaÈ›ie: Algoritmul Dijkstra</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>Dijkstra cu Min-Heap Priority Queue</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void dijkstra(Graph *g, int src, int dist[]) {
    MinPQ *pq = min_pq_create(g->V);
    
    for (int v = 0; v < g->V; v++)
        dist[v] = INT_MAX;
    dist[src] = 0;
    
    min_pq_insert(pq, src, 0);  /* (nod, distanÈ›Äƒ) */
    
    while (!min_pq_is_empty(pq)) {
        int u = min_pq_extract_min(pq);
        
        for (Edge *e = g->adj[u]; e; e = e->next) {
            int v = e->dest;
            int w = e->weight;
            
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                min_pq_decrease_key(pq, v, dist[v]);
            }
        }
    }
    min_pq_destroy(pq);
}</code></pre>
            </div>
            <p><strong>Complexitate:</strong> <span class="complexity good">O((V + E) log V)</span> cu binary heap</p>
        </div>

        <!-- Slide 28: Application - Huffman -->
        <div class="slide" data-slide="28">
            <h1>ğŸ“¦ AplicaÈ›ie: Codificare Huffman</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>ConstrucÈ›ia arborelui Huffman</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">HuffmanNode* build_huffman_tree(char chars[], int freqs[], int n) {
    /* CreeazÄƒ min-heap cu nodurile iniÈ›iale */
    MinHeap *heap = create_min_heap(n);
    for (int i = 0; i < n; i++) {
        HuffmanNode *node = create_leaf_node(chars[i], freqs[i]);
        insert_min_heap(heap, node);
    }
    
    /* CombinÄƒ pÃ¢nÄƒ rÄƒmÃ¢ne un singur nod */
    while (heap->size > 1) {
        HuffmanNode *left = extract_min(heap);
        HuffmanNode *right = extract_min(heap);
        
        /* CreeazÄƒ nod intern cu suma frecvenÈ›elor */
        HuffmanNode *parent = create_internal_node(
            left->freq + right->freq, left, right
        );
        insert_min_heap(heap, parent);
    }
    
    return extract_min(heap);  /* RÄƒdÄƒcina arborelui */
}</code></pre>
            </div>
        </div>

        <!-- Slide 29: Application - Median Maintenance -->
        <div class="slide" data-slide="29">
            <h1>ğŸ“Š AplicaÈ›ie: MenÈ›inerea Medianei</h1>
            <div class="info-box">
                <p><strong>ProblemÄƒ:</strong> Ãntr-un stream de numere, menÈ›ine mediana curentÄƒ eficient.</p>
                <p><strong>SoluÈ›ie:</strong> DouÄƒ heap-uri - max-heap pentru jumÄƒtatea inferioarÄƒ, min-heap pentru jumÄƒtatea superioarÄƒ.</p>
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>Streaming Median</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">typedef struct {
    MaxHeap *lower;  /* JumÄƒtatea micÄƒ */
    MinHeap *upper;  /* JumÄƒtatea mare */
} MedianFinder;

void add_num(MedianFinder *mf, int num) {
    if (max_heap_is_empty(mf->lower) || num <= max_heap_peek(mf->lower))
        max_heap_insert(mf->lower, num);
    else
        min_heap_insert(mf->upper, num);
    
    /* Rebalansare */
    balance_heaps(mf);
}

double get_median(MedianFinder *mf) {
    if (mf->lower->size > mf->upper->size)
        return max_heap_peek(mf->lower);
    return (max_heap_peek(mf->lower) + min_heap_peek(mf->upper)) / 2.0;
}</code></pre>
            </div>
        </div>

        <!-- Slide 30: D-ary Heaps -->
        <div class="slide" data-slide="30">
            <h1>ğŸ”¢ Heap-uri D-are</h1>
            <div class="info-box">
                <p>Un <strong>d-ary heap</strong> este o generalizare Ã®n care fiecare nod are d copii Ã®n loc de 2.</p>
            </div>
            <div class="two-columns">
                <div class="column">
                    <h3>Formule de Navigare</h3>
                    <ul>
                        <li><code>parent(i) = (i - 1) / d</code></li>
                        <li><code>child_k(i) = d * i + k + 1</code></li>
                        <li>unde k âˆˆ {0, 1, ..., d-1}</li>
                    </ul>
                </div>
                <div class="column">
                    <h3>Trade-offs</h3>
                    <table>
                        <tr>
                            <th>OperaÈ›ie</th>
                            <th>Binary</th>
                            <th>D-ary</th>
                        </tr>
                        <tr>
                            <td>Insert</td>
                            <td>O(logâ‚‚ n)</td>
                            <td>O(log_d n)</td>
                        </tr>
                        <tr>
                            <td>Extract</td>
                            <td>O(logâ‚‚ n)</td>
                            <td>O(dÂ·log_d n)</td>
                        </tr>
                    </table>
                </div>
            </div>
            <div class="success-box">
                <p><strong>CÃ¢nd e util?</strong> D-ary heaps sunt mai bune cÃ¢nd decrease-key este frecvent (ex: Dijkstra pe grafuri dense). D=4 este adesea optim Ã®n practicÄƒ datoritÄƒ cache-ului CPU.</p>
            </div>
        </div>

        <!-- Slide 31: Best Practices -->
        <div class="slide" data-slide="31">
            <h1>âœ… Bune Practici</h1>
            <div class="two-columns">
                <div class="column">
                    <h3 style="color: var(--accent-green);">âœ“ DO</h3>
                    <ul>
                        <li>FoloseÈ™te macro-uri pentru navigare</li>
                        <li>VerificÄƒ Ã®ntotdeauna limitele array-ului</li>
                        <li>Alege min vs max-heap Ã®n funcÈ›ie de nevoie</li>
                        <li>FoloseÈ™te build_heap O(n) pentru construcÈ›ie</li>
                        <li>TesteazÄƒ cu Valgrind Ã®nainte de submission</li>
                        <li>DocumenteazÄƒ invarianÈ›ii heap-ului</li>
                        <li>ConsiderÄƒ d-ary heaps pentru decrease-key frecvent</li>
                    </ul>
                </div>
                <div class="column">
                    <h3 style="color: var(--accent-red);">âœ— DON'T</h3>
                    <ul>
                        <li>Nu amesteca indexare de la 0 È™i de la 1</li>
                        <li>Nu uita sÄƒ eliberezi memoria</li>
                        <li>Nu presupune cÄƒ heap-ul e sortat</li>
                        <li>Nu folosii heap pentru cÄƒutare generalÄƒ</li>
                        <li>Nu ignora edge cases (heap gol)</li>
                        <li>Nu copia pointeri fÄƒrÄƒ grijÄƒ la resize</li>
                        <li>Nu presupune stabilitatea heap sort</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 32: Complexity Summary -->
        <div class="slide" data-slide="32">
            <h1>ğŸ“Š Rezumat ComplexitÄƒÈ›i</h1>
            <table>
                <tr>
                    <th>OperaÈ›ie</th>
                    <th>Complexitate</th>
                    <th>ObservaÈ›ii</th>
                </tr>
                <tr>
                    <td>create</td>
                    <td><span class="complexity good">O(1)</span></td>
                    <td>AlocÄƒ structura goalÄƒ</td>
                </tr>
                <tr>
                    <td>insert</td>
                    <td><span class="complexity good">O(log n)</span></td>
                    <td>Sift-up de la frunzÄƒ</td>
                </tr>
                <tr>
                    <td>peek (get-max/min)</td>
                    <td><span class="complexity good">O(1)</span></td>
                    <td>ReturneazÄƒ rÄƒdÄƒcina</td>
                </tr>
                <tr>
                    <td>extract-max/min</td>
                    <td><span class="complexity good">O(log n)</span></td>
                    <td>Heapify de la rÄƒdÄƒcinÄƒ</td>
                </tr>
                <tr>
                    <td>increase/decrease-key</td>
                    <td><span class="complexity good">O(log n)</span></td>
                    <td>Sift-up sau sift-down</td>
                </tr>
                <tr>
                    <td>delete</td>
                    <td><span class="complexity good">O(log n)</span></td>
                    <td>Ãnlocuire + heapify</td>
                </tr>
                <tr>
                    <td>build-heap</td>
                    <td><span class="complexity good">O(n)</span></td>
                    <td>Bottom-up (Floyd)</td>
                </tr>
                <tr>
                    <td>heap-sort</td>
                    <td><span class="complexity moderate">O(n log n)</span></td>
                    <td>Build + n extracÈ›ii</td>
                </tr>
                <tr>
                    <td>search</td>
                    <td><span class="complexity bad">O(n)</span></td>
                    <td>Trebuie parcurs tot</td>
                </tr>
            </table>
        </div>

        <!-- Slide 33: Comparison with STL -->
        <div class="slide" data-slide="33">
            <h1>ğŸ”„ Heap Ã®n Biblioteci Standard</h1>
            <div class="three-columns">
                <div class="column">
                    <h3>C (manual)</h3>
                    <pre><code class="language-c">// Nu existÄƒ built-in
// Implementare manualÄƒ

void heapify(...);
void build_heap(...);
void heap_sort(...);</code></pre>
                </div>
                <div class="column">
                    <h3>C++ STL</h3>
                    <pre><code class="language-c">// &lt;algorithm&gt;
make_heap(v.begin(), v.end());
push_heap(...);
pop_heap(...);

// &lt;queue&gt;
priority_queue&lt;int&gt; pq;</code></pre>
                </div>
                <div class="column">
                    <h3>Python</h3>
                    <pre><code class="language-python">import heapq

# Min-heap implicit
heapq.heappush(h, x)
heapq.heappop(h)
heapq.heapify(list)

# Max: foloseÈ™te -x</code></pre>
                </div>
            </div>
            <div class="warning-box">
                <p><strong>NotÄƒ:</strong> Ãn acest curs implementÄƒm manual pentru a Ã®nÈ›elege mecanismul. Ãn producÈ›ie, folosiÈ›i bibliotecile standard!</p>
            </div>
        </div>

        <!-- Slide 34: Laboratory Preview -->
        <div class="slide" data-slide="34">
            <h1>ğŸ’» Previzualizare Laborator</h1>
            <div class="two-columns">
                <div class="column">
                    <h3>ExerciÈ›iul 1: Priority Queue</h3>
                    <p>ImplementaÈ›i o coadÄƒ cu prioritÄƒÈ›i completÄƒ:</p>
                    <ul>
                        <li>Structura PriorityQueue cu max-heap</li>
                        <li>FuncÈ›ii: create, insert, extract_max, peek</li>
                        <li>Redimensionare dinamicÄƒ automatÄƒ</li>
                        <li>Gestionare corectÄƒ a memoriei</li>
                        <li>8-10 TODO markers de completat</li>
                    </ul>
                </div>
                <div class="column">
                    <h3>ExerciÈ›iul 2: Heap Sort</h3>
                    <p>ImplementaÈ›i algoritmul Heap Sort:</p>
                    <ul>
                        <li>FuncÈ›ia heapify (sift-down)</li>
                        <li>ConstrucÈ›ia heap-ului O(n)</li>
                        <li>Sortare in-place</li>
                        <li>ComparaÈ›ie cu qsort()</li>
                        <li>10-12 TODO markers de completat</li>
                    </ul>
                </div>
            </div>
            <div class="info-box">
                <p><strong>Timp estimat:</strong> 2-3 ore | <strong>Dificultate:</strong> Medie</p>
            </div>
        </div>

        <!-- Slide 35: Key Takeaways -->
        <div class="slide" data-slide="35">
            <h1>ğŸ¯ Concluzii Cheie</h1>
            <div class="summary-grid">
                <div class="summary-item">
                    <div class="icon">ğŸ”º</div>
                    <h3>StructurÄƒ</h3>
                    <p>Arbore binar complet cu proprietate de ordine parÈ›ialÄƒ</p>
                </div>
                <div class="summary-item">
                    <div class="icon">ğŸ“Š</div>
                    <h3>Reprezentare</h3>
                    <p>Array cu formule simple de navigare</p>
                </div>
                <div class="summary-item">
                    <div class="icon">âš¡</div>
                    <h3>EficienÈ›Äƒ</h3>
                    <p>Insert/Extract Ã®n O(log n), Build Ã®n O(n)</p>
                </div>
                <div class="summary-item">
                    <div class="icon">ğŸ”„</div>
                    <h3>OperaÈ›ii</h3>
                    <p>Heapify (sift-down) È™i Sift-up</p>
                </div>
                <div class="summary-item">
                    <div class="icon">ğŸ“‹</div>
                    <h3>Priority Queue</h3>
                    <p>ADT ideal implementat cu heap</p>
                </div>
                <div class="summary-item">
                    <div class="icon">ğŸ”¢</div>
                    <h3>Heap Sort</h3>
                    <p>O(n log n) in-place, dar instabil</p>
                </div>
            </div>
        </div>

        <!-- Slide 36: Resources -->
        <div class="slide" data-slide="36">
            <h1>ğŸ“– Resurse Recomandate</h1>
            <div class="two-columns">
                <div class="column">
                    <h3>CÄƒrÈ›i</h3>
                    <ul>
                        <li><strong>CLRS</strong> - Introduction to Algorithms, Cap. 6</li>
                        <li><strong>Sedgewick</strong> - Algorithms, Sec. 2.4</li>
                        <li><strong>Knuth</strong> - TAOCP Vol. 3, Sec. 5.2.3</li>
                    </ul>
                    <h3>Articole Academice</h3>
                    <ul>
                        <li>Williams (1964) - Algorithm 232: Heapsort</li>
                        <li>Floyd (1964) - Algorithm 245: Treesort 3</li>
                        <li>Fredman & Tarjan (1987) - Fibonacci Heaps</li>
                    </ul>
                </div>
                <div class="column">
                    <h3>Online</h3>
                    <ul>
                        <li><a href="https://visualgo.net/en/heap" style="color: var(--accent-blue);">Visualgo - Heap Visualization</a></li>
                        <li><a href="https://www.cs.usfca.edu/~galles/visualization/Heap.html" style="color: var(--accent-blue);">USF Heap Visualization</a></li>
                        <li><a href="https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-spring-2020/" style="color: var(--accent-blue);">MIT OCW 6.006</a></li>
                    </ul>
                    <h3>Practice</h3>
                    <ul>
                        <li>LeetCode: #215, #295, #347, #373</li>
                        <li>HackerRank: Heap Problems</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 37: Questions -->
        <div class="slide title-slide" data-slide="37">
            <h1>â“ ÃntrebÄƒri?</h1>
            <p class="subtitle">MulÈ›umesc pentru atenÈ›ie!</p>
            <div style="margin-top: 2rem;">
                <p class="meta">
                    <strong>SÄƒptÄƒmÃ¢na viitoare:</strong><br>
                    Hash Tables È™i FuncÈ›ii de Dispersie<br><br>
                    ğŸ“§ Contact: [email]@ase.ro
                </p>
            </div>
        </div>
    </div>

    <!-- Navigation -->
    <div class="navigation">
        <button class="nav-btn" id="prevBtn" onclick="changeSlide(-1)">â† Anterior</button>
        <button class="nav-btn" id="nextBtn" onclick="changeSlide(1)">UrmÄƒtor â†’</button>
    </div>

    <!-- Slide Counter -->
    <div class="slide-counter">
        <span id="currentSlide">1</span> / <span id="totalSlides">37</span>
    </div>

    <script>
        // Initialize highlight.js
        hljs.highlightAll();

        let currentSlideIndex = 1;
        const totalSlides = document.querySelectorAll('.slide').length;

        document.getElementById('totalSlides').textContent = totalSlides;

        function showSlide(n) {
            const slides = document.querySelectorAll('.slide');
            
            if (n > totalSlides) currentSlideIndex = 1;
            if (n < 1) currentSlideIndex = totalSlides;

            slides.forEach(slide => {
                slide.classList.remove('active');
            });

            slides[currentSlideIndex - 1].classList.add('active');
            document.getElementById('currentSlide').textContent = currentSlideIndex;
            
            // Update progress bar
            const progress = (currentSlideIndex / totalSlides) * 100;
            document.getElementById('progressBar').style.width = progress + '%';

            // Update navigation buttons
            document.getElementById('prevBtn').disabled = currentSlideIndex === 1;
            document.getElementById('nextBtn').disabled = currentSlideIndex === totalSlides;
        }

        function changeSlide(n) {
            currentSlideIndex += n;
            showSlide(currentSlideIndex);
        }

        function goToSlide(n) {
            currentSlideIndex = n;
            showSlide(currentSlideIndex);
        }

        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            switch(e.key) {
                case 'ArrowRight':
                case ' ':
                    e.preventDefault();
                    changeSlide(1);
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    changeSlide(-1);
                    break;
                case 'Home':
                    e.preventDefault();
                    goToSlide(1);
                    break;
                case 'End':
                    e.preventDefault();
                    goToSlide(totalSlides);
                    break;
            }
        });

        // Initialize
        showSlide(currentSlideIndex);
    </script>
</body>
</html>
