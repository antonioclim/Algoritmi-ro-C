<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SÄƒptÄƒmÃ¢na 20: Programare ParalelÄƒ È™i ConcurentÄƒ Ã®n C</title>
    <style>
        /* =================================================================
         * STILURI GLOBALE È˜I RESET
         * ================================================================= */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* PaletÄƒ de culori pentru concurrency */
            --primary-dark: #1a1a2e;
            --primary-medium: #16213e;
            --primary-light: #0f3460;
            --accent-cyan: #00d9ff;
            --accent-magenta: #ff006e;
            --accent-yellow: #ffbe0b;
            --accent-green: #00f5d4;
            --accent-orange: #fb5607;
            --accent-purple: #8338ec;
            --text-light: #e8e8e8;
            --text-muted: #a0a0a0;
            --code-bg: #0d1117;
            --success: #00ff88;
            --warning: #ffaa00;
            --danger: #ff4444;
            
            /* Thread colors */
            --thread-1: #ff6b6b;
            --thread-2: #4ecdc4;
            --thread-3: #45b7d1;
            --thread-4: #96ceb4;
            --thread-5: #ffeaa7;
            --thread-6: #dfe6e9;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--primary-dark) 0%, var(--primary-medium) 50%, var(--primary-light) 100%);
            color: var(--text-light);
            line-height: 1.6;
            min-height: 100vh;
        }

        /* =================================================================
         * NAVIGARE È˜I HEADER
         * ================================================================= */
        .nav-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(26, 26, 46, 0.95);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--accent-cyan);
            box-shadow: 0 4px 30px rgba(0, 217, 255, 0.2);
        }

        .nav-title {
            font-size: 1.4rem;
            font-weight: bold;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .nav-links {
            display: flex;
            gap: 1.5rem;
            flex-wrap: wrap;
        }

        .nav-links a {
            color: var(--text-light);
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            border: 1px solid transparent;
        }

        .nav-links a:hover {
            background: rgba(0, 217, 255, 0.2);
            border-color: var(--accent-cyan);
            transform: translateY(-2px);
        }

        .nav-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-magenta), var(--accent-yellow));
            width: 0%;
            transition: width 0.3s ease;
        }

        /* =================================================================
         * CONÈšINUT PRINCIPAL
         * ================================================================= */
        main {
            padding-top: 80px;
        }

        .slide {
            min-height: 100vh;
            padding: 4rem 2rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
        }

        .slide::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, transparent, var(--accent-cyan), transparent);
        }

        /* =================================================================
         * TITLURI È˜I HEADERE
         * ================================================================= */
        .slide-title {
            font-size: 3rem;
            margin-bottom: 2rem;
            text-align: center;
            position: relative;
        }

        .slide-title::after {
            content: '';
            display: block;
            width: 100px;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-magenta));
            margin: 1rem auto;
            border-radius: 2px;
        }

        .slide-title.cyan { color: var(--accent-cyan); }
        .slide-title.magenta { color: var(--accent-magenta); }
        .slide-title.yellow { color: var(--accent-yellow); }
        .slide-title.green { color: var(--accent-green); }
        .slide-title.orange { color: var(--accent-orange); }
        .slide-title.purple { color: var(--accent-purple); }

        h2 {
            font-size: 2rem;
            color: var(--accent-cyan);
            margin: 2rem 0 1rem;
            border-left: 4px solid var(--accent-cyan);
            padding-left: 1rem;
        }

        h3 {
            font-size: 1.5rem;
            color: var(--accent-yellow);
            margin: 1.5rem 0 1rem;
        }

        h4 {
            font-size: 1.2rem;
            color: var(--accent-green);
            margin: 1rem 0 0.5rem;
        }

        /* =================================================================
         * HERO SECTION
         * ================================================================= */
        .hero {
            text-align: center;
            padding: 6rem 2rem;
            background: radial-gradient(ellipse at center, rgba(0, 217, 255, 0.1) 0%, transparent 70%);
        }

        .hero-title {
            font-size: 4rem;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta), var(--accent-yellow));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGlow 3s ease-in-out infinite;
        }

        @keyframes titleGlow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }

        .hero-subtitle {
            font-size: 1.8rem;
            color: var(--text-muted);
            margin-bottom: 2rem;
        }

        .hero-meta {
            display: flex;
            justify-content: center;
            gap: 3rem;
            flex-wrap: wrap;
            margin-top: 2rem;
        }

        .meta-item {
            text-align: center;
            padding: 1rem 2rem;
            background: rgba(0, 217, 255, 0.1);
            border-radius: 10px;
            border: 1px solid rgba(0, 217, 255, 0.3);
        }

        .meta-value {
            font-size: 2rem;
            font-weight: bold;
            color: var(--accent-cyan);
        }

        .meta-label {
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* =================================================================
         * DIAGRAME THREAD/PARALLEL
         * ================================================================= */
        .thread-diagram {
            background: var(--code-bg);
            border-radius: 15px;
            padding: 2rem;
            margin: 2rem 0;
            font-family: 'Consolas', 'Monaco', monospace;
            overflow-x: auto;
            border: 1px solid rgba(0, 217, 255, 0.3);
        }

        .thread-timeline {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .thread-row {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .thread-label {
            width: 100px;
            font-weight: bold;
            color: var(--text-light);
        }

        .thread-bar {
            height: 30px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary-dark);
            font-weight: bold;
            font-size: 0.85rem;
            transition: all 0.3s ease;
        }

        .thread-bar:hover {
            transform: scaleY(1.2);
            box-shadow: 0 0 20px currentColor;
        }

        .thread-bar.t1 { background: var(--thread-1); }
        .thread-bar.t2 { background: var(--thread-2); }
        .thread-bar.t3 { background: var(--thread-3); }
        .thread-bar.t4 { background: var(--thread-4); }
        .thread-bar.waiting { background: repeating-linear-gradient(45deg, #333, #333 10px, #444 10px, #444 20px); color: var(--text-muted); }
        .thread-bar.blocked { background: var(--danger); }
        .thread-bar.critical { background: var(--warning); }

        /* =================================================================
         * BLOCURI DE COD
         * ================================================================= */
        pre {
            background: var(--code-bg);
            border-radius: 10px;
            padding: 1.5rem;
            overflow-x: auto;
            border-left: 4px solid var(--accent-cyan);
            margin: 1rem 0;
            position: relative;
        }

        pre::before {
            content: attr(data-lang);
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            font-size: 0.75rem;
            color: var(--accent-cyan);
            background: rgba(0, 217, 255, 0.1);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
        }

        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.95rem;
            line-height: 1.5;
        }

        .code-inline {
            background: rgba(0, 217, 255, 0.15);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            color: var(--accent-cyan);
        }

        /* Syntax highlighting */
        .keyword { color: var(--accent-magenta); font-weight: bold; }
        .type { color: var(--accent-cyan); }
        .function { color: var(--accent-yellow); }
        .string { color: var(--accent-green); }
        .comment { color: #6a737d; font-style: italic; }
        .number { color: var(--accent-orange); }
        .preprocessor { color: var(--accent-purple); }

        /* =================================================================
         * CARDURI È˜I BOXURI
         * ================================================================= */
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin: 2rem 0;
        }

        .card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 2rem;
            border: 1px solid rgba(0, 217, 255, 0.2);
            transition: all 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            border-color: var(--accent-cyan);
            box-shadow: 0 10px 40px rgba(0, 217, 255, 0.2);
        }

        .card-title {
            font-size: 1.3rem;
            color: var(--accent-cyan);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .card-icon {
            font-size: 1.5rem;
        }

        /* Box-uri de alertÄƒ */
        .box {
            padding: 1.5rem;
            border-radius: 10px;
            margin: 1.5rem 0;
            border-left: 4px solid;
        }

        .box-info {
            background: rgba(0, 217, 255, 0.1);
            border-color: var(--accent-cyan);
        }

        .box-warning {
            background: rgba(255, 170, 0, 0.1);
            border-color: var(--warning);
        }

        .box-danger {
            background: rgba(255, 68, 68, 0.1);
            border-color: var(--danger);
        }

        .box-success {
            background: rgba(0, 255, 136, 0.1);
            border-color: var(--success);
        }

        .box-title {
            font-weight: bold;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .box-info .box-title { color: var(--accent-cyan); }
        .box-warning .box-title { color: var(--warning); }
        .box-danger .box-title { color: var(--danger); }
        .box-success .box-title { color: var(--success); }

        /* =================================================================
         * TABELE
         * ================================================================= */
        .table-container {
            overflow-x: auto;
            margin: 1.5rem 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }

        th, td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        th {
            background: rgba(0, 217, 255, 0.2);
            color: var(--accent-cyan);
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.85rem;
            letter-spacing: 1px;
        }

        tr:hover {
            background: rgba(0, 217, 255, 0.05);
        }

        td code {
            background: rgba(0, 217, 255, 0.15);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
        }

        /* =================================================================
         * LISTE
         * ================================================================= */
        ul, ol {
            padding-left: 1.5rem;
            margin: 1rem 0;
        }

        li {
            margin: 0.5rem 0;
            position: relative;
        }

        ul li::marker {
            color: var(--accent-cyan);
        }

        ol li::marker {
            color: var(--accent-magenta);
            font-weight: bold;
        }

        /* =================================================================
         * ANIMAÈšII PARALELE
         * ================================================================= */
        .parallel-demo {
            display: flex;
            gap: 1rem;
            margin: 2rem 0;
            padding: 2rem;
            background: var(--code-bg);
            border-radius: 15px;
            overflow: hidden;
        }

        .process-column {
            flex: 1;
            padding: 1rem;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.05);
        }

        .process-title {
            text-align: center;
            font-weight: bold;
            margin-bottom: 1rem;
            padding: 0.5rem;
            border-radius: 5px;
        }

        .process-column:nth-child(1) .process-title { background: var(--thread-1); color: var(--primary-dark); }
        .process-column:nth-child(2) .process-title { background: var(--thread-2); color: var(--primary-dark); }
        .process-column:nth-child(3) .process-title { background: var(--thread-3); color: var(--primary-dark); }
        .process-column:nth-child(4) .process-title { background: var(--thread-4); color: var(--primary-dark); }

        .task-block {
            padding: 0.8rem;
            margin: 0.5rem 0;
            border-radius: 5px;
            text-align: center;
            font-size: 0.85rem;
            animation: fadeInUp 0.5s ease forwards;
            opacity: 0;
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .task-block:nth-child(2) { animation-delay: 0.1s; }
        .task-block:nth-child(3) { animation-delay: 0.2s; }
        .task-block:nth-child(4) { animation-delay: 0.3s; }
        .task-block:nth-child(5) { animation-delay: 0.4s; }

        /* =================================================================
         * FORMULE MATEMATICE
         * ================================================================= */
        .formula {
            text-align: center;
            padding: 1.5rem;
            margin: 1.5rem 0;
            background: rgba(0, 217, 255, 0.1);
            border-radius: 10px;
            font-size: 1.3rem;
            font-family: 'Times New Roman', serif;
            border: 1px solid rgba(0, 217, 255, 0.3);
        }

        .formula-name {
            font-size: 0.9rem;
            color: var(--accent-cyan);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* =================================================================
         * QUOTE-URI ISTORICE
         * ================================================================= */
        .quote {
            padding: 2rem;
            margin: 2rem 0;
            background: linear-gradient(135deg, rgba(131, 56, 236, 0.1), rgba(0, 217, 255, 0.1));
            border-radius: 15px;
            position: relative;
            border-left: 4px solid var(--accent-purple);
        }

        .quote::before {
            content: '"';
            font-size: 4rem;
            position: absolute;
            top: -10px;
            left: 20px;
            color: var(--accent-purple);
            opacity: 0.5;
            font-family: Georgia, serif;
        }

        .quote-text {
            font-size: 1.2rem;
            font-style: italic;
            margin-bottom: 1rem;
            padding-left: 2rem;
        }

        .quote-author {
            text-align: right;
            color: var(--accent-purple);
            font-weight: bold;
        }

        /* =================================================================
         * DIAGRAME DE SINCRONIZARE
         * ================================================================= */
        .sync-diagram {
            background: var(--code-bg);
            padding: 2rem;
            border-radius: 15px;
            margin: 2rem 0;
            font-family: monospace;
            white-space: pre;
            line-height: 1.4;
            overflow-x: auto;
        }

        .sync-highlight {
            background: rgba(255, 170, 0, 0.3);
            padding: 0 0.2rem;
        }

        .sync-lock {
            color: var(--danger);
            font-weight: bold;
        }

        .sync-unlock {
            color: var(--success);
            font-weight: bold;
        }

        /* =================================================================
         * FOOTER
         * ================================================================= */
        footer {
            text-align: center;
            padding: 3rem;
            background: rgba(0, 0, 0, 0.3);
            margin-top: 4rem;
        }

        footer p {
            color: var(--text-muted);
            margin: 0.5rem 0;
        }

        footer a {
            color: var(--accent-cyan);
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* =================================================================
         * RESPONSIVE
         * ================================================================= */
        @media (max-width: 768px) {
            .hero-title { font-size: 2.5rem; }
            .slide-title { font-size: 2rem; }
            .nav-links { display: none; }
            .card-grid { grid-template-columns: 1fr; }
            .parallel-demo { flex-direction: column; }
        }

        /* =================================================================
         * EFECTE SPECIALE
         * ================================================================= */
        .glow-text {
            text-shadow: 0 0 10px currentColor, 0 0 20px currentColor;
        }

        .pulse {
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .typing {
            overflow: hidden;
            border-right: 3px solid var(--accent-cyan);
            white-space: nowrap;
            animation: typing 3s steps(40) infinite, blink 0.75s step-end infinite;
        }

        @keyframes typing {
            from { width: 0; }
            to { width: 100%; }
        }

        @keyframes blink {
            50% { border-color: transparent; }
        }

        /* Indicator scroll */
        .scroll-indicator {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            background: var(--accent-cyan);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(0, 217, 255, 0.4);
            transition: all 0.3s ease;
            z-index: 999;
        }

        .scroll-indicator:hover {
            transform: scale(1.1);
        }

        .scroll-indicator svg {
            width: 24px;
            height: 24px;
            fill: var(--primary-dark);
        }

        /* Race condition visualization */
        .race-demo {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            padding: 2rem;
            background: var(--code-bg);
            border-radius: 15px;
            margin: 2rem 0;
        }

        .race-step {
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            text-align: center;
        }

        .race-step-title {
            font-weight: bold;
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            border-radius: 5px;
        }

        .race-value {
            font-size: 2rem;
            font-weight: bold;
            color: var(--accent-cyan);
            margin: 1rem 0;
        }

        .race-bad .race-value { color: var(--danger); }
        .race-good .race-value { color: var(--success); }
    </style>
</head>
<body>
    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         NAVIGARE
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <nav class="nav-header">
        <div class="nav-title">SÄƒptÄƒmÃ¢na 20: Programare ParalelÄƒ È™i ConcurentÄƒ</div>
        <div class="nav-links">
            <a href="#intro">Introducere</a>
            <a href="#threads">Threads</a>
            <a href="#sync">Sincronizare</a>
            <a href="#patterns">Patterns</a>
            <a href="#lockfree">Lock-free</a>
            <a href="#benchmark">Benchmark</a>
            <a href="#exercitii">ExerciÈ›ii</a>
        </div>
        <div class="nav-progress" id="progressBar"></div>
    </nav>

    <main>
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             HERO SECTION
             â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="hero slide" id="hero">
            <h1 class="hero-title">Programare ParalelÄƒ È™i ConcurentÄƒ</h1>
            <p class="hero-subtitle">Exploatarea puterii procesoarelor multi-core Ã®n C</p>
            
            <div class="hero-meta">
                <div class="meta-item">
                    <div class="meta-value">POSIX</div>
                    <div class="meta-label">Threads API</div>
                </div>
                <div class="meta-item">
                    <div class="meta-value">C11</div>
                    <div class="meta-label">Atomics</div>
                </div>
                <div class="meta-item">
                    <div class="meta-value">Lock-free</div>
                    <div class="meta-label">Structuri</div>
                </div>
                <div class="meta-item">
                    <div class="meta-value">Map-Reduce</div>
                    <div class="meta-label">Pattern</div>
                </div>
            </div>

            <div class="thread-diagram" style="margin-top: 3rem;">
                <div class="thread-timeline">
                    <div class="thread-row">
                        <span class="thread-label">Main:</span>
                        <div class="thread-bar t1" style="width: 100px;">create</div>
                        <div class="thread-bar waiting" style="width: 300px;">join...</div>
                        <div class="thread-bar t1" style="width: 80px;">done</div>
                    </div>
                    <div class="thread-row">
                        <span class="thread-label">Thread 1:</span>
                        <div style="width: 100px;"></div>
                        <div class="thread-bar t2" style="width: 150px;">work</div>
                        <div class="thread-bar critical" style="width: 50px;">lock</div>
                        <div class="thread-bar t2" style="width: 100px;">work</div>
                    </div>
                    <div class="thread-row">
                        <span class="thread-label">Thread 2:</span>
                        <div style="width: 120px;"></div>
                        <div class="thread-bar t3" style="width: 100px;">work</div>
                        <div class="thread-bar blocked" style="width: 50px;">wait</div>
                        <div class="thread-bar critical" style="width: 50px;">lock</div>
                        <div class="thread-bar t3" style="width: 100px;">work</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             INTRODUCERE È˜I OBIECTIVE
             â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="slide" id="intro">
            <h1 class="slide-title cyan">ğŸ¯ Obiective de ÃnvÄƒÈ›are</h1>

            <div class="card-grid">
                <div class="card">
                    <div class="card-title"><span class="card-icon">ğŸ“š</span> ReÈ›ineÈ›i</div>
                    <ul>
                        <li>DiferenÈ›a <strong>concurenÈ›Äƒ vs. paralelism</strong></li>
                        <li>Primitivele POSIX: pthread_create, mutex, semaphore</li>
                        <li>CondiÈ›iile pentru <strong>race condition</strong> È™i <strong>deadlock</strong></li>
                        <li>Formula <strong>Legii lui Amdahl</strong></li>
                    </ul>
                </div>

                <div class="card">
                    <div class="card-title"><span class="card-icon">ğŸ’¡</span> ÃnÈ›elegeÈ›i</div>
                    <ul>
                        <li>De ce <strong>lock-urile</strong> sunt necesare pentru date partajate</li>
                        <li>Cum thread-urile Ã®mpÄƒrtÄƒÈ™esc memoria</li>
                        <li>Overhead-ul sincronizÄƒrii È™i impactul asupra performanÈ›ei</li>
                        <li>Trade-off-uri Ã®ntre corectitudine È™i vitezÄƒ</li>
                    </ul>
                </div>

                <div class="card">
                    <div class="card-title"><span class="card-icon">âš™ï¸</span> AplicaÈ›i</div>
                    <ul>
                        <li>Implementare <strong>Thread Pool</strong> cu coadÄƒ de taskuri</li>
                        <li>Pattern <strong>Producer-Consumer</strong> cu buffer circular</li>
                        <li><strong>Parallel Merge Sort</strong> cu threshold adaptiv</li>
                        <li><strong>Lock-free stack</strong> cu atomic CAS</li>
                    </ul>
                </div>

                <div class="card">
                    <div class="card-title"><span class="card-icon">ğŸ”</span> AnalizaÈ›i</div>
                    <ul>
                        <li>Identificarea <strong>race conditions</strong> Ã®n cod</li>
                        <li>Calcul <strong>speedup</strong> teoretic vs. empiric</li>
                        <li>Profiling È™i bottleneck analysis</li>
                        <li>Scalabilitate pe diferite arhitecturi</li>
                    </ul>
                </div>

                <div class="card">
                    <div class="card-title"><span class="card-icon">âš–ï¸</span> EvaluaÈ›i</div>
                    <ul>
                        <li>Mutex vs. spinlock vs. atomics</li>
                        <li>Granularitate optimÄƒ pentru lock-uri</li>
                        <li>CÃ¢nd meritÄƒ paralelizarea</li>
                        <li>Alegerea pattern-ului potrivit</li>
                    </ul>
                </div>

                <div class="card">
                    <div class="card-title"><span class="card-icon">ğŸ—ï¸</span> CreaÈ›i</div>
                    <ul>
                        <li>AplicaÈ›ie paralelÄƒ cu <strong>scalare demonstrabilÄƒ</strong></li>
                        <li>Sistem <strong>Map-Reduce</strong> Ã®n C</li>
                        <li>Thread Pool cu <strong>Futures</strong></li>
                        <li>Pipeline de procesare concurentÄƒ</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             CONTEXT ISTORIC
             â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="slide" id="istoric">
            <h1 class="slide-title purple">ğŸ“œ Context Istoric</h1>

            <div class="quote">
                <p class="quote-text">
                    The free lunch is over. Concurrency is the next major revolution in how we write software.
                </p>
                <p class="quote-author">â€” Herb Sutter, 2005</p>
            </div>

            <h2>EvoluÈ›ia ProcesÄƒrii Paralele</h2>

            <div class="thread-diagram">
<span class="comment">Timeline: De la secvenÈ›ial la masiv paralel</span>

<span style="color: var(--accent-cyan);">1960s</span> â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€ Primele sisteme timesharing
                     â”‚     Multiprogramare pe mainframe-uri
                     â”‚
<span style="color: var(--accent-cyan);">1970s</span> â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€ <span style="color: var(--accent-magenta);">Dijkstra: Semafoare</span> (1965)
                     â”‚     Comunicarea proceselor secvenÈ›iale
                     â”‚
<span style="color: var(--accent-cyan);">1980s</span> â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€ <span style="color: var(--accent-magenta);">Lamport: Timestamps, Bakery Algorithm</span>
                     â”‚     Sisteme distribuite, consensul
                     â”‚
<span style="color: var(--accent-cyan);">1990s</span> â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€ POSIX Threads (pthreads)
                     â”‚     Java threads, Windows threads
                     â”‚
<span style="color: var(--accent-cyan);">2000s</span> â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€ Multi-core devine mainstream (2005+)
                     â”‚     "Free lunch is over"
                     â”‚
<span style="color: var(--accent-cyan);">2010s</span> â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€ Lock-free data structures mature
                     â”‚     GPU computing, SIMD
                     â”‚
<span style="color: var(--accent-cyan);">2020s</span> â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€ Heterogeneous computing
                           CPU + GPU + TPU + ...
            </div>

            <div class="card-grid" style="margin-top: 2rem;">
                <div class="card">
                    <div class="card-title">Edsger W. Dijkstra (1930-2002)</div>
                    <p>Inventatorul semafoarelor È™i conceptului de secÈ›iune criticÄƒ. Premiul Turing 1972.</p>
                    <div class="quote" style="margin: 1rem 0; padding: 1rem;">
                        <p class="quote-text" style="font-size: 1rem;">"The question of whether a computer can think is no more interesting than the question of whether a submarine can swim."</p>
                    </div>
                    <p><strong>ContribuÈ›ii:</strong> Semafoare, algoritmul Dijkstra, problema filozofilor, goto considered harmful</p>
                </div>

                <div class="card">
                    <div class="card-title">Leslie Lamport (n. 1941)</div>
                    <p>Pionier Ã®n sisteme distribuite È™i concurenÈ›Äƒ. Premiul Turing 2013.</p>
                    <div class="quote" style="margin: 1rem 0; padding: 1rem;">
                        <p class="quote-text" style="font-size: 1rem;">"A distributed system is one in which the failure of a computer you didn't even know existed can render your own computer unusable."</p>
                    </div>
                    <p><strong>ContribuÈ›ii:</strong> Bakery algorithm, Paxos, LaTeX, happens-before relation</p>
                </div>

                <div class="card">
                    <div class="card-title">Gene Amdahl (1922-2015)</div>
                    <p>Arhitect IBM, fondator Amdahl Corporation. Formularea legii care Ã®i poartÄƒ numele.</p>
                    <div class="formula" style="margin: 1rem 0;">
                        <div class="formula-name">Legea lui Amdahl (1967)</div>
                        S(n) = 1 / ((1-P) + P/n)
                    </div>
                    <p><strong>Unde:</strong> P = fracÈ›iunea paralelizabilÄƒ, n = numÄƒr procesoare</p>
                </div>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             CONCURENÈšÄ‚ VS PARALELISM
             â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="slide" id="concepts">
            <h1 class="slide-title yellow">âš¡ ConcurenÈ›Äƒ vs. Paralelism</h1>

            <div class="box box-info">
                <div class="box-title">ğŸ’¡ DiferenÈ›a FundamentalÄƒ</div>
                <ul>
                    <li><strong>ConcurenÈ›a</strong> = structurarea programului pentru a gestiona mai multe sarcini (potenÈ›ial pe un singur core)</li>
                    <li><strong>Paralelismul</strong> = executarea efectivÄƒ simultanÄƒ pe mai multe core-uri</li>
                </ul>
            </div>

            <div class="parallel-demo">
                <div class="process-column">
                    <div class="process-title">SecvenÈ›ial</div>
                    <div class="task-block" style="background: var(--thread-1); color: var(--primary-dark);">Task A</div>
                    <div class="task-block" style="background: var(--thread-2); color: var(--primary-dark);">Task B</div>
                    <div class="task-block" style="background: var(--thread-3); color: var(--primary-dark);">Task C</div>
                    <div class="task-block" style="background: var(--thread-4); color: var(--primary-dark);">Task D</div>
                    <p style="text-align: center; margin-top: 1rem; color: var(--text-muted);">Total: 4 unitÄƒÈ›i timp</p>
                </div>

                <div class="process-column">
                    <div class="process-title">Concurrent (1 core)</div>
                    <div class="task-block" style="background: linear-gradient(90deg, var(--thread-1) 50%, var(--thread-2) 50%); color: var(--primary-dark);">Aâ”‚Bâ”‚Aâ”‚B</div>
                    <div class="task-block" style="background: linear-gradient(90deg, var(--thread-3) 50%, var(--thread-4) 50%); color: var(--primary-dark);">Câ”‚Dâ”‚Câ”‚D</div>
                    <p style="text-align: center; margin-top: 1rem; color: var(--text-muted);">Total: ~4 unitÄƒÈ›i<br>(context switch overhead)</p>
                </div>

                <div class="process-column">
                    <div class="process-title">Paralel (2 cores)</div>
                    <div style="display: flex; gap: 0.5rem;">
                        <div class="task-block" style="flex: 1; background: var(--thread-1); color: var(--primary-dark);">A</div>
                        <div class="task-block" style="flex: 1; background: var(--thread-2); color: var(--primary-dark);">B</div>
                    </div>
                    <div style="display: flex; gap: 0.5rem;">
                        <div class="task-block" style="flex: 1; background: var(--thread-3); color: var(--primary-dark);">C</div>
                        <div class="task-block" style="flex: 1; background: var(--thread-4); color: var(--primary-dark);">D</div>
                    </div>
                    <p style="text-align: center; margin-top: 1rem; color: var(--text-muted);">Total: 2 unitÄƒÈ›i<br>(speedup ~2x)</p>
                </div>

                <div class="process-column">
                    <div class="process-title">Paralel (4 cores)</div>
                    <div style="display: flex; gap: 0.3rem;">
                        <div class="task-block" style="flex: 1; background: var(--thread-1); color: var(--primary-dark); font-size: 0.7rem;">A</div>
                        <div class="task-block" style="flex: 1; background: var(--thread-2); color: var(--primary-dark); font-size: 0.7rem;">B</div>
                        <div class="task-block" style="flex: 1; background: var(--thread-3); color: var(--primary-dark); font-size: 0.7rem;">C</div>
                        <div class="task-block" style="flex: 1; background: var(--thread-4); color: var(--primary-dark); font-size: 0.7rem;">D</div>
                    </div>
                    <p style="text-align: center; margin-top: 1rem; color: var(--text-muted);">Total: 1 unitate<br>(speedup ~4x)</p>
                </div>
            </div>

            <h2>Procesele È™i Thread-urile</h2>

            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>CaracteristicÄƒ</th>
                            <th>Proces</th>
                            <th>Thread</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Memorie</td>
                            <td>SpaÈ›iu de adrese <strong>separat</strong></td>
                            <td>SpaÈ›iu de adrese <strong>partajat</strong></td>
                        </tr>
                        <tr>
                            <td>Creare</td>
                            <td>Costisitoare (fork)</td>
                            <td>Relativ ieftinÄƒ</td>
                        </tr>
                        <tr>
                            <td>Comunicare</td>
                            <td>IPC (pipes, sockets, shared memory)</td>
                            <td>DirectÄƒ (variabile globale)</td>
                        </tr>
                        <tr>
                            <td>Izolare</td>
                            <td>CompletÄƒ (crash nu afecteazÄƒ altele)</td>
                            <td>LimitatÄƒ (crash = proces mort)</td>
                        </tr>
                        <tr>
                            <td>Context switch</td>
                            <td>Lent (flush TLB)</td>
                            <td>Rapid</td>
                        </tr>
                        <tr>
                            <td>Sincronizare</td>
                            <td>NecesitÄƒ IPC explicit</td>
                            <td>Mutex, semafoare, atomics</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="thread-diagram">
<span class="comment">Anatomia unui proces cu multiple threads:</span>

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        <span style="color: var(--accent-cyan);">PROCES</span>                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  <span style="color: var(--accent-yellow);">SpaÈ›iu de adrese partajat:</span>                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚    Code     â”‚  â”‚    Data     â”‚  â”‚    Heap     â”‚             â”‚
â”‚  â”‚  (text)     â”‚  â”‚  (global)   â”‚  â”‚  (malloc)   â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                                                                 â”‚
â”‚  <span style="color: var(--accent-magenta);">Per-thread (separate):</span>                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚  <span style="color: var(--thread-1);">Thread 1</span>  â”‚   â”‚  <span style="color: var(--thread-2);">Thread 2</span>  â”‚   â”‚  <span style="color: var(--thread-3);">Thread 3</span>  â”‚                 â”‚
â”‚  â”‚           â”‚   â”‚           â”‚   â”‚           â”‚                 â”‚
â”‚  â”‚  Stack    â”‚   â”‚  Stack    â”‚   â”‚  Stack    â”‚                 â”‚
â”‚  â”‚  Registersâ”‚   â”‚  Registersâ”‚   â”‚  Registersâ”‚                 â”‚
â”‚  â”‚  PC       â”‚   â”‚  PC       â”‚   â”‚  PC       â”‚                 â”‚
â”‚  â”‚  Thread IDâ”‚   â”‚  Thread IDâ”‚   â”‚  Thread IDâ”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             PTHREADS BASICS
             â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="slide" id="threads">
            <h1 class="slide-title cyan">ğŸ§µ POSIX Threads (pthreads)</h1>

            <h2>Creare È™i Terminare Thread</h2>

            <pre data-lang="C"><code><span class="preprocessor">#include</span> <span class="string">&lt;pthread.h&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;stdio.h&gt;</span>

<span class="comment">/* FuncÈ›ia executatÄƒ de thread */</span>
<span class="type">void</span>* <span class="function">worker</span>(<span class="type">void</span> *arg) {
    <span class="type">int</span> id = *(<span class="type">int</span>*)arg;
    <span class="function">printf</span>(<span class="string">"Thread %d: Salut din thread!\n"</span>, id);
    
    <span class="comment">/* Valoarea returnatÄƒ poate fi obÈ›inutÄƒ prin pthread_join */</span>
    <span class="type">int</span> *result = <span class="function">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));
    *result = id * <span class="number">100</span>;
    <span class="keyword">return</span> result;
}

<span class="type">int</span> <span class="function">main</span>(<span class="type">void</span>) {
    <span class="type">pthread_t</span> threads[<span class="number">4</span>];
    <span class="type">int</span> ids[<span class="number">4</span>] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};
    
    <span class="comment">/* Creare threads */</span>
    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i < <span class="number">4</span>; i++) {
        <span class="keyword">if</span> (<span class="function">pthread_create</span>(&threads[i], <span class="number">NULL</span>, worker, &ids[i]) != <span class="number">0</span>) {
            <span class="function">perror</span>(<span class="string">"pthread_create failed"</span>);
            <span class="keyword">return</span> <span class="number">1</span>;
        }
    }
    
    <span class="comment">/* AÈ™teptare terminare È™i colectare rezultate */</span>
    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i < <span class="number">4</span>; i++) {
        <span class="type">void</span> *retval;
        <span class="function">pthread_join</span>(threads[i], &retval);
        <span class="function">printf</span>(<span class="string">"Thread %d returned: %d\n"</span>, i, *(<span class="type">int</span>*)retval);
        <span class="function">free</span>(retval);
    }
    
    <span class="keyword">return</span> <span class="number">0</span>;
}

<span class="comment">/* Compilare: gcc -Wall -pthread -o demo demo.c */</span></code></pre>

            <h2>API Principal pthread</h2>

            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>FuncÈ›ie</th>
                            <th>Descriere</th>
                            <th>NotÄƒ</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>pthread_create()</code></td>
                            <td>CreeazÄƒ un nou thread</td>
                            <td>ReturneazÄƒ 0 la succes</td>
                        </tr>
                        <tr>
                            <td><code>pthread_join()</code></td>
                            <td>AÈ™teaptÄƒ terminarea thread-ului</td>
                            <td>BlocheazÄƒ pÃ¢nÄƒ la terminare</td>
                        </tr>
                        <tr>
                            <td><code>pthread_detach()</code></td>
                            <td>MarcheazÄƒ thread-ul ca detached</td>
                            <td>Resursele eliberate automat</td>
                        </tr>
                        <tr>
                            <td><code>pthread_exit()</code></td>
                            <td>TerminÄƒ thread-ul curent</td>
                            <td>Nu terminÄƒ procesul</td>
                        </tr>
                        <tr>
                            <td><code>pthread_self()</code></td>
                            <td>ReturneazÄƒ ID-ul thread-ului curent</td>
                            <td>Tip opac pthread_t</td>
                        </tr>
                        <tr>
                            <td><code>pthread_equal()</code></td>
                            <td>ComparÄƒ douÄƒ thread ID-uri</td>
                            <td>Nu folosi == direct</td>
                        </tr>
                        <tr>
                            <td><code>pthread_cancel()</code></td>
                            <td>SolicitÄƒ anularea thread-ului</td>
                            <td>Poate fi ignorat</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="box box-warning">
                <div class="box-title">âš ï¸ GreÈ™eli Comune</div>
                <ul>
                    <li><strong>Pasare pointer la variabilÄƒ localÄƒ din buclÄƒ</strong> - toate thread-urile vÄƒd aceeaÈ™i adresÄƒ</li>
                    <li><strong>Uitarea pthread_join()</strong> - memory leak pentru thread-uri joinable</li>
                    <li><strong>Return din main() Ã®nainte de join</strong> - toate thread-urile sunt terminate forÈ›at</li>
                    <li><strong>Uitarea flag-ului -pthread la compilare</strong> - comportament nedefinit</li>
                </ul>
            </div>

            <h3>Pattern Corect pentru Pasare Date</h3>

            <pre data-lang="C"><code><span class="comment">/* GREÈ˜IT: Toate thread-urile primesc aceeaÈ™i adresÄƒ! */</span>
<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i < N; i++) {
    <span class="function">pthread_create</span>(&t[i], <span class="number">NULL</span>, worker, &i);  <span class="comment">/* BUG! */</span>
}

<span class="comment">/* CORECT: Array separat */</span>
<span class="type">int</span> ids[N];
<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i < N; i++) {
    ids[i] = i;
    <span class="function">pthread_create</span>(&t[i], <span class="number">NULL</span>, worker, &ids[i]);
}

<span class="comment">/* CORECT: StructurÄƒ alocatÄƒ dinamic */</span>
<span class="keyword">typedef struct</span> {
    <span class="type">int</span> id;
    <span class="type">char</span> *data;
} ThreadArgs;

<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i < N; i++) {
    ThreadArgs *args = <span class="function">malloc</span>(<span class="keyword">sizeof</span>(ThreadArgs));
    args->id = i;
    args->data = <span class="string">"shared data"</span>;
    <span class="function">pthread_create</span>(&t[i], <span class="number">NULL</span>, worker, args);
    <span class="comment">/* worker() va face free(args) */</span>
}</code></pre>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             RACE CONDITIONS
             â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="slide" id="race">
            <h1 class="slide-title magenta">ğŸ’¥ Race Conditions</h1>

            <div class="box box-danger">
                <div class="box-title">ğŸ”¥ Ce este o Race Condition?</div>
                <p>O situaÈ›ie Ã®n care comportamentul programului depinde de ordinea relativÄƒ a execuÈ›iei operaÈ›iilor din thread-uri diferite. Rezultatul este <strong>nedeterminist</strong> È™i <strong>greu de reprodus</strong>.</p>
            </div>

            <h2>DemonstraÈ›ie: Counter FÄƒrÄƒ ProtecÈ›ie</h2>

            <div class="race-demo">
                <div class="race-step">
                    <div class="race-step-title" style="background: var(--thread-1); color: var(--primary-dark);">Thread A</div>
                    <p>1. CiteÈ™te counter (0)</p>
                    <p>2. AdaugÄƒ 1 â†’ 1</p>
                    <p>3. Scrie counter (1)</p>
                </div>
                <div class="race-step race-bad">
                    <div class="race-step-title" style="background: var(--danger);">Problema</div>
                    <p>Thread B citeÈ™te <strong>Ã®nainte</strong> ca A sÄƒ scrie!</p>
                    <div class="race-value">1</div>
                    <p>Ãn loc de 2!</p>
                </div>
                <div class="race-step">
                    <div class="race-step-title" style="background: var(--thread-2); color: var(--primary-dark);">Thread B</div>
                    <p>1. CiteÈ™te counter (0)</p>
                    <p>2. AdaugÄƒ 1 â†’ 1</p>
                    <p>3. Scrie counter (1)</p>
                </div>
            </div>

            <pre data-lang="C"><code><span class="preprocessor">#include</span> <span class="string">&lt;pthread.h&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;stdio.h&gt;</span>

<span class="type">volatile int</span> counter = <span class="number">0</span>;  <span class="comment">/* VariabilÄƒ partajatÄƒ */</span>
<span class="preprocessor">#define</span> ITERATIONS <span class="number">1000000</span>

<span class="type">void</span>* <span class="function">increment</span>(<span class="type">void</span> *arg) {
    (<span class="type">void</span>)arg;
    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i < ITERATIONS; i++) {
        counter++;  <span class="comment">/* NU ESTE ATOMIC! */</span>
        <span class="comment">/*
         * Echivalent cu:
         *   int temp = counter;    // LOAD
         *   temp = temp + 1;       // ADD
         *   counter = temp;        // STORE
         * 
         * Ãntre LOAD È™i STORE alt thread poate interveni!
         */</span>
    }
    <span class="keyword">return</span> <span class="number">NULL</span>;
}

<span class="type">int</span> <span class="function">main</span>(<span class="type">void</span>) {
    <span class="type">pthread_t</span> t1, t2;
    
    <span class="function">pthread_create</span>(&t1, <span class="number">NULL</span>, increment, <span class="number">NULL</span>);
    <span class="function">pthread_create</span>(&t2, <span class="number">NULL</span>, increment, <span class="number">NULL</span>);
    
    <span class="function">pthread_join</span>(t1, <span class="number">NULL</span>);
    <span class="function">pthread_join</span>(t2, <span class="number">NULL</span>);
    
    <span class="comment">/* AÈ™teptat: 2,000,000 */</span>
    <span class="comment">/* Real: 1,000,000 - 2,000,000 (nedeterminist!) */</span>
    <span class="function">printf</span>(<span class="string">"Counter: %d (expected %d)\n"</span>, counter, <span class="number">2</span> * ITERATIONS);
    
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>

            <div class="thread-diagram">
<span class="comment">ExecuÈ›ie intercalatÄƒ (race condition):</span>

Timp    Thread A                   Thread B                    counter
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
tâ‚€      LOAD counter (â†’ 0)                                        0
tâ‚                                 LOAD counter (â†’ 0)             0
tâ‚‚      ADD 1 (temp_A = 1)                                        0
tâ‚ƒ                                 ADD 1 (temp_B = 1)             0
tâ‚„      STORE counter (â† 1)                                       <span style="color: var(--thread-1);">1</span>
tâ‚…                                 STORE counter (â† 1)            <span style="color: var(--danger);">1</span> âœ—
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                                                                  <span style="color: var(--danger);">Pierdut un increment!</span>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             MUTEX
             â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="slide" id="sync">
            <h1 class="slide-title green">ğŸ”’ Mutex (Mutual Exclusion)</h1>

            <div class="box box-success">
                <div class="box-title">âœ“ SoluÈ›ia: SecÈ›iunea CriticÄƒ</div>
                <p>Un <strong>mutex</strong> asigurÄƒ cÄƒ doar un singur thread poate executa o secÈ›iune criticÄƒ la un moment dat.</p>
            </div>

            <pre data-lang="C"><code><span class="preprocessor">#include</span> <span class="string">&lt;pthread.h&gt;</span>

<span class="type">int</span> counter = <span class="number">0</span>;
<span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;  <span class="comment">/* IniÈ›ializare staticÄƒ */</span>

<span class="type">void</span>* <span class="function">increment_safe</span>(<span class="type">void</span> *arg) {
    (<span class="type">void</span>)arg;
    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i < ITERATIONS; i++) {
        <span class="function">pthread_mutex_lock</span>(&mutex);      <span class="comment">/* IntrÄƒ Ã®n secÈ›iunea criticÄƒ */</span>
        <span class="comment">/* â•â•â•â•â•â•â• SECÈšIUNE CRITICÄ‚ â•â•â•â•â•â•â• */</span>
        counter++;                       <span class="comment">/* Acum e sigur! */</span>
        <span class="comment">/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */</span>
        <span class="function">pthread_mutex_unlock</span>(&mutex);    <span class="comment">/* Iese din secÈ›iunea criticÄƒ */</span>
    }
    <span class="keyword">return</span> <span class="number">NULL</span>;
}

<span class="comment">/* Alternativ: IniÈ›ializare dinamicÄƒ */</span>
<span class="type">pthread_mutex_t</span> dyn_mutex;

<span class="type">void</span> <span class="function">init_mutex</span>(<span class="type">void</span>) {
    <span class="type">pthread_mutexattr_t</span> attr;
    <span class="function">pthread_mutexattr_init</span>(&attr);
    <span class="function">pthread_mutexattr_settype</span>(&attr, PTHREAD_MUTEX_ERRORCHECK);  <span class="comment">/* Debug */</span>
    <span class="function">pthread_mutex_init</span>(&dyn_mutex, &attr);
    <span class="function">pthread_mutexattr_destroy</span>(&attr);
}

<span class="type">void</span> <span class="function">cleanup</span>(<span class="type">void</span>) {
    <span class="function">pthread_mutex_destroy</span>(&dyn_mutex);
}</code></pre>

            <div class="thread-diagram">
<span class="comment">ExecuÈ›ie cu mutex (corectÄƒ):</span>

Timp    Thread A                   Thread B                    counter   Mutex
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
tâ‚€      <span class="sync-lock">lock()</span> âœ“                                                0       <span style="color: var(--thread-1);">LOCKED by A</span>
tâ‚      LOAD counter (â†’ 0)                                        0       <span style="color: var(--thread-1);">LOCKED by A</span>
tâ‚‚      ADD 1                      <span class="sync-lock">lock()</span> ... <span style="color: var(--warning);">BLOCKED</span>           0       <span style="color: var(--thread-1);">LOCKED by A</span>
tâ‚ƒ      STORE counter (â† 1)        <span style="color: var(--warning);">waiting...</span>                    <span style="color: var(--success);">1</span>       <span style="color: var(--thread-1);">LOCKED by A</span>
tâ‚„      <span class="sync-unlock">unlock()</span>                  <span class="sync-lock">lock()</span> âœ“                      1       <span style="color: var(--thread-2);">LOCKED by B</span>
tâ‚…                                 LOAD counter (â†’ 1)            1       <span style="color: var(--thread-2);">LOCKED by B</span>
tâ‚†                                 ADD 1                         1       <span style="color: var(--thread-2);">LOCKED by B</span>
tâ‚‡                                 STORE counter (â† 2)           <span style="color: var(--success);">2</span>       <span style="color: var(--thread-2);">LOCKED by B</span>
tâ‚ˆ                                 <span class="sync-unlock">unlock()</span>                     2       UNLOCKED
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                                                                  <span style="color: var(--success);">Corect!</span>
            </div>

            <h2>Tipuri de Mutex</h2>

            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>Tip</th>
                            <th>Comportament</th>
                            <th>CÃ¢nd sÄƒ-l foloseÈ™ti</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>PTHREAD_MUTEX_NORMAL</code></td>
                            <td>Self-deadlock posibil, nu verificÄƒ owner</td>
                            <td>PerformanÈ›Äƒ maximÄƒ (implicit)</td>
                        </tr>
                        <tr>
                            <td><code>PTHREAD_MUTEX_ERRORCHECK</code></td>
                            <td>ReturneazÄƒ eroare la self-lock sau unlock greÈ™it</td>
                            <td>Debugging</td>
                        </tr>
                        <tr>
                            <td><code>PTHREAD_MUTEX_RECURSIVE</code></td>
                            <td>AcelaÈ™i thread poate face lock de mai multe ori</td>
                            <td>FuncÈ›ii recursive</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="box box-info">
                <div class="box-title">ğŸ’¡ Granularitate Lock</div>
                <p><strong>Fine-grained:</strong> Lock per element â†’ mai mult paralelism, mai mult overhead</p>
                <p><strong>Coarse-grained:</strong> Un lock pentru tot â†’ simplu, dar serializare</p>
                <p>Alege Ã®n funcÈ›ie de cÃ¢t de des accesezi date partajate È™i cÃ¢t dureazÄƒ operaÈ›iile.</p>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             DEADLOCK
             â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="slide" id="deadlock">
            <h1 class="slide-title orange">â˜ ï¸ Deadlock</h1>

            <div class="box box-danger">
                <div class="box-title">ğŸ”’ğŸ”’ DefiniÈ›ie</div>
                <p>Un <strong>deadlock</strong> apare cÃ¢nd douÄƒ sau mai multe thread-uri se aÈ™teaptÄƒ reciproc pentru resurse pe care le deÈ›in mutual, rezultÃ¢nd Ã®n blocaj permanent.</p>
            </div>

            <h2>Cele 4 CondiÈ›ii Coffman (1971)</h2>

            <div class="card-grid">
                <div class="card">
                    <div class="card-title">1. Excludere MutualÄƒ</div>
                    <p>Resursele sunt folosite exclusiv de un thread la un moment dat.</p>
                </div>
                <div class="card">
                    <div class="card-title">2. Hold and Wait</div>
                    <p>Thread-ul deÈ›ine cel puÈ›in o resursÄƒ È™i aÈ™teaptÄƒ sÄƒ obÈ›inÄƒ altele.</p>
                </div>
                <div class="card">
                    <div class="card-title">3. No Preemption</div>
                    <p>Resursele nu pot fi luate forÈ›at; doar thread-ul care le deÈ›ine le poate elibera.</p>
                </div>
                <div class="card">
                    <div class="card-title">4. Circular Wait</div>
                    <p>ExistÄƒ un ciclu de aÈ™teptare: T1â†’T2â†’...â†’Tnâ†’T1.</p>
                </div>
            </div>

            <h3>Exemplu Clasic: Dining Philosophers</h3>

            <div class="thread-diagram">
<span class="comment">5 filozofi stau la masÄƒ rotundÄƒ, fiecare are nevoie de 2 furculiÈ›e pentru a mÃ¢nca:</span>

                        <span style="color: var(--thread-1);">ğŸ§‘ Phil 0</span>
                     ğŸ´            ğŸ´
                    
              <span style="color: var(--thread-5);">ğŸ§‘</span>                         <span style="color: var(--thread-2);">ğŸ§‘</span>
            Phil 4   ğŸ´    ğŸ²     ğŸ´   Phil 1
              
                    ğŸ´            ğŸ´
                <span style="color: var(--thread-4);">ğŸ§‘</span>                 <span style="color: var(--thread-3);">ğŸ§‘</span>
              Phil 3              Phil 2


<span class="comment">Deadlock cÃ¢nd toÈ›i iau furculiÈ›a din stÃ¢nga simultan:</span>

Phil 0: <span class="sync-lock">lock(fork[0])</span> âœ“ ... aÈ™teaptÄƒ fork[1]
Phil 1: <span class="sync-lock">lock(fork[1])</span> âœ“ ... aÈ™teaptÄƒ fork[2]
Phil 2: <span class="sync-lock">lock(fork[2])</span> âœ“ ... aÈ™teaptÄƒ fork[3]
Phil 3: <span class="sync-lock">lock(fork[3])</span> âœ“ ... aÈ™teaptÄƒ fork[4]
Phil 4: <span class="sync-lock">lock(fork[4])</span> âœ“ ... aÈ™teaptÄƒ fork[0] â† <span style="color: var(--danger);">DEADLOCK!</span>
            </div>

            <pre data-lang="C"><code><span class="comment">/* SoluÈ›ie: Ordonare globalÄƒ a resurselor */</span>
<span class="type">void</span> <span class="function">philosopher</span>(<span class="type">int</span> id) {
    <span class="type">int</span> left = id;
    <span class="type">int</span> right = (id + <span class="number">1</span>) % <span class="number">5</span>;
    
    <span class="comment">/* ÃNTOTDEAUNA ia mai Ã®ntÃ¢i furculiÈ›a cu index mai mic */</span>
    <span class="type">int</span> first = (left < right) ? left : right;
    <span class="type">int</span> second = (left < right) ? right : left;
    
    <span class="keyword">while</span> (<span class="number">1</span>) {
        <span class="function">think</span>();
        
        <span class="function">pthread_mutex_lock</span>(&forks[first]);   <span class="comment">/* Ordinea e consistentÄƒ */</span>
        <span class="function">pthread_mutex_lock</span>(&forks[second]);
        
        <span class="function">eat</span>();
        
        <span class="function">pthread_mutex_unlock</span>(&forks[second]);
        <span class="function">pthread_mutex_unlock</span>(&forks[first]);
    }
}</code></pre>

            <h2>Strategii de Evitare Deadlock</h2>

            <div class="card-grid">
                <div class="card">
                    <div class="card-title">ğŸ”¢ Ordonare GlobalÄƒ</div>
                    <p>Toate thread-urile iau lock-urile Ã®n aceeaÈ™i ordine (dupÄƒ un ID unic). Previne ciclul.</p>
                </div>
                <div class="card">
                    <div class="card-title">â±ï¸ Timeout</div>
                    <p><code>pthread_mutex_timedlock()</code> - renunÈ›Äƒ dacÄƒ nu obÈ›ine lock-ul Ã®n timp util.</p>
                </div>
                <div class="card">
                    <div class="card-title">ğŸ”„ Try-lock</div>
                    <p><code>pthread_mutex_trylock()</code> - non-blocking; returneazÄƒ imediat cu succes/eÈ™ec.</p>
                </div>
                <div class="card">
                    <div class="card-title">ğŸ“Š Banker's Algorithm</div>
                    <p>AlocÄƒ resurse doar dacÄƒ sistemul rÄƒmÃ¢ne Ã®n stare "safe". Complex, rar folosit Ã®n practicÄƒ.</p>
                </div>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             SEMAFOARE È˜I CONDITION VARIABLES
             â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="slide" id="semaphore">
            <h1 class="slide-title purple">ğŸš¦ Semafoare È™i Condition Variables</h1>

            <h2>Semafoare POSIX</h2>

            <div class="box box-info">
                <div class="box-title">ğŸ’¡ Ce este un Semafor?</div>
                <p>Un contor atomic care permite sincronizarea mai multor thread-uri. Poate avea valori > 1 (spre deosebire de mutex care e binar).</p>
            </div>

            <pre data-lang="C"><code><span class="preprocessor">#include</span> <span class="string">&lt;semaphore.h&gt;</span>

<span class="type">sem_t</span> sem;

<span class="type">void</span> <span class="function">init_semaphore</span>(<span class="type">void</span>) {
    <span class="comment">/* sem_init(semafor, pshared, valoare_iniÈ›ialÄƒ) */</span>
    <span class="comment">/* pshared: 0 = Ã®ntre thread-uri, non-zero = Ã®ntre procese */</span>
    <span class="function">sem_init</span>(&sem, <span class="number">0</span>, <span class="number">3</span>);  <span class="comment">/* Permite 3 accese simultane */</span>
}

<span class="type">void</span>* <span class="function">worker</span>(<span class="type">void</span> *arg) {
    <span class="function">sem_wait</span>(&sem);      <span class="comment">/* P() / down() - decrementeazÄƒ, blocheazÄƒ la 0 */</span>
    
    <span class="comment">/* SecÈ›iune limitatÄƒ la maxim 3 thread-uri simultan */</span>
    <span class="function">do_work</span>();
    
    <span class="function">sem_post</span>(&sem);      <span class="comment">/* V() / up() - incrementeazÄƒ, trezeÈ™te un thread */</span>
    <span class="keyword">return</span> <span class="number">NULL</span>;
}

<span class="type">void</span> <span class="function">cleanup</span>(<span class="type">void</span>) {
    <span class="function">sem_destroy</span>(&sem);
}</code></pre>

            <h2>Condition Variables</h2>

            <pre data-lang="C"><code><span class="preprocessor">#include</span> <span class="string">&lt;pthread.h&gt;</span>

<span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;
<span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;

<span class="type">bool</span> ready = <span class="keyword">false</span>;

<span class="comment">/* Thread care aÈ™teaptÄƒ */</span>
<span class="type">void</span>* <span class="function">waiter</span>(<span class="type">void</span> *arg) {
    <span class="function">pthread_mutex_lock</span>(&mutex);
    
    <span class="comment">/* IMPORTANT: FoloseÈ™te WHILE, nu IF! */</span>
    <span class="comment">/* Spurious wakeups sunt posibile! */</span>
    <span class="keyword">while</span> (!ready) {
        <span class="comment">/* Atomically: unlock mutex + sleep */</span>
        <span class="comment">/* La trezire: re-lock mutex */</span>
        <span class="function">pthread_cond_wait</span>(&cond, &mutex);
    }
    
    <span class="comment">/* ProceseazÄƒ cÃ¢nd ready == true */</span>
    <span class="function">process_data</span>();
    
    <span class="function">pthread_mutex_unlock</span>(&mutex);
    <span class="keyword">return</span> <span class="number">NULL</span>;
}

<span class="comment">/* Thread care semnalizeazÄƒ */</span>
<span class="type">void</span>* <span class="function">signaler</span>(<span class="type">void</span> *arg) {
    <span class="function">pthread_mutex_lock</span>(&mutex);
    
    <span class="function">prepare_data</span>();
    ready = <span class="keyword">true</span>;
    
    <span class="comment">/* pthread_cond_signal(&cond);    // TrezeÈ™te UN thread */</span>
    <span class="function">pthread_cond_broadcast</span>(&cond);    <span class="comment">/* TrezeÈ™te TOATE thread-urile */</span>
    
    <span class="function">pthread_mutex_unlock</span>(&mutex);
    <span class="keyword">return</span> <span class="number">NULL</span>;
}</code></pre>

            <div class="box box-warning">
                <div class="box-title">âš ï¸ De ce WHILE È™i nu IF?</div>
                <p><strong>Spurious wakeups:</strong> pthread_cond_wait() poate returna chiar dacÄƒ nimeni nu a apelat signal/broadcast. Standard-ul permite asta pentru optimizare.</p>
                <p><strong>Stolen wakeups:</strong> Alt thread poate ajunge primul È™i consuma condiÈ›ia Ã®nainte ca thread-ul trezit sÄƒ verifice.</p>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             PRODUCER-CONSUMER
             â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="slide" id="patterns">
            <h1 class="slide-title yellow">ğŸ­ Pattern: Producer-Consumer</h1>

            <div class="thread-diagram">
<span class="comment">Bounded Buffer / Circular Queue:</span>

    PRODUCERS                    BUFFER                      CONSUMERS
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ <span style="color: var(--thread-1);">Prod 1</span>  â”‚â”€â”€â”€â”€â”€â”€â”        â”‚ â”‚ â”‚ â”‚ â”‚ â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”‚ <span style="color: var(--thread-3);">Cons 1</span>  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚        â””â”€â”´â”€â”´â”€â”´â”€â”´â”€â”˜        â”‚        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â””â”€â”€â”€â”€â”€â”€â”€â–º  <span style="color: var(--warning);">head</span>    <span style="color: var(--success);">tail</span> â”€â”€â”€â”€â”€â”€â”˜        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ <span style="color: var(--thread-2);">Prod 2</span>  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â†“       â†‘ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ <span style="color: var(--thread-4);">Cons 2</span>  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚Aâ”‚Bâ”‚Câ”‚ â”‚ â”‚                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â””â”€â”´â”€â”´â”€â”´â”€â”´â”€â”˜

<span class="comment">Sincronizare necesarÄƒ:</span>
â€¢ <span style="color: var(--accent-cyan);">Mutex:</span> protejeazÄƒ accesul la buffer
â€¢ <span style="color: var(--accent-magenta);">Cond not_full:</span> producers aÈ™teaptÄƒ cÃ¢nd buffer plin
â€¢ <span style="color: var(--accent-green);">Cond not_empty:</span> consumers aÈ™teaptÄƒ cÃ¢nd buffer gol
            </div>

            <pre data-lang="C"><code><span class="keyword">typedef struct</span> {
    <span class="type">void</span> **items;
    <span class="type">size_t</span> capacity;
    <span class="type">size_t</span> count;
    <span class="type">size_t</span> head;      <span class="comment">/* Index pentru citire (consumator) */</span>
    <span class="type">size_t</span> tail;      <span class="comment">/* Index pentru scriere (producÄƒtor) */</span>
    
    <span class="type">pthread_mutex_t</span> mutex;
    <span class="type">pthread_cond_t</span> not_full;
    <span class="type">pthread_cond_t</span> not_empty;
} BoundedBuffer;

<span class="type">void</span> <span class="function">buffer_put</span>(BoundedBuffer *buf, <span class="type">void</span> *item) {
    <span class="function">pthread_mutex_lock</span>(&buf->mutex);
    
    <span class="comment">/* AÈ™teaptÄƒ cÃ¢t timp buffer-ul e plin */</span>
    <span class="keyword">while</span> (buf->count == buf->capacity) {
        <span class="function">pthread_cond_wait</span>(&buf->not_full, &buf->mutex);
    }
    
    buf->items[buf->tail] = item;
    buf->tail = (buf->tail + <span class="number">1</span>) % buf->capacity;
    buf->count++;
    
    <span class="function">pthread_cond_signal</span>(&buf->not_empty);
    <span class="function">pthread_mutex_unlock</span>(&buf->mutex);
}

<span class="type">void</span>* <span class="function">buffer_get</span>(BoundedBuffer *buf) {
    <span class="function">pthread_mutex_lock</span>(&buf->mutex);
    
    <span class="comment">/* AÈ™teaptÄƒ cÃ¢t timp buffer-ul e gol */</span>
    <span class="keyword">while</span> (buf->count == <span class="number">0</span>) {
        <span class="function">pthread_cond_wait</span>(&buf->not_empty, &buf->mutex);
    }
    
    <span class="type">void</span> *item = buf->items[buf->head];
    buf->head = (buf->head + <span class="number">1</span>) % buf->capacity;
    buf->count--;
    
    <span class="function">pthread_cond_signal</span>(&buf->not_full);
    <span class="function">pthread_mutex_unlock</span>(&buf->mutex);
    
    <span class="keyword">return</span> item;
}</code></pre>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             THREAD POOL
             â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="slide" id="threadpool">
            <h1 class="slide-title cyan">ğŸŠ Thread Pool</h1>

            <div class="box box-info">
                <div class="box-title">ğŸ’¡ De ce Thread Pool?</div>
                <ul>
                    <li><strong>Reutilizare:</strong> EvitÄƒ costul creÄƒrii/distrugerii thread-urilor pentru fiecare task</li>
                    <li><strong>Limitare:</strong> ControleazÄƒ numÄƒrul maxim de thread-uri active</li>
                    <li><strong>Load balancing:</strong> Taskurile sunt distribuite automat</li>
                </ul>
            </div>

            <div class="thread-diagram">
<span class="comment">Arhitectura Thread Pool:</span>

        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                        <span style="color: var(--accent-cyan);">THREAD POOL</span>                            â”‚
        â”‚                                                                 â”‚
        â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
        â”‚  â”‚              <span style="color: var(--accent-yellow);">TASK QUEUE</span> (thread-safe)               â”‚   â”‚
        â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”    â”‚   â”‚
        â”‚  â”‚  â”‚Task1â”‚Task2â”‚Task3â”‚Task4â”‚     â”‚     â”‚     â”‚     â”‚    â”‚   â”‚
        â”‚  â”‚  â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜    â”‚   â”‚
        â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
        â”‚                              â”‚                                  â”‚
        â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
        â”‚              â–¼               â–¼               â–¼                  â”‚
        â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
        â”‚         â”‚<span style="color: var(--thread-1);">Worker 1</span> â”‚    â”‚<span style="color: var(--thread-2);">Worker 2</span> â”‚    â”‚<span style="color: var(--thread-3);">Worker 3</span> â”‚              â”‚
        â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
        â”‚              â”‚               â”‚               â”‚                  â”‚
        â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
        â”‚                              â–¼                                  â”‚
        â”‚                         <span style="color: var(--accent-green);">Results</span>                               â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

<span class="comment">Lifecycle:</span>
1. <span style="color: var(--accent-cyan);">submit(task)</span> â†’ adaugÄƒ Ã®n queue
2. <span style="color: var(--thread-1);">Worker</span> idle â†’ extrage task din queue
3. <span style="color: var(--thread-1);">Worker</span> executÄƒ task
4. <span style="color: var(--thread-1);">Worker</span> redevine idle, cautÄƒ alt task
            </div>

            <pre data-lang="C"><code><span class="keyword">typedef struct</span> Task {
    <span class="type">void</span> (*function)(<span class="type">void</span>*);   <span class="comment">/* FuncÈ›ia de executat */</span>
    <span class="type">void</span> *argument;            <span class="comment">/* Argument pentru funcÈ›ie */</span>
    <span class="keyword">struct</span> Task *next;         <span class="comment">/* Pentru listÄƒ Ã®nlÄƒnÈ›uitÄƒ */</span>
} Task;

<span class="keyword">typedef struct</span> {
    <span class="type">pthread_t</span> *threads;        <span class="comment">/* Array de worker threads */</span>
    <span class="type">size_t</span> num_threads;
    
    Task *queue_head;
    Task *queue_tail;
    <span class="type">size_t</span> queue_size;
    
    <span class="type">pthread_mutex_t</span> mutex;
    <span class="type">pthread_cond_t</span> not_empty;
    
    <span class="type">volatile bool</span> shutdown;
} ThreadPool;

<span class="comment">/* FuncÈ›ia executatÄƒ de fiecare worker */</span>
<span class="type">void</span>* <span class="function">worker_thread</span>(<span class="type">void</span> *arg) {
    ThreadPool *pool = (ThreadPool*)arg;
    
    <span class="keyword">while</span> (<span class="number">1</span>) {
        <span class="function">pthread_mutex_lock</span>(&pool->mutex);
        
        <span class="comment">/* AÈ™teaptÄƒ task sau shutdown */</span>
        <span class="keyword">while</span> (pool->queue_size == <span class="number">0</span> && !pool->shutdown) {
            <span class="function">pthread_cond_wait</span>(&pool->not_empty, &pool->mutex);
        }
        
        <span class="keyword">if</span> (pool->shutdown && pool->queue_size == <span class="number">0</span>) {
            <span class="function">pthread_mutex_unlock</span>(&pool->mutex);
            <span class="keyword">break</span>;  <span class="comment">/* Exit thread */</span>
        }
        
        <span class="comment">/* Extrage task din coadÄƒ */</span>
        Task *task = pool->queue_head;
        pool->queue_head = task->next;
        pool->queue_size--;
        
        <span class="function">pthread_mutex_unlock</span>(&pool->mutex);
        
        <span class="comment">/* ExecutÄƒ task */</span>
        task-><span class="function">function</span>(task->argument);
        <span class="function">free</span>(task);
    }
    
    <span class="keyword">return</span> <span class="number">NULL</span>;
}</code></pre>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             C11 ATOMICS
             â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="slide" id="lockfree">
            <h1 class="slide-title green">âš›ï¸ C11 Atomics È™i Lock-free</h1>

            <div class="box box-info">
                <div class="box-title">ğŸ’¡ Ce sunt OperaÈ›iile Atomice?</div>
                <p>OperaÈ›ii care se executÄƒ <strong>indivizibil</strong> - nu pot fi Ã®ntrerupte sau observate parÈ›ial de alte thread-uri. Hardware-ul garanteazÄƒ atomicitatea.</p>
            </div>

            <h2>OperaÈ›ii Atomice Ã®n C11</h2>

            <pre data-lang="C"><code><span class="preprocessor">#include</span> <span class="string">&lt;stdatomic.h&gt;</span>

<span class="comment">/* Declarare variabilÄƒ atomicÄƒ */</span>
<span class="type">atomic_int</span> counter = <span class="number">0</span>;

<span class="comment">/* OperaÈ›ii atomice de bazÄƒ */</span>
<span class="function">atomic_store</span>(&counter, <span class="number">42</span>);                   <span class="comment">/* Scriere atomicÄƒ */</span>
<span class="type">int</span> val = <span class="function">atomic_load</span>(&counter);             <span class="comment">/* Citire atomicÄƒ */</span>

<span class="comment">/* Read-Modify-Write (RMW) operations */</span>
<span class="function">atomic_fetch_add</span>(&counter, <span class="number">1</span>);               <span class="comment">/* counter++ (returneazÄƒ valoarea veche) */</span>
<span class="function">atomic_fetch_sub</span>(&counter, <span class="number">1</span>);               <span class="comment">/* counter-- */</span>
<span class="function">atomic_fetch_or</span>(&counter, <span class="number">0xFF</span>);             <span class="comment">/* counter |= 0xFF */</span>
<span class="function">atomic_fetch_and</span>(&counter, <span class="number">0xFF</span>);            <span class="comment">/* counter &= 0xFF */</span>
<span class="function">atomic_fetch_xor</span>(&counter, <span class="number">0xFF</span>);            <span class="comment">/* counter ^= 0xFF */</span>

<span class="comment">/* Compare-And-Swap (CAS) - operaÈ›ia fundamentalÄƒ lock-free */</span>
<span class="type">int</span> expected = <span class="number">10</span>;
<span class="type">int</span> desired = <span class="number">20</span>;

<span class="keyword">if</span> (<span class="function">atomic_compare_exchange_strong</span>(&counter, &expected, desired)) {
    <span class="comment">/* Succes: counter era 10, acum e 20 */</span>
} <span class="keyword">else</span> {
    <span class="comment">/* EÈ™ec: counter NU era 10 */</span>
    <span class="comment">/* expected conÈ›ine acum valoarea realÄƒ */</span>
}</code></pre>

            <h2>Lock-free Stack (Treiber Stack)</h2>

            <pre data-lang="C"><code><span class="keyword">typedef struct</span> Node {
    <span class="type">void</span> *data;
    <span class="keyword">struct</span> Node *next;
} Node;

<span class="keyword">typedef struct</span> {
    <span class="type">_Atomic</span>(Node*) head;
} LockFreeStack;

<span class="type">void</span> <span class="function">lf_push</span>(LockFreeStack *stack, <span class="type">void</span> *data) {
    Node *node = <span class="function">malloc</span>(<span class="keyword">sizeof</span>(Node));
    node->data = data;
    
    Node *old_head;
    <span class="keyword">do</span> {
        old_head = <span class="function">atomic_load</span>(&stack->head);
        node->next = old_head;
        <span class="comment">/* CAS: dacÄƒ head nu s-a schimbat, actualizeazÄƒ-l la node */</span>
    } <span class="keyword">while</span> (!<span class="function">atomic_compare_exchange_weak</span>(&stack->head, &old_head, node));
}

<span class="type">void</span>* <span class="function">lf_pop</span>(LockFreeStack *stack) {
    Node *old_head;
    Node *new_head;
    <span class="type">void</span> *data;
    
    <span class="keyword">do</span> {
        old_head = <span class="function">atomic_load</span>(&stack->head);
        <span class="keyword">if</span> (old_head == <span class="number">NULL</span>) {
            <span class="keyword">return</span> <span class="number">NULL</span>;  <span class="comment">/* Stack gol */</span>
        }
        new_head = old_head->next;
        data = old_head->data;
        <span class="comment">/* CAS: dacÄƒ head nu s-a schimbat, actualizeazÄƒ-l la new_head */</span>
    } <span class="keyword">while</span> (!<span class="function">atomic_compare_exchange_weak</span>(&stack->head, &old_head, new_head));
    
    <span class="function">free</span>(old_head);
    <span class="keyword">return</span> data;
}</code></pre>

            <div class="box box-warning">
                <div class="box-title">âš ï¸ Problema ABA</div>
                <p>Thread A citeÈ™te valoarea X, e Ã®ntrerupt. Thread B schimbÄƒ Xâ†’Yâ†’X. Thread A reia, CAS reuÈ™eÈ™te (vede tot X), dar starea s-a schimbat!</p>
                <p><strong>SoluÈ›ii:</strong> Tagged pointers (version counter), hazard pointers, epoch-based reclamation.</p>
            </div>

            <h2>Mutex vs Spinlock vs Atomics</h2>

            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Mutex</th>
                            <th>Spinlock</th>
                            <th>Atomics</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Blocare</td>
                            <td>Thread doarme (yield to OS)</td>
                            <td>Busy-wait (spin)</td>
                            <td>N/A (lock-free)</td>
                        </tr>
                        <tr>
                            <td>Overhead</td>
                            <td>Context switch (~1Î¼s)</td>
                            <td>CPU cycle (~ns)</td>
                            <td>Minimal (~ns)</td>
                        </tr>
                        <tr>
                            <td>CÃ¢nd e bun</td>
                            <td>SecÈ›iuni lungi, I/O</td>
                            <td>SecÈ›iuni foarte scurte</td>
                            <td>OperaÈ›ii simple (counter)</td>
                        </tr>
                        <tr>
                            <td>Priority inversion</td>
                            <td>PosibilÄƒ</td>
                            <td>PosibilÄƒ</td>
                            <td>Nu</td>
                        </tr>
                        <tr>
                            <td>Complexitate</td>
                            <td>SimplÄƒ</td>
                            <td>SimplÄƒ</td>
                            <td>Poate fi foarte complexÄƒ</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             AMDAHL'S LAW È˜I BENCHMARK
             â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="slide" id="benchmark">
            <h1 class="slide-title orange">ğŸ“Š Legea lui Amdahl È™i Benchmarking</h1>

            <div class="formula">
                <div class="formula-name">Legea lui Amdahl</div>
                S(n) = 1 / ((1 - P) + P/n)
            </div>

            <div class="card-grid">
                <div class="card">
                    <div class="card-title">ğŸ“ Variabilele</div>
                    <ul>
                        <li><strong>S(n)</strong> = Speedup cu n procesoare</li>
                        <li><strong>P</strong> = FracÈ›iunea paralelizabilÄƒ (0 â‰¤ P â‰¤ 1)</li>
                        <li><strong>n</strong> = NumÄƒrul de procesoare</li>
                        <li><strong>1-P</strong> = FracÈ›iunea serialÄƒ (bottleneck!)</li>
                    </ul>
                </div>
                <div class="card">
                    <div class="card-title">ğŸš€ Limita TeoreticÄƒ</div>
                    <p>CÃ¢nd n â†’ âˆ:</p>
                    <div class="formula" style="margin: 1rem 0; font-size: 1.1rem;">
                        S<sub>max</sub> = 1 / (1 - P)
                    </div>
                    <p>Cu P = 0.95 (95% paralel): S<sub>max</sub> = 20Ã—</p>
                    <p>Cu P = 0.99 (99% paralel): S<sub>max</sub> = 100Ã—</p>
                </div>
            </div>

            <div class="thread-diagram">
<span class="comment">Vizualizare Legea lui Amdahl:</span>

Speedup
   â”‚
20 â”¼ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ <span style="color: var(--success);">P=0.95 (limitÄƒ=20)</span>
   â”‚                                    <span style="color: var(--success);">â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span>
   â”‚                               <span style="color: var(--success);">â•â•â•â•</span>
   â”‚                          <span style="color: var(--success);">â•â•â•â•â•</span>
   â”‚                     <span style="color: var(--success);">â•â•â•â•â•</span>
   â”‚                <span style="color: var(--success);">â•â•â•â•â•</span>
10 â”¼ â”€ â”€ â”€ â”€ â”€ <span style="color: var(--success);">â•â•â•â•</span>â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ <span style="color: var(--warning);">P=0.90 (limitÄƒ=10)</span>
   â”‚          <span style="color: var(--success);">â•</span>                         <span style="color: var(--warning);">â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span>
   â”‚        <span style="color: var(--success);">â•â•</span>                     <span style="color: var(--warning);">â•â•â•â•â•</span>
   â”‚       <span style="color: var(--success);">â•</span>                  <span style="color: var(--warning);">â•â•â•â•â•</span>
   â”‚     <span style="color: var(--success);">â•â•</span>              <span style="color: var(--warning);">â•â•â•â•â•</span>
 5 â”¼ â”€ <span style="color: var(--success);">â•â•</span>â”€ â”€ â”€ â”€ â”€ <span style="color: var(--warning);">â•â•â•â•</span>â”€ â”€ â”€ â”€ â”€ â”€ <span style="color: var(--danger);">P=0.75 (limitÄƒ=4)</span>
   â”‚  <span style="color: var(--success);">â•</span>        <span style="color: var(--warning);">â•â•â•â•</span>                   <span style="color: var(--danger);">â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span>
   â”‚ <span style="color: var(--success);">â•</span>      <span style="color: var(--warning);">â•â•â•â•</span>                  <span style="color: var(--danger);">â•â•â•â•</span>
   â”‚<span style="color: var(--success);">â•</span>     <span style="color: var(--warning);">â•â•â•</span>                <span style="color: var(--danger);">â•â•â•â•</span>
   â”‚<span style="color: var(--success);">â•</span>    <span style="color: var(--warning);">â•â•</span>                <span style="color: var(--danger);">â•â•â•â•</span>
 1 â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   1   2   4   8  16  32  64 128 256 512 1024   Procesoare (n)
            </div>

            <h2>Metrici de PerformanÈ›Äƒ</h2>

            <div class="card-grid">
                <div class="card">
                    <div class="card-title">â±ï¸ Speedup</div>
                    <div class="formula" style="margin: 1rem 0; font-size: 1rem;">
                        Speedup = T<sub>secvenÈ›ial</sub> / T<sub>paralel</sub>
                    </div>
                    <p>Linear speedup: S(n) = n</p>
                    <p>Super-linear: S(n) > n (rar, cache effects)</p>
                </div>
                <div class="card">
                    <div class="card-title">ğŸ“ˆ EficienÈ›Äƒ</div>
                    <div class="formula" style="margin: 1rem 0; font-size: 1rem;">
                        Efficiency = Speedup / n
                    </div>
                    <p>Ideal: E = 100%</p>
                    <p>Real: E < 100% (overhead, Amdahl)</p>
                </div>
                <div class="card">
                    <div class="card-title">ğŸ“‰ Scalabilitate</div>
                    <p><strong>Strong scaling:</strong> ProblemÄƒ fixÄƒ, adÄƒugÄƒm procesoare</p>
                    <p><strong>Weak scaling:</strong> ProblemÄƒ creÈ™te proporÈ›ional cu procesoarele</p>
                </div>
            </div>

            <pre data-lang="C"><code><span class="comment">/* Benchmark simplu pentru parallel sort */</span>
<span class="preprocessor">#define</span> NUM_RUNS <span class="number">5</span>

<span class="type">double</span> <span class="function">benchmark_sort</span>(<span class="type">int</span> *arr, <span class="type">size_t</span> n, <span class="type">int</span> num_threads) {
    <span class="type">double</span> total_time = <span class="number">0.0</span>;
    
    <span class="keyword">for</span> (<span class="type">int</span> run = <span class="number">0</span>; run < NUM_RUNS; run++) {
        <span class="comment">/* Copie array pentru a nu afecta alte runs */</span>
        <span class="type">int</span> *copy = <span class="function">copy_array</span>(arr, n);
        
        <span class="type">struct timespec</span> start, end;
        <span class="function">clock_gettime</span>(CLOCK_MONOTONIC, &start);
        
        <span class="function">parallel_merge_sort</span>(copy, n, num_threads);
        
        <span class="function">clock_gettime</span>(CLOCK_MONOTONIC, &end);
        
        <span class="type">double</span> elapsed = (end.tv_sec - start.tv_sec) +
                        (end.tv_nsec - start.tv_nsec) / <span class="number">1e9</span>;
        total_time += elapsed;
        
        <span class="function">free</span>(copy);
    }
    
    <span class="keyword">return</span> total_time / NUM_RUNS;
}

<span class="type">void</span> <span class="function">run_benchmark</span>(<span class="type">int</span> *arr, <span class="type">size_t</span> n) {
    <span class="type">double</span> t_seq = <span class="function">benchmark_sort</span>(arr, n, <span class="number">1</span>);
    
    <span class="function">printf</span>(<span class="string">"Threads | Time (s) | Speedup | Efficiency\n"</span>);
    <span class="function">printf</span>(<span class="string">"--------|----------|---------|----------\n"</span>);
    
    <span class="keyword">for</span> (<span class="type">int</span> threads = <span class="number">1</span>; threads <= <span class="number">8</span>; threads *= <span class="number">2</span>) {
        <span class="type">double</span> t = <span class="function">benchmark_sort</span>(arr, n, threads);
        <span class="type">double</span> speedup = t_seq / t;
        <span class="type">double</span> efficiency = speedup / threads * <span class="number">100</span>;
        
        <span class="function">printf</span>(<span class="string">"   %d    | %.4f   |  %.2fx  |   %.1f%%\n"</span>,
               threads, t, speedup, efficiency);
    }
}</code></pre>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             EXERCIÈšII
             â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="slide" id="exercitii">
            <h1 class="slide-title cyan">ğŸ’» ExerciÈ›ii de Laborator</h1>

            <div class="card-grid">
                <div class="card">
                    <div class="card-title">ğŸ“‹ ExerciÈ›iul 1: Log Processor</div>
                    <h4>Obiectiv</h4>
                    <p>ImplementaÈ›i un sistem producer-consumer pentru procesarea fiÈ™ierelor de log.</p>
                    
                    <h4>CerinÈ›e</h4>
                    <ul>
                        <li>N producÄƒtori citesc linii din fiÈ™iere</li>
                        <li>M consumatori proceseazÄƒ (parseazÄƒ, filtreazÄƒ)</li>
                        <li>Buffer circular thread-safe</li>
                        <li>Statistici per-thread È™i totale</li>
                        <li>Graceful shutdown la EOF</li>
                    </ul>
                    
                    <h4>FiÈ™iere</h4>
                    <p><code>src/exercise1.c</code>, <code>data/log_entries.txt</code></p>
                </div>

                <div class="card">
                    <div class="card-title">ğŸ“Š ExerciÈ›iul 2: Parallel Sort</div>
                    <h4>Obiectiv</h4>
                    <p>ImplementaÈ›i Quick Sort paralel cu benchmark È™i analizÄƒ.</p>
                    
                    <h4>CerinÈ›e</h4>
                    <ul>
                        <li>Threshold pentru switch la secvenÈ›ial</li>
                        <li>Limitare numÄƒr threads active</li>
                        <li>Benchmark cu 1, 2, 4, 8 threads</li>
                        <li>Calcul speedup È™i eficienÈ›Äƒ</li>
                        <li>ComparaÈ›ie cu Amdahl teoretic</li>
                    </ul>
                    
                    <h4>FiÈ™iere</h4>
                    <p><code>src/exercise2.c</code>, <code>data/large_numbers.txt</code></p>
                </div>
            </div>

            <h2>ğŸ“ Teme de CasÄƒ</h2>

            <div class="card-grid">
                <div class="card">
                    <div class="card-title">ğŸ† Tema 1: Thread Pool cu Futures (50p)</div>
                    <ul>
                        <li>StructurÄƒ ThreadPool cu workers È™i task queue</li>
                        <li>API Future: submit, get, get_timeout, cancel, is_done</li>
                        <li>Graceful shutdown (finalizeazÄƒ running, reject noi)</li>
                        <li>Memory safety (Valgrind clean)</li>
                    </ul>
                </div>

                <div class="card">
                    <div class="card-title">ğŸ† Tema 2: Map-Reduce (50p)</div>
                    <ul>
                        <li>Map phase: procesare paralelÄƒ fiÈ™iere</li>
                        <li>Shuffle: distribuire key-value la reducers</li>
                        <li>Reduce phase: agregare rezultate</li>
                        <li>Benchmark È™i raport</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             PYTHON COMPARISON
             â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="slide" id="python">
            <h1 class="slide-title purple">ğŸ ComparaÈ›ie cu Python</h1>

            <div class="box box-warning">
                <div class="box-title">âš ï¸ GIL (Global Interpreter Lock)</div>
                <p>Python are un lock global care previne execuÈ›ia simultanÄƒ a bytecode-ului Python. ImplicaÈ›ii:</p>
                <ul>
                    <li><strong>threading</strong> - NU oferÄƒ paralelism real pentru CPU-bound</li>
                    <li><strong>multiprocessing</strong> - procese separate, fÄƒrÄƒ GIL, paralelism real</li>
                    <li><strong>asyncio</strong> - concurenÈ›Äƒ pentru I/O-bound, single-threaded</li>
                </ul>
            </div>

            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>C (pthreads)</th>
                            <th>Python threading</th>
                            <th>Python multiprocessing</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Paralelism CPU</td>
                            <td>âœ“ Real</td>
                            <td>âœ— GIL blocheazÄƒ</td>
                            <td>âœ“ Procese separate</td>
                        </tr>
                        <tr>
                            <td>Memorie partajatÄƒ</td>
                            <td>âœ“ Direct</td>
                            <td>âœ“ Direct</td>
                            <td>âœ— NecesitÄƒ IPC/Manager</td>
                        </tr>
                        <tr>
                            <td>Overhead creare</td>
                            <td>~Î¼s</td>
                            <td>~Î¼s</td>
                            <td>~ms (fork)</td>
                        </tr>
                        <tr>
                            <td>Complexitate</td>
                            <td>RidicatÄƒ</td>
                            <td>Medie</td>
                            <td>Medie</td>
                        </tr>
                        <tr>
                            <td>CÃ¢nd e potrivit</td>
                            <td>Orice</td>
                            <td>I/O bound</td>
                            <td>CPU bound</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <pre data-lang="Python"><code><span class="comment"># Python threading - NU oferÄƒ speedup pentru CPU-bound!</span>
<span class="keyword">import</span> threading
<span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor

<span class="comment"># Echivalent pthread_create + pthread_join</span>
<span class="keyword">def</span> <span class="function">worker</span>(data):
    <span class="keyword">return</span> <span class="function">sum</span>(x*x <span class="keyword">for</span> x <span class="keyword">in</span> data)

threads = [threading.Thread(target=worker, args=(chunk,)) <span class="keyword">for</span> chunk <span class="keyword">in</span> chunks]
<span class="keyword">for</span> t <span class="keyword">in</span> threads: t.start()
<span class="keyword">for</span> t <span class="keyword">in</span> threads: t.join()

<span class="comment"># Thread pool (echivalent ThreadPool din C)</span>
<span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> pool:
    futures = [pool.submit(worker, chunk) <span class="keyword">for</span> chunk <span class="keyword">in</span> chunks]
    results = [f.result() <span class="keyword">for</span> f <span class="keyword">in</span> futures]

<span class="comment"># Python multiprocessing - OFERÄ‚ speedup pentru CPU-bound!</span>
<span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool

<span class="keyword">with</span> Pool(processes=<span class="number">4</span>) <span class="keyword">as</span> pool:
    results = pool.map(worker, chunks)  <span class="comment"># Paralelism real!</span></code></pre>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             RESURSE È˜I BIBLIOGRAFIE
             â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="slide" id="resurse">
            <h1 class="slide-title yellow">ğŸ“– Resurse È™i Bibliografie</h1>

            <div class="card-grid">
                <div class="card">
                    <div class="card-title">ğŸ“š CÄƒrÈ›i EsenÈ›iale</div>
                    <ul>
                        <li><strong>Butenhof</strong> - "Programming with POSIX Threads"</li>
                        <li><strong>Herlihy & Shavit</strong> - "The Art of Multiprocessor Programming"</li>
                        <li><strong>Williams</strong> - "C++ Concurrency in Action" (concepte aplicabile È™i Ã®n C)</li>
                    </ul>
                </div>

                <div class="card">
                    <div class="card-title">ğŸŒ Resurse Online</div>
                    <ul>
                        <li><a href="https://man7.org/linux/man-pages/man7/pthreads.7.html" target="_blank">POSIX Threads Manual</a></li>
                        <li><a href="https://en.cppreference.com/w/c/atomic" target="_blank">C11 Atomics Reference</a></li>
                        <li><a href="https://www.youtube.com/watch?v=A8eCGOqgvH4" target="_blank">MIT 6.172: Multithreading</a></li>
                    </ul>
                </div>

                <div class="card">
                    <div class="card-title">ğŸ› ï¸ Tools</div>
                    <ul>
                        <li><strong>Valgrind (Helgrind, DRD)</strong> - detectare race conditions</li>
                        <li><strong>ThreadSanitizer</strong> - gcc/clang -fsanitize=thread</li>
                        <li><strong>perf</strong> - Linux performance profiling</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             PREVIEW FINAL
             â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="slide" id="final">
            <h1 class="slide-title green">âœ… Recapitulare</h1>

            <div class="card-grid">
                <div class="card">
                    <div class="card-title">ğŸ§µ Threads</div>
                    <ul>
                        <li>pthread_create, pthread_join</li>
                        <li>Memorie partajatÄƒ Ã®ntre threads</li>
                        <li>Lifecycle: creare â†’ execuÈ›ie â†’ terminare</li>
                    </ul>
                </div>

                <div class="card">
                    <div class="card-title">ğŸ”’ Sincronizare</div>
                    <ul>
                        <li>Mutex pentru excludere mutualÄƒ</li>
                        <li>Semafoare pentru resurse limitate</li>
                        <li>Condition variables pentru aÈ™teptare condiÈ›ionatÄƒ</li>
                    </ul>
                </div>

                <div class="card">
                    <div class="card-title">âš ï¸ Probleme</div>
                    <ul>
                        <li>Race conditions â†’ mutex/atomics</li>
                        <li>Deadlock â†’ ordonare/timeout</li>
                        <li>Starvation â†’ fairness</li>
                    </ul>
                </div>

                <div class="card">
                    <div class="card-title">ğŸ“Š PerformanÈ›Äƒ</div>
                    <ul>
                        <li>Legea lui Amdahl limiteazÄƒ speedup</li>
                        <li>EficienÈ›Äƒ = Speedup / threads</li>
                        <li>Profile Ã®nainte de optimizare!</li>
                    </ul>
                </div>
            </div>

            <div class="box box-success" style="margin-top: 2rem;">
                <div class="box-title">ğŸ¯ AÈ›i ÃnvÄƒÈ›at</div>
                <p>Fundamentele programÄƒrii paralele È™i concurente Ã®n C: de la crearea thread-urilor, prin sincronizare cu mutex È™i semafoare, la structuri lock-free cu C11 atomics. Acum puteÈ›i exploata eficient procesoarele multi-core!</p>
            </div>

            <div style="text-align: center; margin-top: 3rem;">
                <p style="font-size: 1.5rem; color: var(--accent-cyan);">ğŸš€ Succes la implementare!</p>
                <p style="color: var(--text-muted);">ÃntrebÄƒri? ConsultaÈ›i README.md sau materialele suplimentare.</p>
            </div>
        </section>
    </main>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         FOOTER
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <footer>
        <p><strong>SÄƒptÄƒmÃ¢na 20: Programare ParalelÄƒ È™i ConcurentÄƒ Ã®n C</strong></p>
        <p>Curs "Algoritmi È™i Tehnici de Programare" (ATP)</p>
        <p>Academia de Studii Economice din BucureÈ™ti - CSIE</p>
        <p>Actualizat: Ianuarie 2026</p>
    </footer>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         SCROLL TO TOP
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div class="scroll-indicator" onclick="window.scrollTo({top: 0, behavior: 'smooth'})">
        <svg viewBox="0 0 24 24"><path d="M12 4l-8 8h5v8h6v-8h5z"/></svg>
    </div>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         SCRIPTS
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <script>
        // Progress bar pe scroll
        window.addEventListener('scroll', () => {
            const winScroll = document.documentElement.scrollTop;
            const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            const scrolled = (winScroll / height) * 100;
            document.getElementById('progressBar').style.width = scrolled + '%';
        });

        // AnimaÈ›ie pentru task blocks
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.querySelectorAll('.task-block').forEach((block, i) => {
                        block.style.animationDelay = (i * 0.1) + 's';
                        block.style.opacity = '1';
                    });
                }
            });
        }, { threshold: 0.2 });

        document.querySelectorAll('.parallel-demo').forEach(demo => {
            observer.observe(demo);
        });

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            const slides = document.querySelectorAll('.slide');
            const currentSlide = Array.from(slides).findIndex(slide => {
                const rect = slide.getBoundingClientRect();
                return rect.top >= 0 && rect.top < window.innerHeight / 2;
            });

            if (e.key === 'ArrowDown' || e.key === 'PageDown') {
                e.preventDefault();
                if (currentSlide < slides.length - 1) {
                    slides[currentSlide + 1].scrollIntoView({ behavior: 'smooth' });
                }
            } else if (e.key === 'ArrowUp' || e.key === 'PageUp') {
                e.preventDefault();
                if (currentSlide > 0) {
                    slides[currentSlide - 1].scrollIntoView({ behavior: 'smooth' });
                }
            } else if (e.key === 'Home') {
                e.preventDefault();
                slides[0].scrollIntoView({ behavior: 'smooth' });
            } else if (e.key === 'End') {
                e.preventDefault();
                slides[slides.length - 1].scrollIntoView({ behavior: 'smooth' });
            }
        });

        // Highlight current section in nav
        const sections = document.querySelectorAll('section[id]');
        const navLinks = document.querySelectorAll('.nav-links a');

        window.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (scrollY >= sectionTop - 200) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.style.background = 'transparent';
                link.style.borderColor = 'transparent';
                if (link.getAttribute('href') === '#' + current) {
                    link.style.background = 'rgba(0, 217, 255, 0.2)';
                    link.style.borderColor = 'var(--accent-cyan)';
                }
            });
        });
    </script>
</body>
</html>
