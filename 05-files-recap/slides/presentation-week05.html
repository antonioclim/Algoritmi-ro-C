<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SÄƒptÄƒmÃ¢na 5: Stive (Stack) - ATP</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-yellow: #d29922;
            --accent-red: #f85149;
            --accent-purple: #a371f7;
            --border-color: #30363d;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow: hidden;
        }

        /* Progress Bar */
        .progress-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: var(--bg-tertiary);
            z-index: 1000;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            transition: width 0.3s ease;
        }

        /* Slide Container */
        .slides-container {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 60px 80px;
            display: none;
            opacity: 0;
            transition: opacity 0.4s ease;
            overflow-y: auto;
        }

        .slide.active {
            display: block;
            opacity: 1;
        }

        /* Slide Counter */
        .slide-counter {
            position: fixed;
            bottom: 20px;
            left: 30px;
            font-size: 14px;
            color: var(--text-secondary);
            z-index: 100;
        }

        /* Navigation Buttons */
        .nav-buttons {
            position: fixed;
            bottom: 20px;
            right: 30px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .nav-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .nav-btn:hover {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Typography */
        h1 {
            font-size: 2.8em;
            margin-bottom: 30px;
            color: var(--text-primary);
            border-bottom: 3px solid var(--accent-blue);
            padding-bottom: 15px;
        }

        h2 {
            font-size: 2.2em;
            margin-bottom: 25px;
            color: var(--accent-blue);
        }

        h3 {
            font-size: 1.6em;
            margin: 20px 0 15px 0;
            color: var(--accent-green);
        }

        p {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: var(--text-secondary);
        }

        /* Title Slide */
        .title-slide {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .title-slide h1 {
            font-size: 3.5em;
            border: none;
            margin-bottom: 20px;
        }

        .title-slide .subtitle {
            font-size: 1.8em;
            color: var(--accent-blue);
            margin-bottom: 40px;
        }

        .title-slide .meta {
            font-size: 1.2em;
            color: var(--text-secondary);
        }

        .title-slide .course-badge {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            padding: 15px 40px;
            border-radius: 30px;
            font-size: 1.3em;
            margin-bottom: 30px;
        }

        /* Lists */
        ul, ol {
            margin: 15px 0 15px 30px;
            font-size: 1.15em;
        }

        li {
            margin: 12px 0;
            color: var(--text-secondary);
        }

        li strong {
            color: var(--text-primary);
        }

        /* Code Blocks */
        .code-block {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin: 20px 0;
            overflow: hidden;
        }

        .code-header {
            background: var(--bg-tertiary);
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
        }

        .code-header span {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .lang-badge {
            background: var(--accent-blue);
            color: var(--bg-primary);
            padding: 3px 10px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .code-block pre {
            margin: 0;
            padding: 20px;
            overflow-x: auto;
        }

        .code-block code {
            font-family: 'Fira Code', 'Cascadia Code', Consolas, monospace;
            font-size: 0.95em;
        }

        /* Info Boxes */
        .info-box {
            padding: 20px 25px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid;
        }

        .info-box.note {
            background: rgba(88, 166, 255, 0.1);
            border-color: var(--accent-blue);
        }

        .info-box.warning {
            background: rgba(210, 153, 34, 0.1);
            border-color: var(--accent-yellow);
        }

        .info-box.danger {
            background: rgba(248, 81, 73, 0.1);
            border-color: var(--accent-red);
        }

        .info-box.success {
            background: rgba(63, 185, 80, 0.1);
            border-color: var(--accent-green);
        }

        .info-box-title {
            font-weight: bold;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* ASCII Diagrams */
        .ascii-diagram {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            font-family: 'Fira Code', monospace;
            font-size: 0.95em;
            white-space: pre;
            overflow-x: auto;
            line-height: 1.4;
            color: var(--accent-green);
        }

        /* Two Column Layout */
        .two-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 20px 0;
        }

        .column {
            background: var(--bg-secondary);
            padding: 25px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .column h3 {
            margin-top: 0;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 1em;
        }

        th, td {
            padding: 15px;
            text-align: left;
            border: 1px solid var(--border-color);
        }

        th {
            background: var(--bg-tertiary);
            color: var(--accent-blue);
            font-weight: 600;
        }

        td {
            background: var(--bg-secondary);
            color: var(--text-secondary);
        }

        tr:hover td {
            background: var(--bg-tertiary);
        }

        /* Highlight */
        .highlight {
            color: var(--accent-yellow);
            font-weight: bold;
        }

        .keyword {
            color: var(--accent-purple);
        }

        /* Quote */
        blockquote {
            border-left: 4px solid var(--accent-purple);
            padding: 20px 25px;
            margin: 25px 0;
            background: var(--bg-secondary);
            border-radius: 0 8px 8px 0;
            font-style: italic;
            color: var(--text-secondary);
        }

        blockquote cite {
            display: block;
            margin-top: 15px;
            color: var(--accent-blue);
            font-style: normal;
            font-weight: bold;
        }

        /* Figure Box */
        .figure-box {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 25px;
            display: flex;
            gap: 25px;
            align-items: flex-start;
        }

        .figure-avatar {
            width: 120px;
            height: 120px;
            background: var(--bg-tertiary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            flex-shrink: 0;
        }

        .figure-info h3 {
            margin-top: 0;
        }

        /* Key Takeaways Grid */
        .takeaways-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 25px 0;
        }

        .takeaway-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            transition: transform 0.2s ease;
        }

        .takeaway-card:hover {
            transform: translateY(-5px);
            border-color: var(--accent-blue);
        }

        .takeaway-card .icon {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .takeaway-card h4 {
            color: var(--accent-blue);
            margin-bottom: 10px;
        }

        /* Complexity Table */
        .complexity-highlight {
            color: var(--accent-green);
            font-weight: bold;
        }

        /* Animations */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .slide.active > * {
            animation: fadeInUp 0.5s ease forwards;
        }

        /* Keyboard shortcuts hint */
        .keyboard-hint {
            position: fixed;
            bottom: 60px;
            left: 30px;
            font-size: 12px;
            color: var(--text-secondary);
            opacity: 0.6;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .slide {
                padding: 40px 50px;
            }
            .two-columns {
                grid-template-columns: 1fr;
            }
            .takeaways-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .slide {
                padding: 30px;
            }
            h1 { font-size: 2em; }
            h2 { font-size: 1.6em; }
            .takeaways-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Progress Bar -->
    <div class="progress-container">
        <div class="progress-bar" id="progressBar"></div>
    </div>

    <!-- Slide Counter -->
    <div class="slide-counter">
        <span id="currentSlide">1</span> / <span id="totalSlides">37</span>
    </div>

    <!-- Navigation -->
    <div class="nav-buttons">
        <button class="nav-btn" onclick="goToSlide(0)">â® Ãnceput</button>
        <button class="nav-btn" onclick="prevSlide()">â† Anterior</button>
        <button class="nav-btn" onclick="nextSlide()">UrmÄƒtor â†’</button>
        <button class="nav-btn" onclick="goToSlide(totalSlides-1)">SfÃ¢rÈ™it â­</button>
    </div>

    <div class="keyboard-hint">Navigare: â† â†’ Space Home End</div>

    <!-- Slides Container -->
    <div class="slides-container">

        <!-- Slide 1: Title -->
        <div class="slide title-slide active">
            <div class="course-badge">Algoritmi È™i Tehnici de Programare</div>
            <h1>SÄƒptÄƒmÃ¢na 5: Stive (Stack)</h1>
            <p class="subtitle">Structura de Date LIFO È™i AplicaÈ›iile Sale</p>
            <p class="meta">Facultatea de CiberneticÄƒ, StatisticÄƒ È™i InformaticÄƒ EconomicÄƒ<br>
            Universitatea de È˜tiinÈ›e Economice din BucureÈ™ti</p>
        </div>

        <!-- Slide 2: Learning Objectives -->
        <div class="slide">
            <h1>ğŸ¯ Obiective de ÃnvÄƒÈ›are</h1>
            <p>La finalul acestei sÄƒptÄƒmÃ¢ni vei fi capabil sÄƒ:</p>
            <ul>
                <li><strong>RecunoÈ™ti</strong> principiul LIFO È™i scenariile unde stiva este structura optimÄƒ</li>
                <li><strong>ÃnÈ›elegi</strong> mecanismele operaÈ›iilor <code>push</code>, <code>pop</code>, <code>peek</code></li>
                <li><strong>Aplici</strong> implementÄƒri pe vectori È™i liste Ã®nlÄƒnÈ›uite</li>
                <li><strong>Analizezi</strong> complexitatea temporalÄƒ È™i spaÈ›ialÄƒ a fiecÄƒrei implementÄƒri</li>
                <li><strong>Evaluezi</strong> corectitudinea algoritmilor bazaÈ›i pe stive</li>
                <li><strong>Creezi</strong> aplicaÈ›ii complete: evaluare expresii, verificare paranteze, DFS</li>
            </ul>
            <div class="info-box note">
                <div class="info-box-title">ğŸ“ NotÄƒ</div>
                Stiva este fundamentul multor algoritmi È™i mecanisme din informaticÄƒ, inclusiv call stack-ul folosit de fiecare program.
            </div>
        </div>

        <!-- Slide 3: Historical Context -->
        <div class="slide">
            <h1>ğŸ“œ Context Istoric</h1>
            <h3>Originea Conceptului de Stack</h3>
            <p>Conceptul de stivÄƒ Ã®È™i are rÄƒdÄƒcinile Ã®n anii 1950-1960, Ã®n dezvoltarea limbajelor de programare È™i a compilatoarelor.</p>
            
            <div class="two-columns">
                <div class="column">
                    <h3>ğŸ“… Cronologie</h3>
                    <ul>
                        <li><strong>1946:</strong> Alan Turing descrie "stiva de adrese de Ã®ntoarcere" Ã®n ACE</li>
                        <li><strong>1957:</strong> Bauer È™i Samelson folosesc stive pentru compilatoare</li>
                        <li><strong>1961:</strong> Dijkstra publicÄƒ algoritmul Shunting Yard</li>
                        <li><strong>1963:</strong> Stiva devine componentÄƒ standard a procesoarelor</li>
                    </ul>
                </div>
                <div class="column">
                    <h3>ğŸ¯ Impactul</h3>
                    <p>Stiva a revoluÈ›ionat:</p>
                    <ul>
                        <li>Implementarea apelurilor de funcÈ›ii</li>
                        <li>Evaluarea expresiilor matematice</li>
                        <li>Algoritmii de parcurgere (DFS)</li>
                        <li>Mecanismele Undo/Redo</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 4: Key Figure - Dijkstra -->
        <div class="slide">
            <h1>ğŸ‘¤ Figura Cheie: Edsger W. Dijkstra</h1>
            
            <div class="figure-box">
                <div class="figure-avatar">ğŸ§‘â€ğŸ’»</div>
                <div class="figure-info">
                    <h3>Edsger Wybe Dijkstra (1930-2002)</h3>
                    <p>Informatician olandez, laureat al Premiului Turing (1972) pentru contribuÈ›ii fundamentale la dezvoltarea limbajelor de programare.</p>
                    <ul>
                        <li><strong>Algoritmul Shunting Yard</strong> - conversie infix â†’ postfix folosind stive</li>
                        <li><strong>Algoritmul Dijkstra</strong> - cel mai scurt drum Ã®n grafuri</li>
                        <li><strong>Semafoare</strong> - sincronizare Ã®n sisteme concurente</li>
                    </ul>
                </div>
            </div>
            
            <blockquote>
                "Simplitatea este o mare virtute, dar necesitÄƒ multÄƒ muncÄƒ pentru a o atinge È™i educaÈ›ie pentru a o aprecia."
                <cite>â€” Edsger W. Dijkstra</cite>
            </blockquote>
        </div>

        <!-- Slide 5: LIFO Principle -->
        <div class="slide">
            <h1>ğŸ“š Principiul LIFO</h1>
            <h2>Last In, First Out</h2>
            
            <div class="two-columns">
                <div class="column">
                    <h3>ğŸ¯ DefiniÈ›ie</h3>
                    <p>Stiva este o structurÄƒ de date <strong>abstractÄƒ</strong> (ADT) Ã®n care:</p>
                    <ul>
                        <li>Ultimul element adÄƒugat este primul eliminat</li>
                        <li>Accesul se face doar prin <strong>vÃ¢rf</strong> (top)</li>
                        <li>Nu existÄƒ acces aleatoriu la elemente</li>
                    </ul>
                </div>
                <div class="column">
                    <h3>ğŸ“¦ Analogie</h3>
                    <p>ImagineazÄƒ-È›i un teanc de farfurii:</p>
                    <ul>
                        <li>PoÈ›i pune o farfurie doar deasupra</li>
                        <li>PoÈ›i lua doar farfuria din vÃ¢rf</li>
                        <li>Nu poÈ›i accesa farfuriile de dedesubt</li>
                    </ul>
                </div>
            </div>
            
            <div class="ascii-diagram">
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚     5     â”‚ â† TOP (ultimul adÄƒugat, primul eliminat)
           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
           â”‚     3     â”‚
           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
           â”‚     8     â”‚
           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
           â”‚     1     â”‚ â† BAZÄ‚ (primul adÄƒugat, ultimul eliminat)
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
        </div>

        <!-- Slide 6: Stack Operations -->
        <div class="slide">
            <h1>âš™ï¸ OperaÈ›ii Fundamentale</h1>
            
            <table>
                <tr>
                    <th>OperaÈ›ie</th>
                    <th>Descriere</th>
                    <th>Complexitate</th>
                </tr>
                <tr>
                    <td><code>push(x)</code></td>
                    <td>AdaugÄƒ elementul x Ã®n vÃ¢rful stivei</td>
                    <td class="complexity-highlight">O(1)</td>
                </tr>
                <tr>
                    <td><code>pop()</code></td>
                    <td>EliminÄƒ È™i returneazÄƒ elementul din vÃ¢rf</td>
                    <td class="complexity-highlight">O(1)</td>
                </tr>
                <tr>
                    <td><code>peek() / top()</code></td>
                    <td>ReturneazÄƒ elementul din vÃ¢rf fÄƒrÄƒ a-l elimina</td>
                    <td class="complexity-highlight">O(1)</td>
                </tr>
                <tr>
                    <td><code>isEmpty()</code></td>
                    <td>VerificÄƒ dacÄƒ stiva este goalÄƒ</td>
                    <td class="complexity-highlight">O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>ReturneazÄƒ numÄƒrul de elemente</td>
                    <td class="complexity-highlight">O(1)</td>
                </tr>
            </table>
            
            <div class="info-box success">
                <div class="info-box-title">âœ… ObservaÈ›ie Cheie</div>
                Toate operaÈ›iile de bazÄƒ ale stivei sunt Ã®n timp constant O(1), fÄƒcÃ¢nd-o una dintre cele mai eficiente structuri de date.
            </div>
        </div>

        <!-- Slide 7: Push Operation Visualization -->
        <div class="slide">
            <h1>ğŸ“¥ OperaÈ›ia Push</h1>
            <h3>AdÄƒugarea unui element Ã®n vÃ¢rful stivei</h3>
            
            <div class="ascii-diagram">
ÃNAINTE de push(7):          DUPÄ‚ push(7):
                             
    â”Œâ”€â”€â”€â”                        â”Œâ”€â”€â”€â”
    â”‚ 5 â”‚ â† top                  â”‚ 7 â”‚ â† top (NOU!)
    â”œâ”€â”€â”€â”¤                        â”œâ”€â”€â”€â”¤
    â”‚ 3 â”‚                        â”‚ 5 â”‚
    â”œâ”€â”€â”€â”¤                        â”œâ”€â”€â”€â”¤
    â”‚ 1 â”‚                        â”‚ 3 â”‚
    â””â”€â”€â”€â”˜                        â”œâ”€â”€â”€â”¤
                                 â”‚ 1 â”‚
                                 â””â”€â”€â”€â”˜

PaÈ™i:
1. VerificÄƒ dacÄƒ stiva nu este plinÄƒ (stack overflow)
2. IncrementeazÄƒ indexul top
3. PlaseazÄƒ elementul la poziÈ›ia top
            </div>

            <div class="code-block">
                <div class="code-header">
                    <span>Implementare push pe vector</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">bool push(Stack *s, int value) {
    if (s->top >= MAX_SIZE - 1) {
        return false;  // Stack overflow
    }
    s->top++;
    s->data[s->top] = value;
    return true;
}</code></pre>
            </div>
        </div>

        <!-- Slide 8: Pop Operation Visualization -->
        <div class="slide">
            <h1>ğŸ“¤ OperaÈ›ia Pop</h1>
            <h3>Eliminarea È™i returnarea elementului din vÃ¢rf</h3>
            
            <div class="ascii-diagram">
ÃNAINTE de pop():            DUPÄ‚ pop():
                             ReturneazÄƒ: 7
    â”Œâ”€â”€â”€â”                        
    â”‚ 7 â”‚ â† top                  â”Œâ”€â”€â”€â”
    â”œâ”€â”€â”€â”¤                        â”‚ 5 â”‚ â† top (NOU!)
    â”‚ 5 â”‚                        â”œâ”€â”€â”€â”¤
    â”œâ”€â”€â”€â”¤                        â”‚ 3 â”‚
    â”‚ 3 â”‚                        â”œâ”€â”€â”€â”¤
    â”œâ”€â”€â”€â”¤                        â”‚ 1 â”‚
    â”‚ 1 â”‚                        â””â”€â”€â”€â”˜
    â””â”€â”€â”€â”˜                        

PaÈ™i:
1. VerificÄƒ dacÄƒ stiva nu este goalÄƒ (stack underflow)
2. SalveazÄƒ valoarea de la poziÈ›ia top
3. DecrementeazÄƒ indexul top
4. ReturneazÄƒ valoarea salvatÄƒ
            </div>

            <div class="code-block">
                <div class="code-header">
                    <span>Implementare pop pe vector</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">bool pop(Stack *s, int *value) {
    if (s->top < 0) {
        return false;  // Stack underflow
    }
    *value = s->data[s->top];
    s->top--;
    return true;
}</code></pre>
            </div>
        </div>

        <!-- Slide 9: Array-Based Implementation Structure -->
        <div class="slide">
            <h1>ğŸ”¢ Implementare pe Vector</h1>
            <h2>DefiniÈ›ia Structurii</h2>
            
            <div class="code-block">
                <div class="code-header">
                    <span>Structura stivei pe vector</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">#define MAX_SIZE 100

typedef struct {
    int data[MAX_SIZE];    // Vectorul de stocare
    int top;               // Indexul vÃ¢rfului (-1 = goalÄƒ)
} ArrayStack;

// IniÈ›ializare
void stack_init(ArrayStack *s) {
    s->top = -1;  // Stiva goalÄƒ
}

// Verificare stivÄƒ goalÄƒ
bool stack_is_empty(const ArrayStack *s) {
    return s->top == -1;
}

// Verificare stivÄƒ plinÄƒ
bool stack_is_full(const ArrayStack *s) {
    return s->top == MAX_SIZE - 1;
}</code></pre>
            </div>

            <div class="info-box note">
                <div class="info-box-title">ğŸ“ ConvenÈ›ie</div>
                Folosim <code>top = -1</code> pentru a indica stiva goalÄƒ. La primul push, top devine 0, indicÃ¢nd primul element.
            </div>
        </div>

        <!-- Slide 10: Array-Based Memory Layout -->
        <div class="slide">
            <h1>ğŸ§  Layout Ã®n Memorie - Vector</h1>
            
            <div class="ascii-diagram">
ArrayStack s;
stack_init(&s);
push(&s, 10); push(&s, 20); push(&s, 30);

AdresÄƒ      Index    Valoare    
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
0x1000      [0]      10         
0x1004      [1]      20         
0x1008      [2]      30  â† top = 2
0x100C      [3]      ?  (nedefinit)
0x1010      [4]      ?  
   ...       ...     ...
0x118C      [99]     ?          
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Structura ArrayStack:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ data[0..99]                              â”‚  400 bytes (100 Ã— 4)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ top = 2                                  â”‚  4 bytes
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Total: 404 bytes (dimensiune fixÄƒ)
            </div>

            <div class="info-box warning">
                <div class="info-box-title">âš ï¸ AtenÈ›ie</div>
                Vectorul static alocÄƒ memorie pentru toate cele 100 de elemente, chiar dacÄƒ stiva conÈ›ine doar 3.
            </div>
        </div>

        <!-- Slide 11: Complete Array Stack Implementation -->
        <div class="slide">
            <h1>ğŸ’» Implementare CompletÄƒ - Vector</h1>
            
            <div class="code-block">
                <div class="code-header">
                    <span>Toate operaÈ›iile pe stivÄƒ cu vector</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

#define MAX_SIZE 100

typedef struct {
    int data[MAX_SIZE];
    int top;
} ArrayStack;

void stack_init(ArrayStack *s)           { s->top = -1; }
bool stack_is_empty(const ArrayStack *s) { return s->top == -1; }
bool stack_is_full(const ArrayStack *s)  { return s->top == MAX_SIZE - 1; }
int  stack_size(const ArrayStack *s)     { return s->top + 1; }

bool push(ArrayStack *s, int value) {
    if (stack_is_full(s)) return false;
    s->data[++s->top] = value;
    return true;
}

bool pop(ArrayStack *s, int *value) {
    if (stack_is_empty(s)) return false;
    *value = s->data[s->top--];
    return true;
}

bool peek(const ArrayStack *s, int *value) {
    if (stack_is_empty(s)) return false;
    *value = s->data[s->top];
    return true;
}</code></pre>
            </div>
        </div>

        <!-- Slide 12: Linked List Implementation Structure -->
        <div class="slide">
            <h1>ğŸ”— Implementare pe ListÄƒ ÃnlÄƒnÈ›uitÄƒ</h1>
            <h2>DefiniÈ›ia Structurilor</h2>
            
            <div class="code-block">
                <div class="code-header">
                    <span>Structuri pentru stivÄƒ cu listÄƒ Ã®nlÄƒnÈ›uitÄƒ</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

typedef struct Node {
    int data;
    struct Node *next;
} Node;

typedef struct {
    Node *top;      // Pointer la vÃ¢rful stivei
    size_t size;    // NumÄƒr de elemente (opÈ›ional)
} LinkedStack;

// IniÈ›ializare
void stack_init(LinkedStack *s) {
    s->top = NULL;
    s->size = 0;
}

// Verificare stivÄƒ goalÄƒ
bool stack_is_empty(const LinkedStack *s) {
    return s->top == NULL;
}</code></pre>
            </div>

            <div class="info-box success">
                <div class="info-box-title">âœ… Avantaj</div>
                Nu existÄƒ limitÄƒ fixÄƒ pentru numÄƒrul de elemente - stiva creÈ™te dinamic.
            </div>
        </div>

        <!-- Slide 13: Linked List Memory Layout -->
        <div class="slide">
            <h1>ğŸ§  Layout Ã®n Memorie - ListÄƒ</h1>
            
            <div class="ascii-diagram">
LinkedStack s;
stack_init(&s);
push(&s, 10); push(&s, 20); push(&s, 30);

LinkedStack (pe stack)     Noduri (pe heap)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      
â”‚ top â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â–º  â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
â”‚ size = 3         â”‚      â”‚  30  â”‚ nextâ”€â”¼â”€â”€â”€â–º  â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜      â”‚  20  â”‚ nextâ”€â”¼â”€â”€â”€â–º  â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
                           (vÃ¢rf/TOP)          â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜      â”‚  10  â”‚ NULL â”‚
                                                                    â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
                                                                     (bazÄƒ)

Memorie utilizatÄƒ:
- LinkedStack: 16 bytes (pointer + size_t)
- Fiecare Node: 16 bytes (int + pointer + padding)
- Total pentru 3 elemente: 16 + 3Ã—16 = 64 bytes
            </div>

            <div class="info-box warning">
                <div class="info-box-title">âš ï¸ Overhead</div>
                Fiecare element necesitÄƒ memorie suplimentarÄƒ pentru pointer (8 bytes pe 64-bit).
            </div>
        </div>

        <!-- Slide 14: Linked Stack Push Operation -->
        <div class="slide">
            <h1>ğŸ“¥ Push pe ListÄƒ ÃnlÄƒnÈ›uitÄƒ</h1>
            
            <div class="ascii-diagram">
ÃNAINTE de push(40):                  DUPÄ‚ push(40):

LinkedStack                           LinkedStack
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ top â”€â”€â”€â”€â”¼â”€â”€â–º [30|â”€]â”€â–º[20|â”€]â”€â–º[10|âˆ…] â”‚ top â”€â”€â”€â”€â”¼â”€â”€â–º [40|â”€]â”€â–º[30|â”€]â”€â–º[20|â”€]â”€â–º[10|âˆ…]
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                               â†‘
                                         NOU nod creat
            </div>

            <div class="code-block">
                <div class="code-header">
                    <span>Implementare push pe listÄƒ</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">bool push(LinkedStack *s, int value) {
    // 1. AlocÄƒ memorie pentru noul nod
    Node *new_node = malloc(sizeof(Node));
    if (new_node == NULL) {
        return false;  // Alocare eÈ™uatÄƒ
    }
    
    // 2. IniÈ›ializeazÄƒ noul nod
    new_node->data = value;
    
    // 3. ConecteazÄƒ la vechiul vÃ¢rf
    new_node->next = s->top;
    
    // 4. ActualizeazÄƒ vÃ¢rful
    s->top = new_node;
    s->size++;
    
    return true;
}</code></pre>
            </div>
        </div>

        <!-- Slide 15: Linked Stack Pop Operation -->
        <div class="slide">
            <h1>ğŸ“¤ Pop pe ListÄƒ ÃnlÄƒnÈ›uitÄƒ</h1>
            
            <div class="ascii-diagram">
ÃNAINTE de pop():                     DUPÄ‚ pop():

LinkedStack                           LinkedStack      ReturneazÄƒ: 40
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ top â”€â”€â”€â”€â”¼â”€â”€â–º [40|â”€]â”€â–º[30|â”€]â”€â–º[20|âˆ…] â”‚ top â”€â”€â”€â”€â”¼â”€â”€â–º [30|â”€]â”€â–º[20|âˆ…]
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â””â”€â–º ELIBERAT cu free()
            </div>

            <div class="code-block">
                <div class="code-header">
                    <span>Implementare pop pe listÄƒ</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">bool pop(LinkedStack *s, int *value) {
    // 1. VerificÄƒ dacÄƒ stiva nu este goalÄƒ
    if (s->top == NULL) {
        return false;  // Stack underflow
    }
    
    // 2. SalveazÄƒ referinÈ›a la nodul de È™ters
    Node *temp = s->top;
    
    // 3. SalveazÄƒ valoarea
    *value = temp->data;
    
    // 4. MutÄƒ vÃ¢rful la urmÄƒtorul nod
    s->top = temp->next;
    s->size--;
    
    // 5. ElibereazÄƒ memoria
    free(temp);
    
    return true;
}</code></pre>
            </div>
        </div>

        <!-- Slide 16: Complete Linked Stack Implementation -->
        <div class="slide">
            <h1>ğŸ’» Implementare CompletÄƒ - ListÄƒ</h1>
            
            <div class="code-block">
                <div class="code-header">
                    <span>Toate operaÈ›iile + eliberare memorie</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">bool peek(const LinkedStack *s, int *value) {
    if (s->top == NULL) return false;
    *value = s->top->data;
    return true;
}

size_t stack_size(const LinkedStack *s) {
    return s->size;
}

// CRITIC: Eliberarea completÄƒ a memoriei
void stack_destroy(LinkedStack *s) {
    Node *current = s->top;
    while (current != NULL) {
        Node *temp = current;
        current = current->next;
        free(temp);
    }
    s->top = NULL;
    s->size = 0;
}

// AfiÈ™are (pentru debugging)
void stack_print(const LinkedStack *s) {
    printf("Stack [size=%zu]: TOP -> ", s->size);
    for (Node *n = s->top; n != NULL; n = n->next) {
        printf("%d -> ", n->data);
    }
    printf("NULL\n");
}</code></pre>
            </div>
        </div>

        <!-- Slide 17: Implementation Comparison -->
        <div class="slide">
            <h1>âš–ï¸ ComparaÈ›ie ImplementÄƒri</h1>
            
            <table>
                <tr>
                    <th>Criteriu</th>
                    <th>Vector Static</th>
                    <th>Vector Dinamic</th>
                    <th>ListÄƒ ÃnlÄƒnÈ›uitÄƒ</th>
                </tr>
                <tr>
                    <td>Complexitate push/pop</td>
                    <td class="complexity-highlight">O(1)</td>
                    <td>O(1) amortizat</td>
                    <td class="complexity-highlight">O(1)</td>
                </tr>
                <tr>
                    <td>Memorie utilizatÄƒ</td>
                    <td>FixÄƒ (risipÄƒ)</td>
                    <td>VariabilÄƒ</td>
                    <td>ExactÄƒ + overhead</td>
                </tr>
                <tr>
                    <td>Dimensiune maximÄƒ</td>
                    <td>FixÄƒ</td>
                    <td>LimitatÄƒ de RAM</td>
                    <td>LimitatÄƒ de RAM</td>
                </tr>
                <tr>
                    <td>Cache locality</td>
                    <td>ExcelentÄƒ</td>
                    <td>ExcelentÄƒ</td>
                    <td>SlabÄƒ</td>
                </tr>
                <tr>
                    <td>Implementare</td>
                    <td>SimplÄƒ</td>
                    <td>ModeratÄƒ</td>
                    <td>ModeratÄƒ</td>
                </tr>
            </table>

            <div class="info-box note">
                <div class="info-box-title">ğŸ’¡ Recomandare PracticÄƒ</div>
                Pentru majoritatea aplicaÈ›iilor, vectorul dinamic oferÄƒ cel mai bun compromis. Lista Ã®nlÄƒnÈ›uitÄƒ este preferatÄƒ cÃ¢nd dimensiunea variazÄƒ drastic sau cÃ¢nd integrezi cu alte structuri de tip listÄƒ.
            </div>
        </div>

        <!-- Slide 18: Application 1 - Bracket Matching -->
        <div class="slide">
            <h1>ğŸ”§ AplicaÈ›ie: Verificarea Parantezelor</h1>
            
            <p>Una dintre cele mai clasice aplicaÈ›ii ale stivei este verificarea parantezelor echilibrate.</p>
            
            <div class="two-columns">
                <div class="column">
                    <h3>âœ… Expresii Valide</h3>
                    <ul>
                        <li><code>{[()]}</code></li>
                        <li><code>((()))</code></li>
                        <li><code>[{()}]</code></li>
                        <li><code>a + (b * [c - d])</code></li>
                    </ul>
                </div>
                <div class="column">
                    <h3>âŒ Expresii Invalide</h3>
                    <ul>
                        <li><code>{[(])}</code> - ordine greÈ™itÄƒ</li>
                        <li><code>((()</code> - neÃ®nchise</li>
                        <li><code>]}</code> - fÄƒrÄƒ deschidere</li>
                        <li><code>([)]</code> - intercalare</li>
                    </ul>
                </div>
            </div>

            <div class="ascii-diagram">
Algoritm pentru "{[()]}":

Caracter    AcÈ›iune              Stiva
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   {        push('{')            [{]
   [        push('[')            [{, []
   (        push('(')            [{, [, (]
   )        pop, verificÄƒ '('    [{, []
   ]        pop, verificÄƒ '['    [{]
   }        pop, verificÄƒ '{'    []
   EOF      stiva goalÄƒ?         DA â†’ VALID
            </div>
        </div>

        <!-- Slide 19: Bracket Matching Code -->
        <div class="slide">
            <h1>ğŸ’» Cod: Verificarea Parantezelor</h1>
            
            <div class="code-block">
                <div class="code-header">
                    <span>Implementare verificator de paranteze</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">bool is_matching(char open, char close) {
    return (open == '(' && close == ')') ||
           (open == '[' && close == ']') ||
           (open == '{' && close == '}');
}

int check_brackets(const char *expr) {
    ArrayStack s;
    stack_init(&s);
    
    for (int i = 0; expr[i] != '\0'; i++) {
        char c = expr[i];
        
        if (c == '(' || c == '[' || c == '{') {
            push(&s, c);  // Deschidere â†’ push
        }
        else if (c == ')' || c == ']' || c == '}') {
            int top_char;
            if (!pop(&s, &top_char) || !is_matching(top_char, c)) {
                return i;  // Eroare la poziÈ›ia i
            }
        }
    }
    
    return stack_is_empty(&s) ? -1 : strlen(expr);
    // -1 = valid, altfel poziÈ›ia ultimei paranteze neÃ®nchise
}</code></pre>
            </div>
        </div>

        <!-- Slide 20: Application 2 - Expression Evaluation -->
        <div class="slide">
            <h1>ğŸ”§ AplicaÈ›ie: Evaluarea Expresiilor</h1>
            <h2>NotaÈ›ia PostfixÄƒ (RPN)</h2>
            
            <p><strong>Reverse Polish Notation</strong> eliminÄƒ necesitatea parantezelor È™i a precedenÈ›ei operatorilor.</p>
            
            <div class="two-columns">
                <div class="column">
                    <h3>Infix â†’ Postfix</h3>
                    <table>
                        <tr><th>Infix</th><th>Postfix</th></tr>
                        <tr><td>3 + 4</td><td>3 4 +</td></tr>
                        <tr><td>3 + 4 Ã— 5</td><td>3 4 5 Ã— +</td></tr>
                        <tr><td>(3 + 4) Ã— 5</td><td>3 4 + 5 Ã—</td></tr>
                        <tr><td>a + b Ã— c - d</td><td>a b c Ã— + d -</td></tr>
                    </table>
                </div>
                <div class="column">
                    <h3>Evaluare cu StivÄƒ</h3>
                    <p>Pentru <code>3 4 + 5 Ã—</code>:</p>
                    <ol>
                        <li>push(3) â†’ [3]</li>
                        <li>push(4) â†’ [3, 4]</li>
                        <li>+: pop, pop, push(7) â†’ [7]</li>
                        <li>push(5) â†’ [7, 5]</li>
                        <li>Ã—: pop, pop, push(35) â†’ [35]</li>
                    </ol>
                    <p><strong>Rezultat: 35</strong></p>
                </div>
            </div>
        </div>

        <!-- Slide 21: Postfix Evaluation Code -->
        <div class="slide">
            <h1>ğŸ’» Cod: Evaluarea Expresiilor Postfixe</h1>
            
            <div class="code-block">
                <div class="code-header">
                    <span>Evaluator de expresii RPN</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">int evaluate_postfix(const char *expr) {
    ArrayStack s;
    stack_init(&s);
    
    for (int i = 0; expr[i] != '\0'; i++) {
        char c = expr[i];
        
        if (isdigit(c)) {
            push(&s, c - '0');  // ConverteÈ™te char la int
        }
        else if (c == '+' || c == '-' || c == '*' || c == '/') {
            int b, a;  // b = al doilea operand, a = primul
            pop(&s, &b);
            pop(&s, &a);
            
            int result;
            switch (c) {
                case '+': result = a + b; break;
                case '-': result = a - b; break;
                case '*': result = a * b; break;
                case '/': result = a / b; break;
            }
            push(&s, result);
        }
    }
    
    int final_result;
    pop(&s, &final_result);
    return final_result;
}</code></pre>
            </div>
        </div>

        <!-- Slide 22: Shunting Yard Algorithm -->
        <div class="slide">
            <h1>ğŸ”§ Algoritmul Shunting Yard</h1>
            <h2>Conversie Infix â†’ Postfix</h2>
            
            <p>Algoritmul lui Dijkstra foloseÈ™te <strong>douÄƒ structuri</strong>: o coadÄƒ de ieÈ™ire È™i o stivÄƒ de operatori.</p>
            
            <div class="ascii-diagram">
Exemplu: "3 + 4 * 5"

Token   AcÈ›iune                      Stiva Op    IeÈ™ire
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  3     numÄƒr â†’ ieÈ™ire               []          [3]
  +     push(+)                      [+]         [3]
  4     numÄƒr â†’ ieÈ™ire               [+]         [3, 4]
  *     precedenÈ›Äƒ(*)>precedenÈ›Äƒ(+)  [+, *]      [3, 4]
        â†’ push(*)
  5     numÄƒr â†’ ieÈ™ire               [+, *]      [3, 4, 5]
 EOF    goleÈ™te stiva                []          [3, 4, 5, *, +]

Rezultat: "3 4 5 * +"
            </div>

            <div class="info-box note">
                <div class="info-box-title">ğŸ“ Regula de BazÄƒ</div>
                Operatorii cu precedenÈ›Äƒ mai mare sau egalÄƒ sunt scoÈ™i din stivÄƒ Ã®nainte de a adÄƒuga noul operator.
            </div>
        </div>

        <!-- Slide 23: Operator Precedence -->
        <div class="slide">
            <h1>ğŸ“Š PrecedenÈ›a È™i Asociativitatea</h1>
            
            <table>
                <tr>
                    <th>Operator</th>
                    <th>PrecedenÈ›Äƒ</th>
                    <th>Asociativitate</th>
                    <th>Exemplu</th>
                </tr>
                <tr>
                    <td><code>^</code> (putere)</td>
                    <td>3 (cea mai mare)</td>
                    <td>Dreapta</td>
                    <td>2^3^2 = 2^(3^2) = 512</td>
                </tr>
                <tr>
                    <td><code>*</code>, <code>/</code>, <code>%</code></td>
                    <td>2</td>
                    <td>StÃ¢nga</td>
                    <td>6/3*2 = (6/3)*2 = 4</td>
                </tr>
                <tr>
                    <td><code>+</code>, <code>-</code></td>
                    <td>1 (cea mai micÄƒ)</td>
                    <td>StÃ¢nga</td>
                    <td>5-3+2 = (5-3)+2 = 4</td>
                </tr>
            </table>

            <div class="code-block">
                <div class="code-header">
                    <span>FuncÈ›ii helper pentru precedenÈ›Äƒ</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">int precedence(char op) {
    switch (op) {
        case '+': case '-': return 1;
        case '*': case '/': return 2;
        case '^':           return 3;
        default:            return 0;
    }
}

bool is_left_associative(char op) {
    return op != '^';  // Doar ^ este asociativ la dreapta
}</code></pre>
            </div>
        </div>

        <!-- Slide 24: Call Stack -->
        <div class="slide">
            <h1>ğŸ“ Call Stack - Stiva de Apeluri</h1>
            
            <p>Fiecare program Ã®n execuÈ›ie foloseÈ™te un <strong>call stack</strong> gestionat de procesor.</p>
            
            <div class="two-columns">
                <div class="column">
                    <h3>Ce se salveazÄƒ pe stack?</h3>
                    <ul>
                        <li><strong>Return address</strong> - unde sÄƒ revinÄƒ</li>
                        <li><strong>Parametri</strong> - argumentele funcÈ›iei</li>
                        <li><strong>Variabile locale</strong></li>
                        <li><strong>Registre salvate</strong></li>
                    </ul>
                </div>
                <div class="column">
                    <div class="ascii-diagram" style="font-size: 0.85em;">
main() apeleazÄƒ func_a()
func_a() apeleazÄƒ func_b()

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ func_b() frame     â”‚ â† SP
â”‚  - variabile localeâ”‚
â”‚  - return addr     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ func_a() frame     â”‚
â”‚  - variabile localeâ”‚
â”‚  - return addr     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ main() frame       â”‚
â”‚  - variabile localeâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â† Stack Base
                    </div>
                </div>
            </div>

            <div class="info-box danger">
                <div class="info-box-title">ğŸš¨ Stack Overflow</div>
                Recursivitatea infinitÄƒ sau alocarea excesivÄƒ pe stack duce la <strong>stack overflow</strong> - programul se terminÄƒ abrupt.
            </div>
        </div>

        <!-- Slide 25: Recursion and Stack -->
        <div class="slide">
            <h1>ğŸ”„ Recursivitate È™i Stiva</h1>
            
            <div class="code-block">
                <div class="code-header">
                    <span>Factorial recursiv È™i evoluÈ›ia stack-ului</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">int factorial(int n) {
    if (n <= 1) return 1;           // Caz de bazÄƒ
    return n * factorial(n - 1);    // Apel recursiv
}

// Apel: factorial(4)</code></pre>
            </div>

            <div class="ascii-diagram">
EvoluÈ›ia call stack pentru factorial(4):

AdÃ¢ncime    Stack Frame           AcÈ›iune
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   1        factorial(4)          apel: return 4 * factorial(3)
   2        factorial(3)          apel: return 3 * factorial(2)
   3        factorial(2)          apel: return 2 * factorial(1)
   4        factorial(1)          caz de bazÄƒ: return 1
   3        factorial(2)          return 2 * 1 = 2
   2        factorial(3)          return 3 * 2 = 6
   1        factorial(4)          return 4 * 6 = 24

Rezultat final: 24
            </div>
        </div>

        <!-- Slide 26: Iterative vs Recursive -->
        <div class="slide">
            <h1>âš–ï¸ Recursiv vs. Iterativ cu StivÄƒ ExplicitÄƒ</h1>
            
            <div class="two-columns">
                <div class="column">
                    <h3>ğŸ”„ Versiune RecursivÄƒ</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>DFS recursiv</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">void dfs_recursiv(int v, 
                  bool visited[]) {
    visited[v] = true;
    process(v);
    
    for (int i = 0; i < adj_count[v]; i++) {
        int u = adj[v][i];
        if (!visited[u]) {
            dfs_recursiv(u, visited);
        }
    }
}</code></pre>
                    </div>
                    <p>âœ… Cod mai clar<br>âŒ Risc stack overflow</p>
                </div>
                <div class="column">
                    <h3>ğŸ“š Versiune IterativÄƒ</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>DFS iterativ</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">void dfs_iterativ(int start, 
                  bool visited[]) {
    ArrayStack s;
    stack_init(&s);
    push(&s, start);
    
    while (!stack_is_empty(&s)) {
        int v;
        pop(&s, &v);
        if (!visited[v]) {
            visited[v] = true;
            process(v);
            for (int i = adj_count[v]-1; 
                 i >= 0; i--) {
                push(&s, adj[v][i]);
            }
        }
    }
}</code></pre>
                    </div>
                    <p>âœ… Control asupra memoriei<br>âŒ Cod mai complex</p>
                </div>
            </div>
        </div>

        <!-- Slide 27: Common Mistakes -->
        <div class="slide">
            <h1>âš ï¸ GreÈ™eli Frecvente</h1>
            
            <div class="info-box danger">
                <div class="info-box-title">ğŸš¨ 1. Stack Underflow</div>
                <p>Ãncercarea de a face <code>pop()</code> pe o stivÄƒ goalÄƒ.</p>
                <pre><code class="language-c">// GREÈ˜IT - nu verificÄƒ dacÄƒ stiva e goalÄƒ
int value = s.data[s.top--];  // Comportament nedefinit!

// CORECT
if (!stack_is_empty(&s)) {
    pop(&s, &value);
}</code></pre>
            </div>

            <div class="info-box danger">
                <div class="info-box-title">ğŸš¨ 2. Memory Leak la Lista ÃnlÄƒnÈ›uitÄƒ</div>
                <p>Uitarea eliberÄƒrii memoriei cÃ¢nd se È™terge stiva.</p>
                <pre><code class="language-c">// GREÈ˜IT
s.top = NULL;  // Memoria nodurilor rÄƒmÃ¢ne alocatÄƒ!

// CORECT
stack_destroy(&s);  // ElibereazÄƒ toate nodurile</code></pre>
            </div>

            <div class="info-box danger">
                <div class="info-box-title">ğŸš¨ 3. Stack Overflow pe Vector</div>
                <p>Push fÄƒrÄƒ verificarea limitei.</p>
                <pre><code class="language-c">// GREÈ˜IT
s.data[++s.top] = value;  // Poate depÄƒÈ™i MAX_SIZE

// CORECT
if (!stack_is_full(&s)) { push(&s, value); }</code></pre>
            </div>
        </div>

        <!-- Slide 28: More Common Mistakes -->
        <div class="slide">
            <h1>âš ï¸ GreÈ™eli Frecvente (continuare)</h1>
            
            <div class="info-box warning">
                <div class="info-box-title">âš ï¸ 4. Confuzia Ã®ntre peek È™i pop</div>
                <pre><code class="language-c">// Citire fÄƒrÄƒ eliminare (peek)
int top_value = s.data[s.top];  // NU modificÄƒ top

// Citire cu eliminare (pop)
int popped = s.data[s.top--];   // ModificÄƒ top</code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">âš ï¸ 5. IniÈ›ializare incorectÄƒ a top</div>
                <pre><code class="language-c">// DacÄƒ iniÈ›ializÄƒm cu top = 0
push: s.data[s.top++] = val;  // Prima valoare la index 0
pop:  return s.data[--s.top]; // DecrementeazÄƒ ÃNAINTE

// DacÄƒ iniÈ›ializÄƒm cu top = -1 (RECOMANDAT)
push: s.data[++s.top] = val;  // IncrementeazÄƒ ÃNAINTE
pop:  return s.data[s.top--]; // DecrementeazÄƒ DUPÄ‚</code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">âš ï¸ 6. Pointer NULL Ã®n lista Ã®nlÄƒnÈ›uitÄƒ</div>
                <pre><code class="language-c">// GREÈ˜IT - acceseazÄƒ potenÈ›ial NULL
int val = s->top->data;

// CORECT
if (s->top != NULL) {
    int val = s->top->data;
}</code></pre>
            </div>
        </div>

        <!-- Slide 29: Debugging with GDB -->
        <div class="slide">
            <h1>ğŸ” Depanare cu GDB</h1>
            
            <div class="code-block">
                <div class="code-header">
                    <span>Comenzi GDB utile pentru stive</span>
                    <span class="lang-badge">Bash</span>
                </div>
                <pre><code class="language-bash"># Compilare cu simboluri de debug
gcc -g -Wall -o program program.c

# Pornire GDB
gdb ./program

# Comenzi Ã®n GDB:
(gdb) break push           # Breakpoint la funcÈ›ia push
(gdb) break stack.c:42     # Breakpoint la linia 42
(gdb) run                  # RuleazÄƒ programul
(gdb) next                 # UrmÄƒtoarea instrucÈ›iune
(gdb) step                 # IntrÄƒ Ã®n funcÈ›ie
(gdb) print s.top          # AfiÈ™eazÄƒ valoarea top
(gdb) print s.data[0]@5    # AfiÈ™eazÄƒ primele 5 elemente
(gdb) backtrace            # AfiÈ™eazÄƒ call stack-ul
(gdb) watch s.top          # OpreÈ™te cÃ¢nd se modificÄƒ top
(gdb) continue             # ContinuÄƒ execuÈ›ia</code></pre>
            </div>

            <div class="info-box note">
                <div class="info-box-title">ğŸ’¡ Sfat</div>
                FoloseÈ™te <code>backtrace</code> (sau <code>bt</code>) pentru a vedea Ã®ntregul call stack cÃ¢nd ai un crash.
            </div>
        </div>

        <!-- Slide 30: Memory Checking with Valgrind -->
        <div class="slide">
            <h1>ğŸ§ª Verificare Memorie cu Valgrind</h1>
            
            <div class="code-block">
                <div class="code-header">
                    <span>Detectarea memory leaks</span>
                    <span class="lang-badge">Bash</span>
                </div>
                <pre><code class="language-bash"># Rulare cu Valgrind
valgrind --leak-check=full ./program

# Output pentru memory leak:
==12345== HEAP SUMMARY:
==12345==     in use at exit: 48 bytes in 3 blocks
==12345==   total heap usage: 10 allocs, 7 frees
==12345== 
==12345== LEAK SUMMARY:
==12345==    definitely lost: 48 bytes in 3 blocks
==12345==    ...

# Program corect (fÄƒrÄƒ leaks):
==12345== All heap blocks were freed -- no leaks are possible</code></pre>
            </div>

            <div class="info-box success">
                <div class="info-box-title">âœ… Regula de Aur</div>
                Pentru fiecare <code>malloc()</code> trebuie sÄƒ existe un <code>free()</code> corespunzÄƒtor. La stive pe liste: apeleazÄƒ <code>stack_destroy()</code> la final!
            </div>
        </div>

        <!-- Slide 31: Best Practices -->
        <div class="slide">
            <h1>âœ¨ Bune Practici</h1>
            
            <div class="two-columns">
                <div class="column">
                    <h3>âœ… DO (FÄƒ aÈ™a)</h3>
                    <ul>
                        <li>VerificÄƒ mereu <code>isEmpty()</code> Ã®nainte de <code>pop()</code></li>
                        <li>VerificÄƒ <code>isFull()</code> Ã®nainte de <code>push()</code> (pt. vectori)</li>
                        <li>IniÈ›ializeazÄƒ explicit stiva</li>
                        <li>ElibereazÄƒ memoria la final (liste)</li>
                        <li>FoloseÈ™te <code>const</code> pentru funcÈ›ii care nu modificÄƒ stiva</li>
                        <li>ReturneazÄƒ status (bool) pentru operaÈ›ii</li>
                        <li>DocumenteazÄƒ comportamentul la erori</li>
                    </ul>
                </div>
                <div class="column">
                    <h3>âŒ DON'T (Nu fÄƒ aÈ™a)</h3>
                    <ul>
                        <li>Nu accesa direct <code>s.data[s.top]</code> fÄƒrÄƒ verificare</li>
                        <li>Nu uita sÄƒ incrementezi/decrementezi <code>top</code></li>
                        <li>Nu amesteca stiluri de iniÈ›ializare (0 vs -1)</li>
                        <li>Nu ignora valorile returnate</li>
                        <li>Nu folosii variabile globale pentru stive</li>
                        <li>Nu presupune dimensiunea stivei fÄƒrÄƒ verificare</li>
                    </ul>
                </div>
            </div>

            <div class="code-block">
                <div class="code-header">
                    <span>Exemplu de API bine proiectat</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">// ReturneazÄƒ bool pentru status + valoare prin pointer
bool pop(Stack *s, int *out_value);

// Folosire corectÄƒ:
int value;
if (pop(&s, &value)) {
    printf("Valoare: %d\n", value);
} else {
    printf("Eroare: stiva goalÄƒ!\n");
}</code></pre>
            </div>
        </div>

        <!-- Slide 32: Generic Stack with void* -->
        <div class="slide">
            <h1>ğŸ­ StivÄƒ GenericÄƒ cu void*</h1>
            
            <p>Pentru a stoca orice tip de date, folosim pointeri generici.</p>
            
            <div class="code-block">
                <div class="code-header">
                    <span>Implementare stivÄƒ genericÄƒ</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">typedef struct {
    void **data;        // Vector de pointeri generici
    int top;
    int capacity;
    size_t elem_size;   // Dimensiunea unui element
} GenericStack;

bool push_generic(GenericStack *s, const void *element) {
    if (s->top >= s->capacity - 1) return false;
    
    // AlocÄƒ È™i copiazÄƒ elementul
    s->data[++s->top] = malloc(s->elem_size);
    memcpy(s->data[s->top], element, s->elem_size);
    return true;
}

// Utilizare:
GenericStack s = {.capacity = 100, .elem_size = sizeof(double)};
double val = 3.14;
push_generic(&s, &val);</code></pre>
            </div>

            <div class="info-box note">
                <div class="info-box-title">ğŸ“ AlternativÄƒ ModernÄƒ</div>
                Ãn C11 se pot folosi macro-uri cu <code>_Generic</code> pentru type-safety, sau Ã®n C++ template-uri.
            </div>
        </div>

        <!-- Slide 33: Stack with Min in O(1) -->
        <div class="slide">
            <h1>ğŸ¯ ProblemÄƒ de Interviu: getMin() Ã®n O(1)</h1>
            
            <p><strong>CerinÈ›Äƒ:</strong> ImplementeazÄƒ o stivÄƒ care suportÄƒ <code>getMin()</code> Ã®n timp constant.</p>
            
            <div class="code-block">
                <div class="code-header">
                    <span>SoluÈ›ie cu stivÄƒ auxiliarÄƒ de minime</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">typedef struct {
    ArrayStack main_stack;   // Stiva principalÄƒ
    ArrayStack min_stack;    // Stiva minimelor
} MinStack;

void minstack_push(MinStack *ms, int value) {
    push(&ms->main_stack, value);
    
    // DacÄƒ e primul element sau valoare <= minimul curent
    int current_min;
    if (stack_is_empty(&ms->min_stack) || 
        (peek(&ms->min_stack, &current_min) && value <= current_min)) {
        push(&ms->min_stack, value);
    }
}

int minstack_pop(MinStack *ms) {
    int value, current_min;
    pop(&ms->main_stack, &value);
    
    // DacÄƒ am scos minimul curent, Ã®l eliminÄƒm È™i din stiva min
    if (peek(&ms->min_stack, &current_min) && value == current_min) {
        pop(&ms->min_stack, &current_min);
    }
    return value;
}

int minstack_get_min(MinStack *ms) {
    int min;
    peek(&ms->min_stack, &min);  // O(1)!
    return min;
}</code></pre>
            </div>
        </div>

        <!-- Slide 34: Laboratory Preview -->
        <div class="slide">
            <h1>ğŸ”¬ Previzualizare Laborator</h1>
            
            <div class="two-columns">
                <div class="column">
                    <h3>ğŸ“ ExerciÈ›iul 1: Verificator Paranteze</h3>
                    <p>ImplementeazÄƒ un verificator complet pentru expresii cu paranteze.</p>
                    <ul>
                        <li>SuportÄƒ <code>()</code>, <code>[]</code>, <code>{}</code></li>
                        <li>ReturneazÄƒ poziÈ›ia primei erori</li>
                        <li>GestioneazÄƒ cazuri limitÄƒ</li>
                        <li>8-10 TODO markers</li>
                    </ul>
                    <p><strong>Complexitate aÈ™teptatÄƒ:</strong> O(n)</p>
                </div>
                <div class="column">
                    <h3>ğŸ“ ExerciÈ›iul 2: Convertor Infixâ†’Postfix</h3>
                    <p>ImplementeazÄƒ algoritmul Shunting Yard.</p>
                    <ul>
                        <li>Operatori: <code>+ - * / ^</code></li>
                        <li>RespectÄƒ precedenÈ›a È™i asociativitatea</li>
                        <li>SuportÄƒ paranteze</li>
                        <li>10-15 TODO markers</li>
                    </ul>
                    <p><strong>Complexitate aÈ™teptatÄƒ:</strong> O(n)</p>
                </div>
            </div>

            <div class="info-box success">
                <div class="info-box-title">âœ… DupÄƒ Laborator</div>
                Vei putea implementa orice algoritm bazat pe stive È™i vei Ã®nÈ›elege Ã®n profunzime cum funcÈ›ioneazÄƒ call stack-ul programelor tale.
            </div>
        </div>

        <!-- Slide 35: Key Takeaways -->
        <div class="slide">
            <h1>ğŸ“Œ Puncte Cheie</h1>
            
            <div class="takeaways-grid">
                <div class="takeaway-card">
                    <div class="icon">ğŸ“š</div>
                    <h4>LIFO</h4>
                    <p>Last In, First Out - ultimul intrat este primul ieÈ™it</p>
                </div>
                <div class="takeaway-card">
                    <div class="icon">âš¡</div>
                    <h4>O(1)</h4>
                    <p>Toate operaÈ›iile de bazÄƒ Ã®n timp constant</p>
                </div>
                <div class="takeaway-card">
                    <div class="icon">ğŸ”¢</div>
                    <h4>Vector</h4>
                    <p>Cache-friendly, dar dimensiune limitatÄƒ</p>
                </div>
                <div class="takeaway-card">
                    <div class="icon">ğŸ”—</div>
                    <h4>ListÄƒ</h4>
                    <p>Dimensiune dinamicÄƒ, dar overhead memorie</p>
                </div>
                <div class="takeaway-card">
                    <div class="icon">ğŸ“</div>
                    <h4>Call Stack</h4>
                    <p>Fundament pentru apeluri de funcÈ›ii È™i recursivitate</p>
                </div>
                <div class="takeaway-card">
                    <div class="icon">ğŸ”§</div>
                    <h4>AplicaÈ›ii</h4>
                    <p>Paranteze, expresii, undo/redo, DFS, parsare</p>
                </div>
            </div>
        </div>

        <!-- Slide 36: Resources -->
        <div class="slide">
            <h1>ğŸ“– Resurse È™i LecturÄƒ SuplimentarÄƒ</h1>
            
            <div class="two-columns">
                <div class="column">
                    <h3>ğŸ“š CÄƒrÈ›i</h3>
                    <ul>
                        <li><strong>CLRS</strong> - Introduction to Algorithms, Cap. 10.1</li>
                        <li><strong>Sedgewick</strong> - Algorithms in C, Cap. 4</li>
                        <li><strong>Knuth</strong> - TAOCP Vol. 1, Sec. 2.2.1</li>
                    </ul>
                    
                    <h3>ğŸŒ Online</h3>
                    <ul>
                        <li><a href="https://visualgo.net/en/list" style="color: var(--accent-blue);">Visualgo - AnimaÈ›ii</a></li>
                        <li><a href="https://www.geeksforgeeks.org/stack-data-structure/" style="color: var(--accent-blue);">GeeksforGeeks</a></li>
                        <li><a href="https://cp-algorithms.com/" style="color: var(--accent-blue);">CP-Algorithms</a></li>
                    </ul>
                </div>
                <div class="column">
                    <h3>ğŸ¥ Video</h3>
                    <ul>
                        <li>MIT OCW 6.006 - Lecture on Stacks</li>
                        <li>Computerphile - Stack Data Structure</li>
                    </ul>
                    
                    <h3>ğŸ’» PracticÄƒ</h3>
                    <ul>
                        <li>LeetCode: Valid Parentheses (#20)</li>
                        <li>LeetCode: Min Stack (#155)</li>
                        <li>LeetCode: Evaluate RPN (#150)</li>
                        <li>LeetCode: Daily Temperatures (#739)</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 37: Questions & Next Week -->
        <div class="slide title-slide">
            <h1>â“ ÃntrebÄƒri?</h1>
            <p class="subtitle">MulÈ›umesc pentru atenÈ›ie!</p>
            
            <div style="margin-top: 60px; padding: 30px; background: var(--bg-secondary); border-radius: 12px; border: 1px solid var(--border-color);">
                <h3 style="color: var(--accent-green); margin-bottom: 15px;">ğŸ”® SÄƒptÄƒmÃ¢na Viitoare</h3>
                <p style="font-size: 1.3em; color: var(--text-primary);">
                    <strong>SÄƒptÄƒmÃ¢na 6: Cozi (Queue)</strong>
                </p>
                <p>FIFO, circular buffer, deque, priority queue È™i aplicaÈ›ii (BFS, scheduling)</p>
            </div>
            
            <p class="meta" style="margin-top: 40px;">
                Algoritmi È™i Tehnici de Programare<br>
                Universitatea de È˜tiinÈ›e Economice din BucureÈ™ti
            </p>
        </div>

    </div>

    <script>
        // Initialize highlight.js
        hljs.highlightAll();

        // Slide navigation
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        const totalSlides = slides.length;

        document.getElementById('totalSlides').textContent = totalSlides;

        function showSlide(index) {
            if (index < 0) index = 0;
            if (index >= totalSlides) index = totalSlides - 1;
            
            slides.forEach((slide, i) => {
                slide.classList.remove('active');
                if (i === index) {
                    slide.classList.add('active');
                }
            });
            
            currentSlide = index;
            document.getElementById('currentSlide').textContent = currentSlide + 1;
            
            // Update progress bar
            const progress = ((currentSlide + 1) / totalSlides) * 100;
            document.getElementById('progressBar').style.width = progress + '%';
        }

        function nextSlide() {
            showSlide(currentSlide + 1);
        }

        function prevSlide() {
            showSlide(currentSlide - 1);
        }

        function goToSlide(index) {
            showSlide(index);
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowRight':
                case ' ':
                    e.preventDefault();
                    nextSlide();
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    prevSlide();
                    break;
                case 'Home':
                    e.preventDefault();
                    goToSlide(0);
                    break;
                case 'End':
                    e.preventDefault();
                    goToSlide(totalSlides - 1);
                    break;
            }
        });

        // Touch support for mobile
        let touchStartX = 0;
        let touchEndX = 0;

        document.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
        });

        document.addEventListener('touchend', (e) => {
            touchEndX = e.changedTouches[0].screenX;
            handleSwipe();
        });

        function handleSwipe() {
            const swipeThreshold = 50;
            const diff = touchStartX - touchEndX;
            
            if (Math.abs(diff) > swipeThreshold) {
                if (diff > 0) {
                    nextSlide();
                } else {
                    prevSlide();
                }
            }
        }

        // Initialize
        showSlide(0);
    </script>
</body>
</html>
