<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SÄƒptÄƒmÃ¢na 16: Paradigme Algoritmice - Greedy È™i Backtracking | ATP - ASE BucureÈ™ti</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-yellow: #d29922;
            --accent-red: #f85149;
            --accent-purple: #a371f7;
            --accent-orange: #f0883e;
            --border-color: #30363d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow: hidden;
        }

        /* Progress Bar */
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-green), var(--accent-purple));
            transition: width 0.3s ease;
            z-index: 1000;
        }

        /* Slide Container */
        .slides-container {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 60px 80px;
            display: none;
            opacity: 0;
            transition: opacity 0.4s ease;
            overflow-y: auto;
        }

        .slide.active {
            display: block;
            opacity: 1;
        }

        /* Typography */
        h1 {
            font-size: 2.8em;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--accent-blue);
        }

        h2 {
            font-size: 2.2em;
            font-weight: 600;
            margin-bottom: 25px;
            color: var(--text-primary);
            border-bottom: 2px solid var(--accent-blue);
            padding-bottom: 10px;
        }

        h3 {
            font-size: 1.6em;
            font-weight: 500;
            margin: 20px 0 15px 0;
            color: var(--accent-green);
        }

        p {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: var(--text-secondary);
        }

        ul, ol {
            margin: 15px 0 15px 30px;
            font-size: 1.15em;
        }

        li {
            margin-bottom: 12px;
            color: var(--text-secondary);
        }

        li strong {
            color: var(--text-primary);
        }

        /* Title Slide */
        .title-slide {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
        }

        .title-slide h1 {
            font-size: 3.5em;
            margin-bottom: 10px;
        }

        .title-slide .subtitle {
            font-size: 1.8em;
            color: var(--accent-purple);
            margin-bottom: 30px;
        }

        .title-slide .course-info {
            font-size: 1.2em;
            color: var(--text-secondary);
        }

        .title-slide .week-badge {
            background: linear-gradient(135deg, var(--accent-green), var(--accent-blue));
            color: var(--bg-primary);
            padding: 8px 25px;
            border-radius: 25px;
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 30px;
        }

        /* Code Blocks */
        pre {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            margin: 20px 0;
        }

        code {
            font-family: 'Cascadia Code', 'Fira Code', Consolas, monospace;
            font-size: 0.95em;
        }

        .inline-code {
            background: var(--bg-tertiary);
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
            color: var(--accent-yellow);
        }

        /* Grid Layout for Two Columns */
        .two-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            margin-top: 20px;
        }

        .column {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 25px;
        }

        .column h3 {
            margin-top: 0;
        }

        /* Info Boxes */
        .info-box {
            background: var(--bg-secondary);
            border-left: 4px solid var(--accent-blue);
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .warning-box {
            background: rgba(208, 153, 34, 0.1);
            border-left: 4px solid var(--accent-yellow);
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .success-box {
            background: rgba(63, 185, 80, 0.1);
            border-left: 4px solid var(--accent-green);
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .danger-box {
            background: rgba(248, 81, 73, 0.1);
            border-left: 4px solid var(--accent-red);
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        /* Objectives List */
        .objectives-list {
            list-style: none;
            margin: 0;
        }

        .objectives-list li {
            display: flex;
            align-items: flex-start;
            margin-bottom: 20px;
            background: var(--bg-secondary);
            padding: 15px 20px;
            border-radius: 10px;
            border-left: 4px solid var(--accent-green);
        }

        .obj-icon {
            font-size: 1.5em;
            margin-right: 15px;
            min-width: 40px;
            text-align: center;
        }

        /* Diagram Container */
        .diagram {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 25px;
            margin: 20px 0;
            font-family: 'Cascadia Code', monospace;
            white-space: pre;
            overflow-x: auto;
            font-size: 0.9em;
            line-height: 1.4;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: var(--bg-secondary);
            border-radius: 10px;
            overflow: hidden;
        }

        th, td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        th {
            background: var(--bg-tertiary);
            color: var(--accent-blue);
            font-weight: 600;
        }

        tr:hover {
            background: var(--bg-tertiary);
        }

        /* Complexity Badge */
        .complexity {
            display: inline-block;
            background: var(--accent-purple);
            color: white;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.9em;
            font-weight: 500;
        }

        /* Algorithm Step */
        .step {
            display: flex;
            align-items: flex-start;
            margin: 15px 0;
            padding: 15px;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        .step-number {
            background: var(--accent-blue);
            color: var(--bg-primary);
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
            flex-shrink: 0;
        }

        /* Navigation */
        .nav-container {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 100;
        }

        .nav-btn {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 12px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .nav-btn:hover:not(:disabled) {
            background: var(--accent-blue);
            color: var(--bg-primary);
            border-color: var(--accent-blue);
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Slide Counter */
        .slide-counter {
            position: fixed;
            bottom: 30px;
            right: 40px;
            background: var(--bg-secondary);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            z-index: 100;
        }

        /* Keyboard Hints */
        .keyboard-hints {
            position: fixed;
            bottom: 30px;
            left: 40px;
            font-size: 0.85em;
            color: var(--text-secondary);
            z-index: 100;
        }

        kbd {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 2px 8px;
            font-family: monospace;
        }

        /* Highlight animation */
        .highlight {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Comparison cards */
        .comparison-card {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 20px;
            margin: 10px 0;
        }

        .comparison-card.greedy {
            border-left: 4px solid var(--accent-green);
        }

        .comparison-card.backtracking {
            border-left: 4px solid var(--accent-purple);
        }

        .comparison-card.dp {
            border-left: 4px solid var(--accent-orange);
        }

        /* Tree visualization */
        .tree-node {
            display: inline-block;
            background: var(--accent-blue);
            color: var(--bg-primary);
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            margin: 5px;
        }
    </style>
</head>
<body>
    <div class="progress-bar" id="progressBar"></div>
    
    <div class="slide-counter" id="slideCounter">1 / 25</div>
    
    <div class="slides-container" id="slidesContainer">
        
        <!-- Slide 1: Title -->
        <div class="slide title-slide active">
            <div class="week-badge">SÄ‚PTÄ‚MÃ‚NA 16</div>
            <h1>Paradigme Algoritmice</h1>
            <p class="subtitle">Greedy È™i Backtracking</p>
            <p class="course-info">
                Algoritmi È™i Tehnici de Programare<br>
                Academia de Studii Economice BucureÈ™ti - CSIE<br>
                <span style="color: var(--accent-yellow);">Anul Universitar 2024-2025</span>
            </p>
        </div>

        <!-- Slide 2: Learning Objectives -->
        <div class="slide">
            <h2>ğŸ¯ Obiective de ÃnvÄƒÈ›are</h2>
            <ul class="objectives-list">
                <li>
                    <span class="obj-icon">ğŸ”</span>
                    <div>
                        <strong>RecunoaÈ™teÈ›i</strong> caracteristicile problemelor rezolvabile cu Greedy vs. Backtracking
                    </div>
                </li>
                <li>
                    <span class="obj-icon">ğŸ§ </span>
                    <div>
                        <strong>ÃnÈ›elegeÈ›i</strong> de ce Greedy nu garanteazÄƒ mereu soluÈ›ia optimÄƒ È™i cÃ¢nd funcÈ›ioneazÄƒ
                    </div>
                </li>
                <li>
                    <span class="obj-icon">âš™ï¸</span>
                    <div>
                        <strong>AplicaÈ›i</strong> Activity Selection, Fractional Knapsack, N-Queens, Sudoku Solver
                    </div>
                </li>
                <li>
                    <span class="obj-icon">ğŸ“Š</span>
                    <div>
                        <strong>AnalizaÈ›i</strong> complexitatea timp/spaÈ›iu È™i efectul pruning-ului Ã®n backtracking
                    </div>
                </li>
                <li>
                    <span class="obj-icon">âš–ï¸</span>
                    <div>
                        <strong>EvaluaÈ›i</strong> care paradigmÄƒ e potrivitÄƒ pentru o problemÄƒ nouÄƒ
                    </div>
                </li>
                <li>
                    <span class="obj-icon">ğŸ› ï¸</span>
                    <div>
                        <strong>CreaÈ›i</strong> soluÈ›ii pentru probleme combinatoriale complexe
                    </div>
                </li>
            </ul>
        </div>

        <!-- Slide 3: Historical Context -->
        <div class="slide">
            <h2>ğŸ“œ Context Istoric</h2>
            <div class="two-columns">
                <div class="column">
                    <h3 style="color: var(--accent-green);">George Dantzig (1914-2005)</h3>
                    <p><em>PÄƒrintele ProgramÄƒrii Liniare</em></p>
                    <ul>
                        <li>A dezvoltat <strong>Metoda Simplex</strong> (1947)</li>
                        <li>Ideile sale au inspirat algoritmii Greedy</li>
                        <li>Celebru pentru cÄƒ a rezolvat douÄƒ probleme "imposibile" crezÃ¢nd cÄƒ sunt teme</li>
                    </ul>
                    <div class="info-box">
                        <em>"The world is more complicated than any of us can figure out by ourselves, so we have to use algorithms to help us."</em>
                    </div>
                </div>
                <div class="column">
                    <h3 style="color: var(--accent-purple);">Robert W. Floyd (1936-2001)</h3>
                    <p><em>Premiul Turing 1978</em></p>
                    <ul>
                        <li>A formalizat tehnica <strong>Backtracking</strong></li>
                        <li>Algoritmi: Floyd-Warshall, verificare heap</li>
                        <li>ContribuÈ›ii majore la analiza algoritmilor</li>
                    </ul>
                    <div class="info-box">
                        <em>"The amount of intelligence used to study an algorithm should be proportional to its importance."</em>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 4: Greedy Introduction -->
        <div class="slide">
            <h2>ğŸ’š Paradigma Greedy - Introducere</h2>
            <div class="info-box">
                <h3>Principiul Alegerii Locale Optime</h3>
                <p>La fiecare pas, algoritmul face alegerea care pare cea mai bunÄƒ <strong>Ã®n acel moment</strong>, fÄƒrÄƒ a se uita Ã®n viitor sau a reconsidera deciziile anterioare.</p>
            </div>
            
            <div class="diagram">
   ProblemÄƒ
      â”‚
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Alegere LocalÄƒ  â”‚ â—„â”€â”€ SelecteazÄƒ cea mai bunÄƒ opÈ›iune disponibilÄƒ
â”‚    OptimÄƒ       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
   SubproblemÄƒ     â—„â”€â”€ Problema se reduce
      â”‚
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Alegere LocalÄƒ  â”‚ â—„â”€â”€ RepetÄƒ procesul
â”‚    OptimÄƒ       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
    SoluÈ›ie        â—„â”€â”€ ConstruitÄƒ incremental
            </div>
            
            <div class="warning-box">
                <strong>âš ï¸ AtenÈ›ie:</strong> Greedy nu garanteazÄƒ ÃNTOTDEAUNA soluÈ›ia optimÄƒ globalÄƒ!
            </div>
        </div>

        <!-- Slide 5: When Greedy Works -->
        <div class="slide">
            <h2>âœ… CÃ¢nd FuncÈ›ioneazÄƒ Greedy?</h2>
            
            <p>Pentru ca Greedy sÄƒ garanteze soluÈ›ia optimÄƒ, problema trebuie sÄƒ aibÄƒ:</p>
            
            <div class="two-columns">
                <div class="column comparison-card greedy">
                    <h3>1. Proprietatea Alegerii Greedy</h3>
                    <p>O soluÈ›ie globalÄƒ optimÄƒ poate fi construitÄƒ fÄƒcÃ¢nd alegeri locale optime.</p>
                    <p><strong>DemonstrÄƒm:</strong> alegerea greedy este parte dintr-o soluÈ›ie optimÄƒ.</p>
                </div>
                <div class="column comparison-card greedy">
                    <h3>2. Substructura OptimalÄƒ</h3>
                    <p>SoluÈ›ia optimÄƒ a problemei conÈ›ine soluÈ›ii optime ale subproblemelor.</p>
                    <p><strong>VerificÄƒm:</strong> dupÄƒ o alegere, problema se reduce la o subproblemÄƒ similarÄƒ.</p>
                </div>
            </div>
            
            <div class="danger-box" style="margin-top: 30px;">
                <h3>âŒ Contraexemplu: Coin Change</h3>
                <p>Monede: {1, 3, 4}, ÈšintÄƒ: 6</p>
                <p>Greedy: 4 + 1 + 1 = <strong>3 monede</strong></p>
                <p>Optimal: 3 + 3 = <strong>2 monede</strong> âœ“</p>
            </div>
        </div>

        <!-- Slide 6: Activity Selection Problem -->
        <div class="slide">
            <h2>ğŸ“… Activity Selection Problem</h2>
            
            <p>Dat: set de activitÄƒÈ›i cu timp de start È™i sfÃ¢rÈ™it. GÄƒseÈ™te numÄƒrul maxim de activitÄƒÈ›i care nu se suprapun.</p>
            
            <div class="diagram">
ActivitÄƒÈ›i:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Activitate â”‚ Start â”‚ SfÃ¢rÈ™it â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     A1     â”‚   1   â”‚    4    â”‚
â”‚     A2     â”‚   3   â”‚    5    â”‚
â”‚     A3     â”‚   0   â”‚    6    â”‚
â”‚     A4     â”‚   5   â”‚    7    â”‚
â”‚     A5     â”‚   3   â”‚    9    â”‚
â”‚     A6     â”‚   5   â”‚    9    â”‚
â”‚     A7     â”‚   6   â”‚   10    â”‚
â”‚     A8     â”‚   8   â”‚   11    â”‚
â”‚     A9     â”‚   8   â”‚   12    â”‚
â”‚    A10     â”‚  12   â”‚   14    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Timeline:
0   1   2   3   4   5   6   7   8   9  10  11  12  13  14
â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ A3
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ A1 âœ“
        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ A2
                    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ A4 âœ“
                                    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ A8 âœ“
                                                â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ A10 âœ“

SoluÈ›ie Greedy: {A1, A4, A8, A10} = 4 activitÄƒÈ›i
            </div>
        </div>

        <!-- Slide 7: Activity Selection Algorithm -->
        <div class="slide">
            <h2>ğŸ“… Activity Selection - Algoritm</h2>
            
            <div class="step">
                <div class="step-number">1</div>
                <div>
                    <strong>SorteazÄƒ</strong> activitÄƒÈ›ile dupÄƒ timpul de <em>sfÃ¢rÈ™it</em> (crescÄƒtor)
                </div>
            </div>
            
            <div class="step">
                <div class="step-number">2</div>
                <div>
                    <strong>SelecteazÄƒ</strong> prima activitate (cea care se terminÄƒ cel mai devreme)
                </div>
            </div>
            
            <div class="step">
                <div class="step-number">3</div>
                <div>
                    <strong>RepetÄƒ:</strong> selecteazÄƒ urmÄƒtoarea activitate care Ã®ncepe dupÄƒ ce se terminÄƒ ultima selectatÄƒ
                </div>
            </div>
            
            <pre><code class="language-c">int activity_selection(Activity *activities, int n, int *selected) {
    // Sortare dupÄƒ timpul de sfÃ¢rÈ™it
    qsort(activities, n, sizeof(Activity), compare_by_finish);
    
    int count = 0;
    int last_finish = 0;
    
    for (int i = 0; i < n; i++) {
        if (activities[i].start >= last_finish) {
            selected[count++] = i;
            last_finish = activities[i].finish;
        }
    }
    
    return count;
}</code></pre>
            
            <p><span class="complexity">Complexitate: O(n log n)</span> - dominatÄƒ de sortare</p>
        </div>

        <!-- Slide 8: Fractional Knapsack -->
        <div class="slide">
            <h2>ğŸ’ Fractional Knapsack</h2>
            
            <p>Dat: obiecte cu greutate È™i valoare, capacitate rucsac W. MaximizeazÄƒ valoarea (putem lua fracÈ›iuni).</p>
            
            <div class="two-columns">
                <div class="column">
                    <h3>Strategie Greedy</h3>
                    <ol>
                        <li>CalculeazÄƒ raportul <strong>value/weight</strong> pentru fiecare obiect</li>
                        <li>SorteazÄƒ descrescÄƒtor dupÄƒ raport</li>
                        <li>Ia obiecte Ã®n ordine pÃ¢nÄƒ la capacitate</li>
                        <li>DacÄƒ ultimul nu Ã®ncape, ia fracÈ›iune</li>
                    </ol>
                </div>
                <div class="column">
                    <h3>Exemplu</h3>
                    <div class="diagram" style="font-size: 0.85em;">
Capacitate: 10 kg

Obiect â”‚ Greutate â”‚ Valoare â”‚ Ratio
â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€
  A    â”‚    4     â”‚   120   â”‚  30 âœ“
  B    â”‚    3     â”‚    60   â”‚  20 âœ“
  C    â”‚    5     â”‚   100   â”‚  20 âœ“

SoluÈ›ie:
A: complet (4kg, 120 lei)
B: complet (3kg,  60 lei)
C: 60% (3kg,  60 lei)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total: 10kg, 240 lei
                    </div>
                </div>
            </div>
            
            <div class="success-box">
                <strong>âœ“ De ce funcÈ›ioneazÄƒ:</strong> LuÃ¢nd obiectele cu cel mai mare raport value/weight, maximizÄƒm valoarea per unitate de greutate.
            </div>
        </div>

        <!-- Slide 9: Fractional Knapsack Code -->
        <div class="slide">
            <h2>ğŸ’ Fractional Knapsack - Implementare</h2>
            
            <pre><code class="language-c">typedef struct {
    int id;
    double weight;
    double value;
    double ratio;
} Item;

int compare_by_ratio(const void *a, const void *b) {
    double diff = ((Item*)b)->ratio - ((Item*)a)->ratio;
    return (diff > 0) - (diff < 0);
}

double fractional_knapsack(Item *items, int n, double capacity) {
    // CalculeazÄƒ rapoartele
    for (int i = 0; i < n; i++) {
        items[i].ratio = items[i].value / items[i].weight;
    }
    
    // SorteazÄƒ descrescÄƒtor dupÄƒ raport
    qsort(items, n, sizeof(Item), compare_by_ratio);
    
    double total_value = 0;
    double remaining = capacity;
    
    for (int i = 0; i < n && remaining > 0; i++) {
        if (items[i].weight <= remaining) {
            // LuÄƒm obiectul complet
            total_value += items[i].value;
            remaining -= items[i].weight;
        } else {
            // LuÄƒm doar o fracÈ›iune
            double fraction = remaining / items[i].weight;
            total_value += items[i].value * fraction;
            remaining = 0;
        }
    }
    
    return total_value;
}</code></pre>
        </div>

        <!-- Slide 10: Backtracking Introduction -->
        <div class="slide">
            <h2>ğŸ”® Paradigma Backtracking - Introducere</h2>
            
            <div class="info-box">
                <h3>Explorarea SistematicÄƒ a SpaÈ›iului SoluÈ›iilor</h3>
                <p>Backtracking construieÈ™te soluÈ›ia <strong>incremental</strong>, abandonÃ¢nd cÄƒile care nu pot duce la soluÈ›ie validÄƒ (<strong>pruning</strong>).</p>
            </div>
            
            <div class="diagram">
Arborele SpaÈ›iului de SoluÈ›ii:

                        â”Œâ”€â”€â”€â”€â”€â”
                        â”‚STARTâ”‚
                        â””â”€â”€â”¬â”€â”€â”˜
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â–¼              â–¼              â–¼
         â”Œâ”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”
         â”‚Alegeâ”‚       â”‚Alegeâ”‚        â”‚Alegeâ”‚
         â”‚  A  â”‚       â”‚  B  â”‚        â”‚  C  â”‚
         â””â”€â”€â”¬â”€â”€â”˜       â””â”€â”€â”¬â”€â”€â”˜        â””â”€â”€â”¬â”€â”€â”˜
      â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”       â”‚              âœ—
      â–¼           â–¼       â”‚          (pruning)
   â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”     â–¼
   â”‚A + 1â”‚    â”‚A + 2â”‚  â”Œâ”€â”€â”€â”€â”€â”
   â””â”€â”€â”¬â”€â”€â”˜    â””â”€â”€â”¬â”€â”€â”˜  â”‚B + 1â”‚
      â”‚          âœ—     â””â”€â”€â”¬â”€â”€â”˜
      â–¼      (invalid)    â”‚
   â”Œâ”€â”€â”€â”€â”€â”                â–¼
   â”‚ âœ“   â”‚            â”Œâ”€â”€â”€â”€â”€â”
   â”‚SOL! â”‚            â”‚ âœ“   â”‚
   â””â”€â”€â”€â”€â”€â”˜            â”‚SOL! â”‚
                      â””â”€â”€â”€â”€â”€â”˜
            </div>
            
            <p>La fiecare nod, verificÄƒm dacÄƒ alegerea curentÄƒ este <strong>promiÈ›Äƒtoare</strong>. DacÄƒ nu, <strong>backtrack</strong> la nodul anterior.</p>
        </div>

        <!-- Slide 11: Backtracking Template -->
        <div class="slide">
            <h2>ğŸ”® Backtracking - Template General</h2>
            
            <pre><code class="language-c">bool backtrack(State *state, int level) {
    // Cazul de bazÄƒ: am gÄƒsit o soluÈ›ie?
    if (is_solution(state, level)) {
        process_solution(state);
        return true;  // sau false pentru TOATE soluÈ›iile
    }
    
    // GenereazÄƒ candidaÈ›ii pentru nivelul curent
    Candidate candidates[MAX_CANDIDATES];
    int n = generate_candidates(state, level, candidates);
    
    // ÃncearcÄƒ fiecare candidat
    for (int i = 0; i < n; i++) {
        // VerificÄƒ dacÄƒ candidatul este promiÈ›Äƒtor (pruning)
        if (is_promising(state, candidates[i])) {
            // AplicÄƒ alegerea
            apply_choice(state, candidates[i]);
            
            // RecurseazÄƒ la nivelul urmÄƒtor
            if (backtrack(state, level + 1)) {
                return true;  // SoluÈ›ie gÄƒsitÄƒ
            }
            
            // BACKTRACK: anuleazÄƒ alegerea
            undo_choice(state, candidates[i]);
        }
    }
    
    return false;  // Nicio soluÈ›ie pe aceastÄƒ cale
}</code></pre>
            
            <div class="warning-box">
                <strong>Cheie:</strong> <code>undo_choice()</code> este esenÈ›ial - reseteazÄƒ starea pentru a Ã®ncerca alt candidat!
            </div>
        </div>

        <!-- Slide 12: N-Queens Problem -->
        <div class="slide">
            <h2>ğŸ‘‘ Problema N-Queens</h2>
            
            <p>PlaseazÄƒ N regine pe o tablÄƒ NxN astfel Ã®ncÃ¢t nicio reginÄƒ sÄƒ nu atace alta.</p>
            
            <div class="two-columns">
                <div class="column">
                    <h3>ConstrÃ¢ngeri</h3>
                    <ul>
                        <li>Cel mult o reginÄƒ per <strong>rÃ¢nd</strong></li>
                        <li>Cel mult o reginÄƒ per <strong>coloanÄƒ</strong></li>
                        <li>Cel mult o reginÄƒ per <strong>diagonalÄƒ</strong></li>
                    </ul>
                    <div class="diagram" style="font-size: 0.9em;">
NumÄƒr de soluÈ›ii:
N=4: 2 soluÈ›ii
N=5: 10 soluÈ›ii
N=6: 4 soluÈ›ii
N=7: 40 soluÈ›ii
N=8: 92 soluÈ›ii
                    </div>
                </div>
                <div class="column">
                    <h3>SoluÈ›ie pentru N=4</h3>
                    <div class="diagram" style="font-size: 1.1em;">
    0   1   2   3
  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
0 â”‚ . â”‚ â™› â”‚ . â”‚ . â”‚
  â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
1 â”‚ . â”‚ . â”‚ . â”‚ â™› â”‚
  â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
2 â”‚ â™› â”‚ . â”‚ . â”‚ . â”‚
  â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
3 â”‚ . â”‚ . â”‚ â™› â”‚ . â”‚
  â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
  
col[] = {1, 3, 0, 2}
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 13: N-Queens Implementation -->
        <div class="slide">
            <h2>ğŸ‘‘ N-Queens - Implementare</h2>
            
            <pre><code class="language-c">// VerificÄƒ dacÄƒ poziÈ›ia (row, col) este sigurÄƒ
bool is_safe(int *col, int row) {
    for (int i = 0; i < row; i++) {
        // AcelaÈ™i column?
        if (col[i] == col[row]) return false;
        
        // AceeaÈ™i diagonalÄƒ?
        // |row - i| == |col[row] - col[i]|
        if (abs(row - i) == abs(col[row] - col[i])) return false;
    }
    return true;
}

// RezolvÄƒ problema N-Queens folosind backtracking
bool solve_n_queens(int *col, int row, int n) {
    if (row == n) {
        // Am plasat toate reginele!
        return true;
    }
    
    // ÃncearcÄƒ fiecare coloanÄƒ pentru rÃ¢ndul curent
    for (int c = 0; c < n; c++) {
        col[row] = c;
        
        if (is_safe(col, row)) {
            if (solve_n_queens(col, row + 1, n)) {
                return true;
            }
        }
        // Backtrack implicit: col[row] va fi suprascris
    }
    
    return false;
}</code></pre>
            
            <p><span class="complexity">Complexitate: O(N!)</span> worst case, dar mult mai bine cu pruning</p>
        </div>

        <!-- Slide 14: Sudoku Solver -->
        <div class="slide">
            <h2>ğŸ”¢ Sudoku Solver</h2>
            
            <p>CompleteazÄƒ un grid 9x9 astfel Ã®ncÃ¢t fiecare rÃ¢nd, coloanÄƒ È™i box 3x3 sÄƒ conÈ›inÄƒ cifrele 1-9 exact o datÄƒ.</p>
            
            <div class="two-columns">
                <div class="column">
                    <h3>ConstrÃ¢ngeri</h3>
                    <div class="step">
                        <div class="step-number">1</div>
                        <div>Cifra nu apare Ã®n <strong>rÃ¢nd</strong></div>
                    </div>
                    <div class="step">
                        <div class="step-number">2</div>
                        <div>Cifra nu apare Ã®n <strong>coloanÄƒ</strong></div>
                    </div>
                    <div class="step">
                        <div class="step-number">3</div>
                        <div>Cifra nu apare Ã®n <strong>box 3x3</strong></div>
                    </div>
                </div>
                <div class="column">
                    <div class="diagram" style="font-size: 0.85em;">
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ 5 3 . â”‚ . 7 . â”‚ . . . â•‘
â•‘ 6 . . â”‚ 1 9 5 â”‚ . . . â•‘
â•‘ . 9 8 â”‚ . . . â”‚ . 6 . â•‘
â•‘â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â•‘
â•‘ 8 . . â”‚ . 6 . â”‚ . . 3 â•‘
â•‘ 4 . . â”‚ 8 . 3 â”‚ . . 1 â•‘
â•‘ 7 . . â”‚ . 2 . â”‚ . . 6 â•‘
â•‘â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â•‘
â•‘ . 6 . â”‚ . . . â”‚ 2 8 . â•‘
â•‘ . . . â”‚ 4 1 9 â”‚ . . 5 â•‘
â•‘ . . . â”‚ . 8 . â”‚ . 7 9 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

'.' = celulÄƒ goalÄƒ
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 15: Sudoku Implementation -->
        <div class="slide">
            <h2>ğŸ”¢ Sudoku Solver - Implementare</h2>
            
            <pre><code class="language-c">bool is_valid(int grid[9][9], int row, int col, int num) {
    // VerificÄƒ rÃ¢ndul
    for (int c = 0; c < 9; c++)
        if (grid[row][c] == num) return false;
    
    // VerificÄƒ coloana
    for (int r = 0; r < 9; r++)
        if (grid[r][col] == num) return false;
    
    // VerificÄƒ box-ul 3x3
    int box_r = (row / 3) * 3;
    int box_c = (col / 3) * 3;
    for (int r = 0; r < 3; r++)
        for (int c = 0; c < 3; c++)
            if (grid[box_r + r][box_c + c] == num) return false;
    
    return true;
}

bool solve_sudoku(int grid[9][9]) {
    // GÄƒseÈ™te prima celulÄƒ goalÄƒ
    for (int row = 0; row < 9; row++) {
        for (int col = 0; col < 9; col++) {
            if (grid[row][col] == 0) {
                // ÃncearcÄƒ fiecare cifrÄƒ 1-9
                for (int num = 1; num <= 9; num++) {
                    if (is_valid(grid, row, col, num)) {
                        grid[row][col] = num;
                        if (solve_sudoku(grid)) return true;
                        grid[row][col] = 0;  // Backtrack
                    }
                }
                return false;
            }
        }
    }
    return true;  // Toate celulele completate
}</code></pre>
        </div>

        <!-- Slide 16: Combinatorial Generation -->
        <div class="slide">
            <h2>ğŸ² Generare CombinatoricÄƒ</h2>
            
            <div class="two-columns">
                <div class="column">
                    <h3>PermutÄƒri P(n)</h3>
                    <p>Toate aranjamentele posibile a n elemente.</p>
                    <div class="diagram" style="font-size: 0.9em;">
P(3) = {1,2,3}:
[1,2,3] [1,3,2]
[2,1,3] [2,3,1]
[3,1,2] [3,2,1]

Total: 3! = 6
                    </div>
                    
                    <h3>CombinÄƒri C(n,k)</h3>
                    <p>SubmulÈ›imi de k elemente din n.</p>
                    <div class="diagram" style="font-size: 0.9em;">
C(4,2) = {1,2,3,4}:
{1,2} {1,3} {1,4}
{2,3} {2,4} {3,4}

Total: C(4,2) = 6
                    </div>
                </div>
                <div class="column">
                    <h3>SubmulÈ›imi 2^n</h3>
                    <p>Toate submulÈ›imile posibile.</p>
                    <div class="diagram" style="font-size: 0.9em;">
2^3 pentru {1,2,3}:
{}
{1} {2} {3}
{1,2} {1,3} {2,3}
{1,2,3}

Total: 2Â³ = 8
                    </div>
                    
                    <div class="info-box">
                        <strong>Backtracking:</strong> La fiecare element, alegem "include" sau "exclude".
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 17: Graph Coloring -->
        <div class="slide">
            <h2>ğŸ¨ Graph Coloring</h2>
            
            <p>ColoreazÄƒ nodurile unui graf cu maximum K culori astfel Ã®ncÃ¢t niciun nod adiacent sÄƒ nu aibÄƒ aceeaÈ™i culoare.</p>
            
            <div class="two-columns">
                <div class="column">
                    <div class="diagram">
Graf necolorat:           Graf colorat (K=3):
                          
    (0)â”€â”€â”€(1)                 (ğŸ”´)â”€â”€â”€(ğŸ”µ)
     â”‚ â•² â•± â”‚                   â”‚ â•² â•± â”‚
     â”‚  â•³  â”‚                   â”‚  â•³  â”‚
     â”‚ â•± â•² â”‚                   â”‚ â•± â•² â”‚
    (2)â”€â”€â”€(3)                 (ğŸŸ¢)â”€â”€â”€(ğŸ”´)
      â•²   â•±                     â•²   â•±
       â•² â•±                       â•² â•±
       (4)                       (ğŸ”µ)
                    </div>
                </div>
                <div class="column">
                    <h3>AplicaÈ›ii</h3>
                    <ul>
                        <li><strong>Scheduling:</strong> Examene, ore de curs</li>
                        <li><strong>Registre:</strong> Alocare Ã®n compilatoare</li>
                        <li><strong>FrecvenÈ›e:</strong> Alocare radio/wireless</li>
                        <li><strong>Sudoku:</strong> K=9 culori!</li>
                    </ul>
                    
                    <div class="warning-box">
                        <strong>NP-Complet:</strong> Pentru K â‰¥ 3, problema este NP-completÄƒ.
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 18: Comparison Table -->
        <div class="slide">
            <h2>âš–ï¸ ComparaÈ›ie: Greedy vs Backtracking vs DP</h2>
            
            <table>
                <thead>
                    <tr>
                        <th>Aspect</th>
                        <th style="color: var(--accent-green);">Greedy</th>
                        <th style="color: var(--accent-purple);">Backtracking</th>
                        <th style="color: var(--accent-orange);">DP</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Strategie</strong></td>
                        <td>Alegere localÄƒ optimÄƒ</td>
                        <td>Explorare exhaustivÄƒ cu pruning</td>
                        <td>Subprobleme + memoizare</td>
                    </tr>
                    <tr>
                        <td><strong>GaranteazÄƒ optim?</strong></td>
                        <td>Doar cu proprietatea greedy</td>
                        <td>Da (exploreazÄƒ tot)</td>
                        <td>Da</td>
                    </tr>
                    <tr>
                        <td><strong>Complexitate tipicÄƒ</strong></td>
                        <td>O(n log n)</td>
                        <td>O(k^n) exponenÈ›ial</td>
                        <td>O(nÃ—W) pseudopolinomial</td>
                    </tr>
                    <tr>
                        <td><strong>Memorie</strong></td>
                        <td>O(1) sau O(n)</td>
                        <td>O(n) stiva recursiei</td>
                        <td>O(nÃ—W) tabelÄƒ</td>
                    </tr>
                    <tr>
                        <td><strong>CÃ¢nd foloseÈ™ti?</strong></td>
                        <td>Probleme cu proprietatea greedy</td>
                        <td>CombinatoricÄƒ, satisfacÈ›ie constrÃ¢ngeri</td>
                        <td>Subprobleme suprapuse</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Slide 19: Decision Flowchart -->
        <div class="slide">
            <h2>ğŸ§­ Ghid de Alegere a Paradigmei</h2>
            
            <div class="diagram">
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚          PROBLEMÄ‚ DE OPTIMIZARE          â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                          â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ Are proprietatea alegerii greedy?         â”‚
                    â”‚ (alegerea localÄƒ e parte din optim global)â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚                     â”‚
                          DA â”‚                     â”‚ NU
                              â”‚                     â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚     GREEDY       â”‚  â”‚ Subprobleme      â”‚
                    â”‚  O(n log n)      â”‚  â”‚ suprapuse?       â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                              â”‚          â”‚
                                          DA â”‚          â”‚ NU
                                              â”‚          â”‚
                               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”  â”Œâ”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                               â”‚  PROGRAMARE      â”‚  â”‚   BACKTRACKING   â”‚
                               â”‚  DINAMICÄ‚        â”‚  â”‚   (sau Brute     â”‚
                               â”‚  O(nÃ—W)          â”‚  â”‚    Force)        â”‚
                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
        </div>

        <!-- Slide 20: Pruning Techniques -->
        <div class="slide">
            <h2>âœ‚ï¸ Tehnici de Pruning Ã®n Backtracking</h2>
            
            <div class="two-columns">
                <div class="column">
                    <h3>1. Constraint Propagation</h3>
                    <p>EliminÄƒ opÈ›iuni care violeazaz constrÃ¢ngeri.</p>
                    <pre><code class="language-c">// Sudoku: nu Ã®ncerca cifre invalide
if (!is_valid(grid, row, col, num))
    continue;  // Skip</code></pre>
                    
                    <h3>2. Bounding (Branch & Bound)</h3>
                    <p>EstimeazÄƒ dacÄƒ calea curentÄƒ poate duce la soluÈ›ie mai bunÄƒ.</p>
                    <pre><code class="language-c">// DacÄƒ suma restantÄƒ < minim necesar
if (current_sum + max_remaining < target)
    return;  // Prune</code></pre>
                </div>
                <div class="column">
                    <h3>3. Symmetry Breaking</h3>
                    <p>EvitÄƒ explorarea soluÈ›iilor simetrice.</p>
                    <pre><code class="language-c">// N-Queens: prima reginÄƒ doar Ã®n jumÄƒtatea stÃ¢ngÄƒ
if (row == 0 && col > n/2)
    continue;</code></pre>
                    
                    <h3>4. MCV (Most Constrained Variable)</h3>
                    <p>Alege variabila cu cele mai puÈ›ine opÈ›iuni.</p>
                    <pre><code class="language-c">// Sudoku: alege celula cu cel mai puÈ›in opÈ›iuni
int best = find_most_constrained_cell(grid);</code></pre>
                </div>
            </div>
        </div>

        <!-- Slide 21: Common Mistakes -->
        <div class="slide">
            <h2>âš ï¸ GreÈ™eli Frecvente</h2>
            
            <div class="two-columns">
                <div class="column comparison-card greedy">
                    <h3>Greedy</h3>
                    <ul>
                        <li>âŒ <strong>Presupunere fÄƒrÄƒ demonstraÈ›ie</strong> cÄƒ funcÈ›ioneazÄƒ
                            <p style="font-size: 0.9em; color: var(--text-secondary);">Greedy nu garanteazÄƒ optim pentru toate problemele!</p>
                        </li>
                        <li>âŒ <strong>Sortare incorectÄƒ</strong>
                            <p style="font-size: 0.9em; color: var(--text-secondary);">Activity Selection: sortÄƒm dupÄƒ END, nu START</p>
                        </li>
                        <li>âŒ <strong>Uitarea cazurilor limitÄƒ</strong>
                            <p style="font-size: 0.9em; color: var(--text-secondary);">Ce se Ã®ntÃ¢mplÄƒ dacÄƒ n=0 sau capacity=0?</p>
                        </li>
                    </ul>
                </div>
                <div class="column comparison-card backtracking">
                    <h3>Backtracking</h3>
                    <ul>
                        <li>âŒ <strong>Uitarea backtrack</strong>
                            <p style="font-size: 0.9em; color: var(--text-secondary);">Trebuie sÄƒ resetÄƒm starea dupÄƒ recursie eÈ™uatÄƒ!</p>
                        </li>
                        <li>âŒ <strong>Lipsa matricei visited</strong>
                            <p style="font-size: 0.9em; color: var(--text-secondary);">Duce la bucle infinite Ã®n labirint/graf</p>
                        </li>
                        <li>âŒ <strong>Pruning insuficient</strong>
                            <p style="font-size: 0.9em; color: var(--text-secondary);">FÄƒrÄƒ verificÄƒri, explorÄƒm cÄƒi evident invalide</p>
                        </li>
                    </ul>
                </div>
            </div>
            
            <div class="danger-box">
                <strong>Debugging tip:</strong> AfiÈ™aÈ›i starea la fiecare pas pentru a vizualiza comportamentul algoritmului!
            </div>
        </div>

        <!-- Slide 22: Interview Questions -->
        <div class="slide">
            <h2>ğŸ’¼ PregÄƒtire pentru Interviu</h2>
            
            <div class="two-columns">
                <div class="column">
                    <h3>Greedy - ÃntrebÄƒri Tipice</h3>
                    <ol>
                        <li>
                            <strong>Activity Selection</strong>
                            <p style="font-size: 0.9em;">De ce sortÄƒm dupÄƒ finish time?</p>
                        </li>
                        <li>
                            <strong>Huffman Coding</strong>
                            <p style="font-size: 0.9em;">Cum construim arborele?</p>
                        </li>
                        <li>
                            <strong>Coin Change</strong>
                            <p style="font-size: 0.9em;">CÃ¢nd Greedy NU funcÈ›ioneazÄƒ?</p>
                        </li>
                        <li>
                            <strong>Jump Game</strong>
                            <p style="font-size: 0.9em;">VerificÄƒ dacÄƒ poÈ›i ajunge la final</p>
                        </li>
                    </ol>
                </div>
                <div class="column">
                    <h3>Backtracking - ÃntrebÄƒri Tipice</h3>
                    <ol>
                        <li>
                            <strong>N-Queens</strong>
                            <p style="font-size: 0.9em;">Clasic! Implementare + optimizÄƒri</p>
                        </li>
                        <li>
                            <strong>Sudoku Solver</strong>
                            <p style="font-size: 0.9em;">Validare + MCV heuristic</p>
                        </li>
                        <li>
                            <strong>Subsets/Permutations</strong>
                            <p style="font-size: 0.9em;">Generare combinatoricÄƒ</p>
                        </li>
                        <li>
                            <strong>Word Search</strong>
                            <p style="font-size: 0.9em;">CÄƒutare Ã®n grid de caractere</p>
                        </li>
                    </ol>
                </div>
            </div>
        </div>

        <!-- Slide 23: Lab Exercise Preview -->
        <div class="slide">
            <h2>ğŸ”¬ ExerciÈ›ii de Laborator</h2>
            
            <div class="two-columns">
                <div class="column comparison-card greedy">
                    <h3>ExerciÈ›iul 1: Activity Selection</h3>
                    <ul>
                        <li>Citire activitÄƒÈ›i din fiÈ™ier</li>
                        <li>Implementare algoritm greedy</li>
                        <li>AfiÈ™are timeline vizual</li>
                        <li>Statistici: activitÄƒÈ›i selectate</li>
                    </ul>
                    <p><strong>FiÈ™ier:</strong> <code>exercise1.c</code></p>
                    <p><strong>Timp:</strong> ~45 minute</p>
                </div>
                <div class="column comparison-card backtracking">
                    <h3>ExerciÈ›iul 2: Sudoku Solver</h3>
                    <ul>
                        <li>Citire puzzle din fiÈ™ier</li>
                        <li>Implementare backtracking</li>
                        <li>AfiÈ™are grid cu culori</li>
                        <li>Bonus: MCV optimization</li>
                    </ul>
                    <p><strong>FiÈ™ier:</strong> <code>exercise2.c</code></p>
                    <p><strong>Timp:</strong> ~60 minute</p>
                </div>
            </div>
            
            <div class="success-box" style="margin-top: 30px;">
                <strong>ğŸ’¡ Sfat:</strong> ÃncepeÈ›i cu funcÈ›iile de validare, apoi implementaÈ›i algoritmul principal!
            </div>
        </div>

        <!-- Slide 24: Summary -->
        <div class="slide">
            <h2>ğŸ“ Rezumat</h2>
            
            <div class="info-box">
                <h3>Ce am Ã®nvÄƒÈ›at Ã®n aceastÄƒ sÄƒptÄƒmÃ¢nÄƒ:</h3>
            </div>
            
            <div class="two-columns">
                <div class="column">
                    <h3 style="color: var(--accent-green);">ğŸ’š Greedy</h3>
                    <ul>
                        <li>Alegere localÄƒ optimÄƒ</li>
                        <li>Proprietatea greedy + substructurÄƒ optimalÄƒ</li>
                        <li>Activity Selection O(n log n)</li>
                        <li>Fractional Knapsack O(n log n)</li>
                        <li>Nu garanteazÄƒ mereu optim!</li>
                    </ul>
                </div>
                <div class="column">
                    <h3 style="color: var(--accent-purple);">ğŸ’œ Backtracking</h3>
                    <ul>
                        <li>Explorare sistematicÄƒ cu pruning</li>
                        <li>GaranteazÄƒ gÄƒsirea soluÈ›iei</li>
                        <li>N-Queens, Sudoku, Graph Coloring</li>
                        <li>Template: try â†’ recurse â†’ undo</li>
                        <li>OptimizÄƒri: MCV, symmetry breaking</li>
                    </ul>
                </div>
            </div>
            
            <div class="success-box" style="margin-top: 30px; text-align: center;">
                <h3>ğŸ¯ Ãntrebarea cheie: "Alegerea localÄƒ poate fi parte din optimul global?"</h3>
                <p>DA â†’ Greedy | NU â†’ Backtracking sau DP</p>
            </div>
        </div>

        <!-- Slide 25: Next Week Preview -->
        <div class="slide">
            <h2>ğŸ”® Preview: SÄƒptÄƒmÃ¢na UrmÄƒtoare</h2>
            
            <div class="info-box" style="text-align: center;">
                <h1 style="color: var(--accent-yellow); font-size: 3em;">ğŸ“š RECAPITULARE</h1>
                <h2 style="border: none; margin-top: 20px;">PregÄƒtire pentru Examen</h2>
            </div>
            
            <div class="two-columns" style="margin-top: 40px;">
                <div class="column">
                    <h3>Ce vom recapitula</h3>
                    <ul>
                        <li>Structuri de date fundamentale</li>
                        <li>Algoritmi de sortare È™i cÄƒutare</li>
                        <li>Grafuri È™i arbori</li>
                        <li>Paradigme algoritmice</li>
                        <li>Complexitate È™i analiza algoritmilor</li>
                    </ul>
                </div>
                <div class="column">
                    <h3>Cum sÄƒ vÄƒ pregÄƒtiÈ›i</h3>
                    <ul>
                        <li>âœ… RevedeÈ›i toate temele</li>
                        <li>âœ… ReÃ®ncercaÈ›i exerciÈ›iile de laborator</li>
                        <li>âœ… RezolvaÈ›i probleme de practicÄƒ</li>
                        <li>âœ… ÃnÈ›elegeÈ›i "de ce", nu doar "cum"</li>
                        <li>âœ… PregÄƒtiÈ›i Ã®ntrebÄƒri pentru clarificÄƒri</li>
                    </ul>
                </div>
            </div>
            
            <div class="success-box" style="margin-top: 30px; text-align: center;">
                <strong>ğŸ’ª Succes la pregÄƒtire!</strong>
            </div>
        </div>

    </div>
    
    <div class="keyboard-hints">
        <kbd>â†</kbd> <kbd>â†’</kbd> pentru navigare | <kbd>Home</kbd> <kbd>End</kbd> pentru Ã®nceput/final
    </div>
    
    <div class="nav-container">
        <button class="nav-btn" id="prevBtn" onclick="changeSlide(-1)">â† Anterior</button>
        <button class="nav-btn" id="nextBtn" onclick="changeSlide(1)">UrmÄƒtor â†’</button>
    </div>

    <script>
        // Initialize highlight.js
        hljs.highlightAll();

        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        const totalSlides = slides.length;
        const progressBar = document.getElementById('progressBar');
        const slideCounter = document.getElementById('slideCounter');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');

        function showSlide(index) {
            slides.forEach(slide => slide.classList.remove('active'));
            
            if (index < 0) index = 0;
            if (index >= totalSlides) index = totalSlides - 1;
            
            currentSlide = index;
            slides[currentSlide].classList.add('active');
            
            const progress = ((currentSlide + 1) / totalSlides) * 100;
            progressBar.style.width = progress + '%';
            
            slideCounter.textContent = `${currentSlide + 1} / ${totalSlides}`;
            
            prevBtn.disabled = currentSlide === 0;
            nextBtn.disabled = currentSlide === totalSlides - 1;
        }

        function changeSlide(direction) {
            showSlide(currentSlide + direction);
        }

        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            switch(e.key) {
                case 'ArrowRight':
                case 'PageDown':
                case ' ':
                    e.preventDefault();
                    changeSlide(1);
                    break;
                case 'ArrowLeft':
                case 'PageUp':
                    e.preventDefault();
                    changeSlide(-1);
                    break;
                case 'Home':
                    e.preventDefault();
                    showSlide(0);
                    break;
                case 'End':
                    e.preventDefault();
                    showSlide(totalSlides - 1);
                    break;
            }
        });

        // Touch support
        let touchStartX = 0;
        let touchEndX = 0;

        document.addEventListener('touchstart', e => {
            touchStartX = e.changedTouches[0].screenX;
        });

        document.addEventListener('touchend', e => {
            touchEndX = e.changedTouches[0].screenX;
            handleSwipe();
        });

        function handleSwipe() {
            const threshold = 50;
            const diff = touchStartX - touchEndX;
            
            if (Math.abs(diff) > threshold) {
                if (diff > 0) {
                    changeSlide(1);
                } else {
                    changeSlide(-1);
                }
            }
        }

        // Initialize
        showSlide(0);
    </script>
</body>
</html>
