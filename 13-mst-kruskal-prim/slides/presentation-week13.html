<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SÄƒptÄƒmÃ¢na 13: Algoritmi pe Grafuri - Dijkstra & Bellman-Ford | ATP</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-yellow: #d29922;
            --accent-red: #f85149;
            --accent-purple: #a371f7;
            --accent-cyan: #39c5cf;
            --border-color: #30363d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            line-height: 1.6;
        }

        /* Progress Bar */
        .progress-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: var(--bg-tertiary);
            z-index: 1000;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            transition: width 0.3s ease;
        }

        /* Slide Container */
        .slides-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .slide {
            position: absolute;
            width: 100%;
            height: 100%;
            padding: 60px 80px;
            display: none;
            opacity: 0;
            transition: opacity 0.4s ease;
            overflow-y: auto;
        }

        .slide.active {
            display: flex;
            flex-direction: column;
            opacity: 1;
        }

        /* Slide Counter */
        .slide-counter {
            position: fixed;
            bottom: 20px;
            left: 30px;
            font-size: 14px;
            color: var(--text-secondary);
            z-index: 100;
        }

        /* Navigation Buttons */
        .nav-buttons {
            position: fixed;
            bottom: 20px;
            right: 30px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .nav-btn {
            padding: 10px 20px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .nav-btn:hover {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Typography */
        h1 {
            font-size: 3rem;
            color: var(--accent-blue);
            margin-bottom: 30px;
            line-height: 1.2;
        }

        h2 {
            font-size: 2.2rem;
            color: var(--accent-green);
            margin-bottom: 25px;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 10px;
        }

        h3 {
            font-size: 1.5rem;
            color: var(--accent-yellow);
            margin: 20px 0 15px 0;
        }

        p {
            font-size: 1.2rem;
            color: var(--text-primary);
            margin-bottom: 15px;
        }

        ul, ol {
            margin-left: 30px;
            margin-bottom: 20px;
        }

        li {
            font-size: 1.15rem;
            margin-bottom: 12px;
            color: var(--text-primary);
        }

        /* Title Slide */
        .title-slide {
            justify-content: center;
            align-items: center;
            text-align: center;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
        }

        .title-slide h1 {
            font-size: 3.5rem;
            margin-bottom: 20px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .title-slide .subtitle {
            font-size: 1.8rem;
            color: var(--accent-green);
            margin-bottom: 40px;
        }

        .title-slide .meta {
            font-size: 1.2rem;
            color: var(--text-secondary);
        }

        /* Code Block */
        .code-block {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin: 20px 0;
            overflow: hidden;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .lang-badge {
            background: var(--accent-blue);
            color: var(--bg-primary);
            padding: 2px 10px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.8rem;
        }

        .code-block pre {
            margin: 0;
            padding: 20px;
            overflow-x: auto;
        }

        .code-block code {
            font-family: 'Fira Code', 'Consolas', 'Monaco', monospace;
            font-size: 0.95rem;
            line-height: 1.5;
        }

        /* Info Boxes */
        .info-box {
            padding: 20px 25px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid;
        }

        .info-box.tip {
            background: rgba(63, 185, 80, 0.1);
            border-color: var(--accent-green);
        }

        .info-box.warning {
            background: rgba(210, 153, 34, 0.1);
            border-color: var(--accent-yellow);
        }

        .info-box.danger {
            background: rgba(248, 81, 73, 0.1);
            border-color: var(--accent-red);
        }

        .info-box.info {
            background: rgba(88, 166, 255, 0.1);
            border-color: var(--accent-blue);
        }

        .info-box h4 {
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .info-box.tip h4 { color: var(--accent-green); }
        .info-box.warning h4 { color: var(--accent-yellow); }
        .info-box.danger h4 { color: var(--accent-red); }
        .info-box.info h4 { color: var(--accent-blue); }

        /* Two Column Layout */
        .two-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            margin: 20px 0;
        }

        .column {
            background: var(--bg-secondary);
            padding: 25px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        /* Comparison Table */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 1rem;
        }

        .comparison-table th {
            background: var(--bg-tertiary);
            color: var(--accent-blue);
            padding: 15px;
            text-align: left;
            border: 1px solid var(--border-color);
        }

        .comparison-table td {
            padding: 12px 15px;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
        }

        .comparison-table tr:hover td {
            background: var(--bg-tertiary);
        }

        /* Complexity Badge */
        .complexity {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 15px;
            font-family: 'Fira Code', monospace;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .complexity.good { background: var(--accent-green); color: var(--bg-primary); }
        .complexity.medium { background: var(--accent-yellow); color: var(--bg-primary); }
        .complexity.bad { background: var(--accent-red); color: var(--text-primary); }

        /* Graph Visualization (ASCII) */
        .graph-ascii {
            font-family: 'Fira Code', 'Consolas', monospace;
            background: var(--bg-secondary);
            padding: 25px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            white-space: pre;
            line-height: 1.4;
            font-size: 1rem;
            overflow-x: auto;
        }

        /* Key Figure Box */
        .key-figure {
            display: flex;
            gap: 30px;
            background: var(--bg-secondary);
            padding: 30px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            margin: 20px 0;
        }

        .key-figure .photo-placeholder {
            width: 150px;
            height: 180px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            flex-shrink: 0;
        }

        .key-figure .bio {
            flex: 1;
        }

        .key-figure .bio h3 {
            color: var(--accent-blue);
            margin-top: 0;
        }

        .key-figure blockquote {
            font-style: italic;
            color: var(--accent-yellow);
            border-left: 3px solid var(--accent-yellow);
            padding-left: 15px;
            margin-top: 15px;
        }

        /* Algorithm Steps */
        .algorithm-steps {
            counter-reset: step;
            list-style: none;
            margin-left: 0;
        }

        .algorithm-steps li {
            position: relative;
            padding-left: 50px;
            margin-bottom: 20px;
        }

        .algorithm-steps li::before {
            counter-increment: step;
            content: counter(step);
            position: absolute;
            left: 0;
            top: 0;
            width: 35px;
            height: 35px;
            background: var(--accent-blue);
            color: var(--bg-primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        /* Highlight Text */
        .highlight { color: var(--accent-yellow); font-weight: 600; }
        .highlight-blue { color: var(--accent-blue); font-weight: 600; }
        .highlight-green { color: var(--accent-green); font-weight: 600; }
        .highlight-red { color: var(--accent-red); font-weight: 600; }

        /* Summary Grid */
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 20px 0;
        }

        .summary-item {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            text-align: center;
        }

        .summary-item .icon {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .summary-item h4 {
            color: var(--accent-blue);
            margin-bottom: 8px;
        }

        /* Keyboard Shortcuts */
        kbd {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 3px 8px;
            font-family: 'Fira Code', monospace;
            font-size: 0.85rem;
            color: var(--accent-yellow);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .slide { padding: 40px 50px; }
            h1 { font-size: 2.5rem; }
            h2 { font-size: 1.8rem; }
            .two-columns { grid-template-columns: 1fr; }
            .summary-grid { grid-template-columns: repeat(2, 1fr); }
        }
    </style>
</head>
<body>
    <!-- Progress Bar -->
    <div class="progress-container">
        <div class="progress-bar" id="progressBar"></div>
    </div>

    <!-- Slide Counter -->
    <div class="slide-counter">
        <span id="currentSlide">1</span> / <span id="totalSlides">37</span>
    </div>

    <!-- Navigation -->
    <div class="nav-buttons">
        <button class="nav-btn" id="prevBtn" onclick="changeSlide(-1)">â† Anterior</button>
        <button class="nav-btn" id="nextBtn" onclick="changeSlide(1)">UrmÄƒtor â†’</button>
    </div>

    <!-- Slides Container -->
    <div class="slides-container">

        <!-- Slide 1: Title -->
        <div class="slide title-slide active" data-slide="1">
            <div style="font-size: 1.2rem; color: var(--text-secondary); margin-bottom: 30px;">
                Academia de Studii Economice din BucureÈ™ti<br>
                Catedra de InformaticÄƒ EconomicÄƒ
            </div>
            <h1>Algoritmi pe Grafuri</h1>
            <div class="subtitle">Dijkstra & Bellman-Ford</div>
            <div style="font-size: 2rem; margin-bottom: 30px;">ğŸ“Š SÄƒptÄƒmÃ¢na 13</div>
            <div class="meta">
                Algoritmi È™i Tehnici de Programare<br>
                Anul II â€¢ Semestrul 2
            </div>
        </div>

        <!-- Slide 2: Learning Objectives -->
        <div class="slide" data-slide="2">
            <h2>ğŸ¯ Obiective de ÃnvÄƒÈ›are</h2>
            <p>La finalul acestei sÄƒptÄƒmÃ¢ni, veÈ›i fi capabili sÄƒ:</p>
            <ol>
                <li><span class="highlight">ÃnÈ›elegeÈ›i</span> problema drumului minim Ã®n grafuri ponderate È™i diferenÈ›a fundamentalÄƒ Ã®ntre abordÄƒrile greedy È™i dynamic programming</li>
                <li><span class="highlight-blue">ImplementaÈ›i</span> algoritmul Dijkstra folosind o coadÄƒ de prioritÄƒÈ›i (min-heap) pentru optimizarea complexitÄƒÈ›ii</li>
                <li><span class="highlight-green">AplicaÈ›i</span> algoritmul Bellman-Ford pentru grafuri cu muchii negative È™i sÄƒ detectaÈ›i cicluri negative</li>
                <li><span class="highlight">AnalizaÈ›i</span> complexitatea temporalÄƒ È™i spaÈ›ialÄƒ a ambilor algoritmi Ã®n funcÈ›ie de reprezentarea grafului</li>
                <li><span class="highlight-blue">EvaluaÈ›i</span> alegerea algoritmului optim Ã®n funcÈ›ie de caracteristicile problemei (muchii negative, densitate)</li>
                <li><span class="highlight-green">CreaÈ›i</span> soluÈ›ii complete care includ reconstrucÈ›ia drumului È™i gestionarea cazurilor speciale</li>
            </ol>
        </div>

        <!-- Slide 3: Historical Context -->
        <div class="slide" data-slide="3">
            <h2>ğŸ“œ Context Istoric</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Originile Problemei</h3>
                    <ul>
                        <li><strong>1736</strong> - Euler È™i problema podurilor din KÃ¶nigsberg â€” naÈ™terea teoriei grafurilor</li>
                        <li><strong>1956</strong> - Dijkstra dezvoltÄƒ algoritmul Ã®n 20 de minute!</li>
                        <li><strong>1958</strong> - Bellman È™i Ford publicÄƒ independent</li>
                        <li><strong>1962</strong> - Floyd-Warshall pentru toate perechile</li>
                    </ul>
                </div>
                <div class="column">
                    <h3>AplicaÈ›ii Istorice</h3>
                    <ul>
                        <li><strong>ARPANET</strong> (1969) - primul routing protocol</li>
                        <li><strong>GPS</strong> (1978) - navigaÈ›ie satelitarÄƒ</li>
                        <li><strong>OSPF</strong> (1989) - protocol de rutare Internet</li>
                        <li><strong>Google Maps</strong> (2005) - navigaÈ›ie modernÄƒ</li>
                    </ul>
                </div>
            </div>
            <div class="info-box info">
                <h4>ğŸ’¡ È˜tiaÈ›i cÄƒ?</h4>
                <p>Dijkstra a conceput algoritmul Ã®n timp ce lua cafeaua Ã®ntr-o terasÄƒ din Amsterdam, fÄƒrÄƒ sÄƒ foloseascÄƒ creion È™i hÃ¢rtie!</p>
            </div>
        </div>

        <!-- Slide 4: Key Figure - Dijkstra -->
        <div class="slide" data-slide="4">
            <h2>ğŸ‘¤ Figura Cheie: Edsger W. Dijkstra</h2>
            <div class="key-figure">
                <div class="photo-placeholder">
                    ğŸ“·<br>Dijkstra<br>(1930-2002)
                </div>
                <div class="bio">
                    <h3>Edsger Wybe Dijkstra (1930-2002)</h3>
                    <p><strong>Èšara:</strong> Olanda ğŸ‡³ğŸ‡± | <strong>Premiu Turing:</strong> 1972</p>
                    <p>Pionier Ã®n informaticÄƒ teoreticÄƒ, cunoscut pentru:</p>
                    <ul>
                        <li>Algoritmul shortest path (1956)</li>
                        <li>Conceptul de "structured programming"</li>
                        <li>Algoritmul de excludere mutualÄƒ (semafoare)</li>
                        <li>Problema "Dining Philosophers"</li>
                    </ul>
                    <blockquote>
                        "Simplicity is prerequisite for reliability."<br>
                        â€” E.W. Dijkstra
                    </blockquote>
                </div>
            </div>
        </div>

        <!-- Slide 5: Key Figure - Bellman -->
        <div class="slide" data-slide="5">
            <h2>ğŸ‘¤ Figura Cheie: Richard Bellman</h2>
            <div class="key-figure">
                <div class="photo-placeholder">
                    ğŸ“·<br>Bellman<br>(1920-1984)
                </div>
                <div class="bio">
                    <h3>Richard Ernest Bellman (1920-1984)</h3>
                    <p><strong>Èšara:</strong> SUA ğŸ‡ºğŸ‡¸ | <strong>Medalia IEEE:</strong> 1979</p>
                    <p>PÄƒrintele programÄƒrii dinamice, contribuÈ›ii majore:</p>
                    <ul>
                        <li>Principiul optimalitÄƒÈ›ii Bellman (1957)</li>
                        <li>EcuaÈ›ia Bellman (fundamentul RL)</li>
                        <li>Algoritmul Bellman-Ford (1958)</li>
                        <li>Termenul "dynamic programming"</li>
                    </ul>
                    <blockquote>
                        "An optimal policy has the property that whatever the initial state and initial decision are, the remaining decisions must constitute an optimal policy."<br>
                        â€” R. Bellman
                    </blockquote>
                </div>
            </div>
        </div>

        <!-- Slide 6: Problem Definition -->
        <div class="slide" data-slide="6">
            <h2>ğŸ“ Problema Drumului Minim</h2>
            <h3>Single-Source Shortest Path (SSSP)</h3>
            <p>Dat fiind un graf ponderat <span class="highlight">G = (V, E)</span> È™i un nod sursÄƒ <span class="highlight">s</span>, gÄƒsiÈ›i distanÈ›a minimÄƒ de la <span class="highlight">s</span> la toate celelalte noduri.</p>
            
            <div class="graph-ascii">
        Exemplu de graf ponderat:
        
              â”Œâ”€â”€â”€â”€(2)â”€â”€â”€â”€â”
              â”‚           â”‚
              â–¼           â–¼
            [A]â”€â”€â”€(1)â”€â”€â”€â–º[B]â”€â”€â”€(3)â”€â”€â”€â–º[D]
              â”‚           â”‚           â–²
              â”‚           â”‚           â”‚
             (4)         (2)         (1)
              â”‚           â”‚           â”‚
              â–¼           â–¼           â”‚
            [C]â”€â”€â”€â”€â”€â”€â”€â”€â”€(5)â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º[E]
            
        Drumul minim Aâ†’D: Aâ†’Bâ†’Eâ†’D (cost: 1+2+1=4)
        NU: Aâ†’Bâ†’D (cost: 1+3=4) - egal, dar ilustrativ
            </div>
        </div>

        <!-- Slide 7: Graph Representations -->
        <div class="slide" data-slide="7">
            <h2>ğŸ—‚ï¸ ReprezentÄƒri ale Grafului</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Matrice de AdiacenÈ›Äƒ</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Matrix representation</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">// Matrice VÃ—V
int adj[MAX_V][MAX_V];

// adj[i][j] = cost muchie iâ†’j
// adj[i][j] = INF dacÄƒ nu existÄƒ

// Complexitate spaÈ›ialÄƒ: O(VÂ²)
// Verificare muchie: O(1)
// Parcurgere vecini: O(V)</code></pre>
                    </div>
                    <p><span class="highlight-green">âœ“</span> Grafuri dense</p>
                    <p><span class="highlight-red">âœ—</span> Grafuri sparse</p>
                </div>
                <div class="column">
                    <h3>Liste de AdiacenÈ›Äƒ</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Adjacency list representation</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">typedef struct Edge {
    int dest;
    int weight;
    struct Edge* next;
} Edge;

Edge* adj[MAX_V];

// Complexitate spaÈ›ialÄƒ: O(V+E)
// Verificare muchie: O(degree)
// Parcurgere vecini: O(degree)</code></pre>
                    </div>
                    <p><span class="highlight-green">âœ“</span> Grafuri sparse</p>
                    <p><span class="highlight-green">âœ“</span> Majoritatea aplicaÈ›iilor</p>
                </div>
            </div>
        </div>

        <!-- Slide 8: Dijkstra Overview -->
        <div class="slide" data-slide="8">
            <h2>âš¡ Algoritmul Dijkstra - Prezentare GeneralÄƒ</h2>
            <div class="info-box tip">
                <h4>ğŸ¯ Caracteristici Fundamentale</h4>
                <ul>
                    <li><strong>Strategie:</strong> Greedy (lacom) â€” alege mereu nodul cu distanÈ›a minimÄƒ</li>
                    <li><strong>RestricÈ›ie:</strong> <span class="highlight-red">NU funcÈ›ioneazÄƒ cu muchii negative!</span></li>
                    <li><strong>Complexitate:</strong> <span class="complexity good">O((V+E) log V)</span> cu heap</li>
                    <li><strong>SpaÈ›iu:</strong> <span class="complexity good">O(V)</span></li>
                </ul>
            </div>
            <h3>Principiul de FuncÈ›ionare</h3>
            <ol class="algorithm-steps">
                <li>IniÈ›ializare: dist[s] = 0, dist[altele] = âˆ</li>
                <li>Extrage nodul cu distanÈ›a minimÄƒ din coada de prioritÄƒÈ›i</li>
                <li>RelaxeazÄƒ toate muchiile adiacente nodului extras</li>
                <li>RepetÄƒ pÃ¢nÄƒ cÃ¢nd coada e goalÄƒ sau toate nodurile sunt vizitate</li>
            </ol>
        </div>

        <!-- Slide 9: Dijkstra Pseudocode -->
        <div class="slide" data-slide="9">
            <h2>ğŸ“ Dijkstra - Pseudocod</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Algoritmul Dijkstra cu Priority Queue</span>
                    <span class="lang-badge">Pseudocod</span>
                </div>
                <pre><code class="language-plaintext">DIJKSTRA(G, sursa):
    // IniÈ›ializare
    pentru fiecare nod v Ã®n G:
        dist[v] â† âˆ
        prev[v] â† NULL
        visited[v] â† false
    
    dist[sursa] â† 0
    PQ â† min-heap gol
    PQ.insert(sursa, 0)
    
    // Procesare
    cÃ¢t timp PQ nu e gol:
        u â† PQ.extract_min()
        
        dacÄƒ visited[u]:
            continuÄƒ
        visited[u] â† true
        
        pentru fiecare vecin v al lui u:
            alt â† dist[u] + weight(u, v)
            dacÄƒ alt < dist[v]:
                dist[v] â† alt           // Relaxare
                prev[v] â† u
                PQ.insert(v, alt)       // sau decrease_key
    
    returneazÄƒ dist[], prev[]</code></pre>
            </div>
        </div>

        <!-- Slide 10: Dijkstra Implementation -->
        <div class="slide" data-slide="10">
            <h2>ğŸ’» Dijkstra - Implementare C (Structuri)</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Structuri de date pentru Dijkstra</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/* Nod Ã®n min-heap */
typedef struct {
    int node;        // ID-ul nodului
    int distance;    // DistanÈ›a curentÄƒ
} HeapNode;

/* Min-Heap pentru priority queue */
typedef struct {
    HeapNode* data;      // Array de noduri
    int* position;       // position[v] = index Ã®n heap
    int size;            // Dimensiune curentÄƒ
    int capacity;        // Capacitate maximÄƒ
} MinHeap;

/* Muchie Ã®n lista de adiacenÈ›Äƒ */
typedef struct Edge {
    int dest;            // Nodul destinaÈ›ie
    int weight;          // Costul muchiei
    struct Edge* next;   // UrmÄƒtoarea muchie
} Edge;

/* Graf cu liste de adiacenÈ›Äƒ */
typedef struct {
    int num_vertices;    // NumÄƒrul de noduri
    Edge** adj;          // Array de liste
} Graph;</code></pre>
            </div>
        </div>

        <!-- Slide 11: Dijkstra Min-Heap Operations -->
        <div class="slide" data-slide="11">
            <h2>ğŸ’» Dijkstra - OperaÈ›ii Min-Heap</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>OperaÈ›ii esenÈ›iale pentru heap</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/* Swap douÄƒ noduri Ã®n heap */
void heap_swap(MinHeap* h, int i, int j) {
    h->position[h->data[i].node] = j;
    h->position[h->data[j].node] = i;
    HeapNode temp = h->data[i];
    h->data[i] = h->data[j];
    h->data[j] = temp;
}

/* Heapify-up dupÄƒ inserare/decrease_key */
void heapify_up(MinHeap* h, int idx) {
    while (idx > 0) {
        int parent = (idx - 1) / 2;
        if (h->data[idx].distance < h->data[parent].distance) {
            heap_swap(h, idx, parent);
            idx = parent;
        } else break;
    }
}

/* Heapify-down dupÄƒ extract_min */
void heapify_down(MinHeap* h, int idx) {
    int smallest = idx;
    int left = 2 * idx + 1, right = 2 * idx + 2;
    
    if (left < h->size && h->data[left].distance < h->data[smallest].distance)
        smallest = left;
    if (right < h->size && h->data[right].distance < h->data[smallest].distance)
        smallest = right;
    
    if (smallest != idx) {
        heap_swap(h, idx, smallest);
        heapify_down(h, smallest);
    }
}</code></pre>
            </div>
        </div>

        <!-- Slide 12: Dijkstra Core Algorithm -->
        <div class="slide" data-slide="12">
            <h2>ğŸ’» Dijkstra - Algoritmul Principal</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>FuncÈ›ia Dijkstra completÄƒ</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void dijkstra(Graph* g, int source, int* dist, int* prev) {
    int V = g->num_vertices;
    MinHeap* pq = heap_create(V);
    bool* visited = calloc(V, sizeof(bool));
    
    // IniÈ›ializare
    for (int i = 0; i < V; i++) {
        dist[i] = INT_MAX;
        prev[i] = -1;
    }
    dist[source] = 0;
    heap_insert(pq, source, 0);
    
    while (pq->size > 0) {
        HeapNode min = heap_extract_min(pq);
        int u = min.node;
        
        if (visited[u]) continue;
        visited[u] = true;
        
        // Relaxare muchii
        for (Edge* e = g->adj[u]; e != NULL; e = e->next) {
            int v = e->dest;
            int new_dist = dist[u] + e->weight;
            
            if (new_dist < dist[v]) {
                dist[v] = new_dist;
                prev[v] = u;
                heap_insert(pq, v, new_dist);
            }
        }
    }
    free(visited);
    heap_free(pq);
}</code></pre>
            </div>
        </div>

        <!-- Slide 13: Dijkstra Visualization -->
        <div class="slide" data-slide="13">
            <h2>ğŸ¬ Dijkstra - ExecuÈ›ie Pas cu Pas</h2>
            <div class="graph-ascii">
Graf:                               ExecuÈ›ie de la nodul 0:
                                    
    â”Œâ”€â”€â”€(1)â”€â”€â”€â–º[1]                 Pas 0: dist = [0, âˆ, âˆ, âˆ, âˆ]
    â”‚          â”‚                           PQ = {(0,0)}
   [0]        (3)                  
    â”‚          â”‚                   Pas 1: Extract (0,0), vizitez 0
    â””â”€â”€â”€(4)â”€â”€â”€â–ºâ–¼                          dist = [0, 1, 4, âˆ, âˆ]
              [2]â”€â”€â”€(1)â”€â”€â–º[3]             PQ = {(1,1), (2,4)}
               â”‚          â”‚        
              (2)        (1)       Pas 2: Extract (1,1), vizitez 1
               â”‚          â”‚               dist = [0, 1, 4, 4, âˆ]
               â–¼          â–¼               PQ = {(2,4), (3,4)}
              [4]â—„â”€â”€â”€â”€â”€â”€â”€[3]       
                                   Pas 3: Extract (2,4), vizitez 2
LegendÄƒ:                                  dist = [0, 1, 4, 4, 6]
[X] = Nod X                               PQ = {(3,4), (4,6)}
(N) = Cost N                       
                                   Final: dist = [0, 1, 4, 4, 5]
            </div>
        </div>

        <!-- Slide 14: Why Dijkstra Fails -->
        <div class="slide" data-slide="14">
            <h2>âš ï¸ De Ce Dijkstra EÈ™ueazÄƒ cu Muchii Negative</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Exemplu Contraexemplu</h3>
                    <div class="graph-ascii">
    [A]â”€â”€â”€(1)â”€â”€â”€â–º[B]
      \           â”‚
       \         (-3)
        \         â”‚
        (2)       â–¼
          \     [C]
           \     â”‚
            \   (1)
             \   â”‚
              â–¼  â–¼
              [D]
                    </div>
                </div>
                <div class="column">
                    <h3>Ce Se ÃntÃ¢mplÄƒ?</h3>
                    <p>Dijkstra marcheazÄƒ B ca vizitat cÃ¢nd:</p>
                    <ul>
                        <li>dist[B] = 1 (via Aâ†’B)</li>
                        <li>Apoi viziteazÄƒ D cu dist[D] = 2</li>
                    </ul>
                    <p>Dar drumul corect este:</p>
                    <ul>
                        <li>A â†’ B â†’ C â†’ D</li>
                        <li>Cost: 1 + (-3) + 1 = <span class="highlight-red">-1</span></li>
                    </ul>
                    <div class="info-box danger">
                        <h4>âš ï¸ ProblemÄƒ FundamentalÄƒ</h4>
                        <p>Dijkstra presupune cÄƒ o datÄƒ ce un nod e marcat "finalizat", distanÈ›a sa nu mai poate scÄƒdea. Muchiile negative Ã®ncalcÄƒ aceastÄƒ presupunere!</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 15: Bellman-Ford Overview -->
        <div class="slide" data-slide="15">
            <h2>ğŸ”„ Algoritmul Bellman-Ford - Prezentare</h2>
            <div class="info-box info">
                <h4>ğŸ¯ Caracteristici Fundamentale</h4>
                <ul>
                    <li><strong>Strategie:</strong> Dynamic Programming â€” relaxare iterativÄƒ</li>
                    <li><strong>Avantaj:</strong> <span class="highlight-green">FuncÈ›ioneazÄƒ cu muchii negative!</span></li>
                    <li><strong>Bonus:</strong> DetecteazÄƒ cicluri negative</li>
                    <li><strong>Complexitate:</strong> <span class="complexity medium">O(V Ã— E)</span></li>
                </ul>
            </div>
            <h3>Principiul de FuncÈ›ionare</h3>
            <ol class="algorithm-steps">
                <li>IniÈ›ializare: dist[s] = 0, dist[altele] = âˆ</li>
                <li>RepetÄƒ de <span class="highlight">V-1</span> ori: relaxeazÄƒ TOATE muchiile</li>
                <li>VerificÄƒ cicluri negative: Ã®ncÄƒ o iteraÈ›ie de relaxare</li>
                <li>DacÄƒ vreo distanÈ›Äƒ scade la pasul 3 â†’ ciclu negativ!</li>
            </ol>
        </div>

        <!-- Slide 16: Bellman-Ford Pseudocode -->
        <div class="slide" data-slide="16">
            <h2>ğŸ“ Bellman-Ford - Pseudocod</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Algoritmul Bellman-Ford</span>
                    <span class="lang-badge">Pseudocod</span>
                </div>
                <pre><code class="language-plaintext">BELLMAN_FORD(G, sursa):
    // IniÈ›ializare
    pentru fiecare nod v Ã®n G:
        dist[v] â† âˆ
        prev[v] â† NULL
    dist[sursa] â† 0
    
    // Faza de relaxare: V-1 iteraÈ›ii
    pentru i de la 1 la |V| - 1:
        pentru fiecare muchie (u, v, w) Ã®n E:
            dacÄƒ dist[u] + w < dist[v]:
                dist[v] â† dist[u] + w
                prev[v] â† u
    
    // Detectare ciclu negativ: a V-a iteraÈ›ie
    pentru fiecare muchie (u, v, w) Ã®n E:
        dacÄƒ dist[u] + w < dist[v]:
            returneazÄƒ "CICLU NEGATIV DETECTAT!"
    
    returneazÄƒ dist[], prev[]</code></pre>
            </div>
            <div class="info-box tip">
                <h4>ğŸ’¡ De ce V-1 iteraÈ›ii?</h4>
                <p>Un drum simplu poate avea cel mult <span class="highlight">V-1</span> muchii. DupÄƒ V-1 relaxÄƒri, toate drumurile optime de aceastÄƒ lungime sunt gÄƒsite.</p>
            </div>
        </div>

        <!-- Slide 17: Bellman-Ford Implementation -->
        <div class="slide" data-slide="17">
            <h2>ğŸ’» Bellman-Ford - Implementare C</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Implementarea completÄƒ Bellman-Ford</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">typedef struct { int u, v, weight; } Edge;

typedef struct {
    int num_vertices, num_edges;
    Edge* edges;  // Array de muchii
} EdgeListGraph;

bool bellman_ford(EdgeListGraph* g, int source, int* dist, int* prev) {
    int V = g->num_vertices, E = g->num_edges;
    
    // IniÈ›ializare
    for (int i = 0; i < V; i++) {
        dist[i] = INT_MAX;
        prev[i] = -1;
    }
    dist[source] = 0;
    
    // V-1 iteraÈ›ii de relaxare
    for (int i = 0; i < V - 1; i++) {
        for (int j = 0; j < E; j++) {
            int u = g->edges[j].u, v = g->edges[j].v;
            int w = g->edges[j].weight;
            if (dist[u] != INT_MAX && dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                prev[v] = u;
            }
        }
    }
    
    // Detectare ciclu negativ
    for (int j = 0; j < E; j++) {
        int u = g->edges[j].u, v = g->edges[j].v;
        if (dist[u] != INT_MAX && dist[u] + g->edges[j].weight < dist[v])
            return false;  // Ciclu negativ!
    }
    return true;
}</code></pre>
            </div>
        </div>

        <!-- Slide 18: Bellman-Ford Visualization -->
        <div class="slide" data-slide="18">
            <h2>ğŸ¬ Bellman-Ford - ExecuÈ›ie Pas cu Pas</h2>
            <div class="graph-ascii">
Graf cu muchii negative:            ExecuÈ›ie de la nodul 0:
                                    
    [0]â”€â”€â”€(6)â”€â”€â”€â–º[1]               IniÈ›ial: dist = [0, âˆ, âˆ, âˆ]
     â”‚            â”‚                
    (7)         (-3)               IteraÈ›ia 1 (relaxÄƒm toate muchiile):
     â”‚            â”‚                  0â†’1: dist[1] = min(âˆ, 0+6) = 6
     â–¼            â–¼                  0â†’2: dist[2] = min(âˆ, 0+7) = 7
    [2]â”€â”€â”€(9)â”€â”€â”€â–º[3]                 1â†’3: dist[3] = min(âˆ, 6-3) = 3
     â”‚                               dist = [0, 6, 7, 3]
    (-2)                           
     â”‚                             IteraÈ›ia 2:
     â–¼                               2â†’1: dist[1] = min(6, 7-2) = 5  â† ÃmbunÄƒtÄƒÈ›it!
    [1] (alt drum)                   dist = [0, 5, 7, 3]
                                   
Muchii: (0,1,6), (0,2,7),          IteraÈ›ia 3:
        (1,3,-3), (2,1,-2),          1â†’3: dist[3] = min(3, 5-3) = 2  â† ÃmbunÄƒtÄƒÈ›it!
        (2,3,9)                      dist = [0, 5, 7, 2]
            </div>
        </div>

        <!-- Slide 19: Negative Cycle Detection -->
        <div class="slide" data-slide="19">
            <h2>ğŸ” Detectarea Ciclurilor Negative</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Ce este un Ciclu Negativ?</h3>
                    <div class="graph-ascii">
    [A]â”€â”€â”€(2)â”€â”€â”€â–º[B]
     â–²            â”‚
     â”‚           (-5)
    (1)           â”‚
     â”‚            â–¼
    [D]â—„â”€â”€(1)â”€â”€â”€[C]
    
    Ciclu: B â†’ C â†’ D â†’ A â†’ B
    Cost: -5 + 1 + 1 + 2 = -1
    
    ParcurgÃ¢nd repetat ciclul,
    costul scade la -âˆ!
                    </div>
                </div>
                <div class="column">
                    <h3>Implementare DetecÈ›ie</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Detectare È™i marcare</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">// DupÄƒ V-1 iteraÈ›ii
for (int j = 0; j < E; j++) {
    int u = edges[j].u;
    int v = edges[j].v;
    int w = edges[j].weight;
    
    // DacÄƒ mai putem relaxa
    if (dist[u] != INT_MAX && 
        dist[u] + w < dist[v]) {
        // v e pe un ciclu negativ
        dist[v] = NEG_INF;
        in_negative_cycle[v] = true;
    }
}</code></pre>
                    </div>
                </div>
            </div>
            <div class="info-box danger">
                <h4>âš ï¸ AtenÈ›ie!</h4>
                <p>Ciclurile negative fac problema drumului minim <strong>nedefinitÄƒ</strong> â€” poÈ›i obÈ›ine costuri arbitrar de mici!</p>
            </div>
        </div>

        <!-- Slide 20: Comparison Table -->
        <div class="slide" data-slide="20">
            <h2>ğŸ“Š ComparaÈ›ie: Dijkstra vs Bellman-Ford</h2>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Criteriu</th>
                        <th>Dijkstra</th>
                        <th>Bellman-Ford</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Complexitate Timp</strong></td>
                        <td><span class="complexity good">O((V+E) log V)</span></td>
                        <td><span class="complexity medium">O(V Ã— E)</span></td>
                    </tr>
                    <tr>
                        <td><strong>Complexitate SpaÈ›iu</strong></td>
                        <td><span class="complexity good">O(V)</span></td>
                        <td><span class="complexity good">O(V)</span></td>
                    </tr>
                    <tr>
                        <td><strong>Muchii Negative</strong></td>
                        <td><span class="highlight-red">âœ— NU</span></td>
                        <td><span class="highlight-green">âœ“ DA</span></td>
                    </tr>
                    <tr>
                        <td><strong>Cicluri Negative</strong></td>
                        <td><span class="highlight-red">âœ— Nedefinit</span></td>
                        <td><span class="highlight-green">âœ“ DetecteazÄƒ</span></td>
                    </tr>
                    <tr>
                        <td><strong>Grafuri Dense</strong></td>
                        <td><span class="highlight-green">âœ“ Eficient</span></td>
                        <td><span class="highlight-red">âœ— Lent</span></td>
                    </tr>
                    <tr>
                        <td><strong>Grafuri Sparse</strong></td>
                        <td><span class="highlight-green">âœ“ Foarte eficient</span></td>
                        <td><span class="highlight">â—‹ Acceptabil</span></td>
                    </tr>
                    <tr>
                        <td><strong>Strategie</strong></td>
                        <td>Greedy</td>
                        <td>Dynamic Programming</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Slide 21: Path Reconstruction -->
        <div class="slide" data-slide="21">
            <h2>ğŸ›¤ï¸ ReconstrucÈ›ia Drumului</h2>
            <p>Ambii algoritmi folosesc array-ul <span class="highlight">prev[]</span> pentru a reconstrui drumul:</p>
            <div class="code-block">
                <div class="code-header">
                    <span>FuncÈ›ie de reconstrucÈ›ie a drumului</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void print_path(int* prev, int dest) {
    if (prev[dest] == -1) {
        printf("%d", dest);
        return;
    }
    print_path(prev, prev[dest]);  // Recursiv pÃ¢nÄƒ la sursÄƒ
    printf(" â†’ %d", dest);
}

// Sau iterativ cu stack:
void print_path_iterative(int* prev, int source, int dest) {
    int path[MAX_V], len = 0;
    
    for (int v = dest; v != -1; v = prev[v])
        path[len++] = v;
    
    printf("Drum: ");
    for (int i = len - 1; i >= 0; i--) {
        printf("%d", path[i]);
        if (i > 0) printf(" â†’ ");
    }
    printf("\n");
}

// Apel:
// print_path_iterative(prev, source, dest);
// Output: Drum: 0 â†’ 2 â†’ 4 â†’ 5</code></pre>
            </div>
        </div>

        <!-- Slide 22: Industrial Application - OSPF -->
        <div class="slide" data-slide="22">
            <h2>ğŸ­ AplicaÈ›ie IndustrialÄƒ: OSPF Routing</h2>
            <div class="info-box tip">
                <h4>ğŸŒ Open Shortest Path First (OSPF)</h4>
                <p>Protocol de rutare folosit Ã®n reÈ›ele enterprise È™i Internet, bazat pe algoritmul Dijkstra.</p>
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>Simulare OSPF simplificatÄƒ</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">// Topologie de routere
typedef struct {
    char name[32];
    int bandwidth;      // Mbps
    int delay;          // ms
} Router;

// Cost OSPF = 100M / bandwidth
int ospf_cost(int bandwidth_mbps) {
    return 100000000 / (bandwidth_mbps * 1000000);
}

// Exemplu: ReÈ›ea corporate
// R1 ----1Gbps---- R2 ----100Mbps---- R3
// |                                    |
// 10Mbps                            10Mbps
// |                                    |
// R4 ----------100Mbps--------------- R5

// Costurile OSPF:
// R1-R2: 100M/1000M = 0.1 â‰ˆ 1
// R2-R3: 100M/100M = 1
// R1-R4: 100M/10M = 10
// Dijkstra alege calea cu cost minim!</code></pre>
            </div>
        </div>

        <!-- Slide 23: Industrial Application - GPS -->
        <div class="slide" data-slide="23">
            <h2>ğŸ­ AplicaÈ›ie IndustrialÄƒ: NavigaÈ›ie GPS</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Modelul Grafului</h3>
                    <ul>
                        <li><strong>Noduri:</strong> IntersecÈ›ii</li>
                        <li><strong>Muchii:</strong> Segmente de drum</li>
                        <li><strong>Costuri:</strong> Timp/distanÈ›Äƒ</li>
                    </ul>
                    <div class="info-box info">
                        <h4>ğŸ“ Google Maps</h4>
                        <p>FoloseÈ™te variante optimizate ale Dijkstra cu heuristici (A*) È™i precalculare (Contraction Hierarchies).</p>
                    </div>
                </div>
                <div class="column">
                    <div class="code-block">
                        <div class="code-header">
                            <span>Model nod GPS</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">typedef struct {
    int id;
    double lat, lon;     // Coordonate
    char name[64];       // "PiaÈ›a Unirii"
} Intersection;

typedef struct {
    int from, to;
    double distance_km;
    double time_min;     // Cu trafic
    int speed_limit;
    bool is_highway;
} RoadSegment;

// Dijkstra cu timp estimat
// sau cu distanÈ›Äƒ pentru
// "shortest distance"</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 24: Industrial Application - Networks -->
        <div class="slide" data-slide="24">
            <h2>ğŸ­ AplicaÈ›ie: ReÈ›ele Sociale & RecomandÄƒri</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Gradul de separare Ã®n reÈ›ele sociale</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">// "Six Degrees of Separation"
// GÄƒseÈ™te conexiunea minimÄƒ Ã®ntre doi utilizatori

typedef struct {
    int user_id;
    char name[64];
    int* friends;        // Lista de prieteni
    int num_friends;
} User;

// Pentru reÈ›ele sociale neponderate, BFS e suficient
// Dar pentru "weighted" connections:

typedef struct {
    int user_id;
    float connection_strength;  // 0.0 - 1.0
    // bazat pe: mesaje, like-uri, timp petrecut
} Connection;

// Cost = 1.0 - connection_strength
// Dijkstra gÄƒseÈ™te "cel mai puternic lanÈ› de conexiuni"

// AplicaÈ›ii:
// - LinkedIn: "How you're connected"
// - Facebook: Sugestii de prieteni
// - Research: Collaboration networks</code></pre>
            </div>
        </div>

        <!-- Slide 25: Common Mistakes -->
        <div class="slide" data-slide="25">
            <h2>âš ï¸ GreÈ™eli Frecvente</h2>
            <div class="two-columns">
                <div class="column">
                    <div class="info-box danger">
                        <h4>âŒ GreÈ™eala #1: Dijkstra cu muchii negative</h4>
                        <pre style="background: var(--bg-tertiary); padding: 10px; border-radius: 4px; margin-top: 10px;"><code>// GREÈ˜IT: Dijkstra pe graf cu costuri negative
graph_add_edge(g, 0, 1, -5);  // PERICOL!
dijkstra(g, 0, dist, prev);   // Rezultat INCORECT!</code></pre>
                    </div>
                    <div class="info-box danger">
                        <h4>âŒ GreÈ™eala #2: Overflow la iniÈ›ializare</h4>
                        <pre style="background: var(--bg-tertiary); padding: 10px; border-radius: 4px; margin-top: 10px;"><code>// GREÈ˜IT:
dist[i] = INT_MAX;
if (dist[u] + weight < dist[v])  // Overflow!

// CORECT:
if (dist[u] != INT_MAX && 
    dist[u] + weight < dist[v])</code></pre>
                    </div>
                </div>
                <div class="column">
                    <div class="info-box danger">
                        <h4>âŒ GreÈ™eala #3: Uitarea visited check</h4>
                        <pre style="background: var(--bg-tertiary); padding: 10px; border-radius: 4px; margin-top: 10px;"><code>// GREÈ˜IT: Procesare repetatÄƒ
HeapNode min = extract_min(pq);
// Procesare directÄƒ

// CORECT:
HeapNode min = extract_min(pq);
if (visited[min.node]) continue;
visited[min.node] = true;</code></pre>
                    </div>
                    <div class="info-box danger">
                        <h4>âŒ GreÈ™eala #4: Bellman-Ford insuficiente iteraÈ›ii</h4>
                        <pre style="background: var(--bg-tertiary); padding: 10px; border-radius: 4px; margin-top: 10px;"><code>// GREÈ˜IT:
for (int i = 0; i < V; i++)  // O iteraÈ›ie Ã®n plus!

// CORECT:
for (int i = 0; i < V - 1; i++)</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 26: Memory Model -->
        <div class="slide" data-slide="26">
            <h2>ğŸ§  Modelul de Memorie</h2>
            <div class="graph-ascii">
STACK                              HEAP
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ main()          â”‚               â”‚                                   â”‚
â”‚  â”œâ”€ dist[]      â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ [0, 3, 5, 7, 2, ...]              â”‚
â”‚  â”œâ”€ prev[]      â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ [-1, 0, 1, 1, 2, ...]             â”‚
â”‚  â””â”€ graph*      â”‚â”€â”€â”€â”€â”          â”‚                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ dijkstra()      â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ Graph {                           â”‚
â”‚  â”œâ”€ pq*         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚   num_vertices: 5                 â”‚
â”‚  â”œâ”€ visited[]   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚   adj[] â”€â”€â–º[Edge*,Edge*,...]      â”‚
â”‚  â””â”€ locals      â”‚               â”‚ }                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤               â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ heapify_down()  â”‚               â”‚ MinHeap {                         â”‚
â”‚  â””â”€ locals      â”‚               â”‚   data[] â”€â”€â–º[{0,0},{1,3},{2,5}]   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚   position[] â”€â”€â–º[0,1,2,-1,-1]     â”‚
                                  â”‚   size: 3, capacity: 5            â”‚
                                  â”‚ }                                 â”‚
                                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

AtenÈ›ie la:
â€¢ Eliberarea heap-ului dupÄƒ fiecare dijkstra()
â€¢ Array-urile prev[] È™i dist[] alocate de apelant
â€¢ Liste de adiacenÈ›Äƒ: malloc pentru fiecare Edge
            </div>
        </div>

        <!-- Slide 27: Debugging with GDB -->
        <div class="slide" data-slide="27">
            <h2>ğŸ”§ Debugging cu GDB</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Comenzi GDB utile pentru debugging grafuri</span>
                    <span class="lang-badge">Bash</span>
                </div>
                <pre><code class="language-bash"># Compilare cu simboluri de debug
$ gcc -g -Wall -o dijkstra dijkstra.c

# Pornire GDB
$ gdb ./dijkstra

# Breakpoint la funcÈ›ia dijkstra
(gdb) break dijkstra
(gdb) run

# Inspectare distanÈ›e
(gdb) print dist[0]@5          # Primele 5 elemente
(gdb) print *pq                # Structura heap
(gdb) print pq->data[0]@3      # Primele 3 noduri din heap

# Watchpoint pentru schimbÄƒri
(gdb) watch dist[3]            # OpreÈ™te cÃ¢nd dist[3] se schimbÄƒ

# Parcurgere pas cu pas
(gdb) next                     # UrmÄƒtoarea linie
(gdb) step                     # IntrÄƒ Ã®n funcÈ›ie

# AfiÈ™are lista de adiacenÈ›Äƒ
(gdb) print *g->adj[0]         # Prima muchie de la nodul 0
(gdb) print g->adj[0]->next    # A doua muchie</code></pre>
            </div>
        </div>

        <!-- Slide 28: Valgrind Memory Check -->
        <div class="slide" data-slide="28">
            <h2>ğŸ”§ Verificare Memorie cu Valgrind</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Comenzi Valgrind esenÈ›iale</span>
                    <span class="lang-badge">Bash</span>
                </div>
                <pre><code class="language-bash"># Verificare memory leaks de bazÄƒ
$ valgrind --leak-check=full ./dijkstra

# Output exemplu pentru cod CORECT:
# ==12345== HEAP SUMMARY:
# ==12345==     in use at exit: 0 bytes in 0 blocks
# ==12345==   total heap usage: 127 allocs, 127 frees
# ==12345== All heap blocks were freed -- no leaks are possible

# Output pentru cod cu MEMORY LEAK:
# ==12345== LEAK SUMMARY:
# ==12345==    definitely lost: 40 bytes in 1 blocks
# ==12345==    indirectly lost: 320 bytes in 8 blocks

# Verificare È™i accesÄƒri invalide
$ valgrind --leak-check=full --show-leak-kinds=all \
           --track-origins=yes ./dijkstra

# Cele mai frecvente erori:
# - "Invalid read of size 4" â†’ Acces Ã®n afara array-ului
# - "Use of uninitialised value" â†’ VariabilÄƒ neiniÈ›ializatÄƒ
# - "definitely lost" â†’ Memorie nealocatÄƒ (free lipsÄƒ)</code></pre>
            </div>
        </div>

        <!-- Slide 29: Best Practices -->
        <div class="slide" data-slide="29">
            <h2>âœ… Best Practices</h2>
            <div class="two-columns">
                <div class="column" style="border-left: 4px solid var(--accent-green);">
                    <h3 style="color: var(--accent-green);">âœ“ DO</h3>
                    <ul>
                        <li>VerificÄƒ dacÄƒ graful are muchii negative Ã®nainte de Dijkstra</li>
                        <li>FoloseÈ™te <code>INT_MAX/2</code> ca infinit pentru a evita overflow</li>
                        <li>ImplementeazÄƒ decrease_key pentru heap optim</li>
                        <li>ValideazÄƒ input-ul (noduri valide, costuri finite)</li>
                        <li>ElibereazÄƒ TOATÄ‚ memoria alocatÄƒ</li>
                        <li>DocumenteazÄƒ complexitatea algoritmului ales</li>
                    </ul>
                </div>
                <div class="column" style="border-left: 4px solid var(--accent-red);">
                    <h3 style="color: var(--accent-red);">âœ— DON'T</h3>
                    <ul>
                        <li>NU folosi Dijkstra dacÄƒ existÄƒ muchii negative</li>
                        <li>NU ignora verificarea pentru cicluri negative</li>
                        <li>NU uita sÄƒ iniÈ›ializezi dist[] cu infinit</li>
                        <li>NU amesteca index 0-based È™i 1-based</li>
                        <li>NU presupune cÄƒ graful e conex</li>
                        <li>NU hardcoda dimensiunile â€” foloseÈ™te constante</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 30: Complexity Analysis Deep Dive -->
        <div class="slide" data-slide="30">
            <h2>ğŸ“ˆ AnalizÄƒ DetaliatÄƒ a ComplexitÄƒÈ›ii</h2>
            <h3>Dijkstra cu Min-Heap Binar</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>OperaÈ›ie</th>
                        <th>Complexitate</th>
                        <th>NumÄƒr Apeluri</th>
                        <th>Total</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>extract_min</td>
                        <td>O(log V)</td>
                        <td>V</td>
                        <td>O(V log V)</td>
                    </tr>
                    <tr>
                        <td>insert / decrease_key</td>
                        <td>O(log V)</td>
                        <td>E (worst case)</td>
                        <td>O(E log V)</td>
                    </tr>
                    <tr>
                        <td><strong>TOTAL</strong></td>
                        <td colspan="3"><span class="complexity good">O((V + E) log V)</span></td>
                    </tr>
                </tbody>
            </table>
            <h3>Bellman-Ford</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Faza</th>
                        <th>OperaÈ›ii</th>
                        <th>Total</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Relaxare</td>
                        <td>(V-1) iteraÈ›ii Ã— E muchii</td>
                        <td>O(V Ã— E)</td>
                    </tr>
                    <tr>
                        <td>Detectare ciclu</td>
                        <td>1 iteraÈ›ie Ã— E muchii</td>
                        <td>O(E)</td>
                    </tr>
                    <tr>
                        <td><strong>TOTAL</strong></td>
                        <td colspan="2"><span class="complexity medium">O(V Ã— E)</span></td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Slide 31: Optimizations -->
        <div class="slide" data-slide="31">
            <h2>ğŸš€ OptimizÄƒri Avansate</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Dijkstra</h3>
                    <ul>
                        <li><strong>Fibonacci Heap:</strong> O(E + V log V)</li>
                        <li><strong>Bidirectional Dijkstra:</strong> CÄƒutare din ambele capete</li>
                        <li><strong>A* Algorithm:</strong> Dijkstra + euristicÄƒ</li>
                        <li><strong>Contraction Hierarchies:</strong> Precalculare pentru rutare</li>
                    </ul>
                    <div class="code-block">
                        <div class="code-header">
                            <span>A* Heuristic</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">// f(n) = g(n) + h(n)
// g(n) = cost real de la start
// h(n) = euristicÄƒ (ex: distanÈ›Äƒ EuclidianÄƒ)

double h(Node* n, Node* goal) {
    double dx = n->x - goal->x;
    double dy = n->y - goal->y;
    return sqrt(dx*dx + dy*dy);
}</code></pre>
                    </div>
                </div>
                <div class="column">
                    <h3>Bellman-Ford</h3>
                    <ul>
                        <li><strong>SPFA:</strong> Shortest Path Faster Algorithm</li>
                        <li><strong>Early termination:</strong> Oprire dacÄƒ nu s-a schimbat nimic</li>
                        <li><strong>Queue-based:</strong> Procesare doar noduri modificate</li>
                    </ul>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Early Termination</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">for (int i = 0; i < V - 1; i++) {
    bool changed = false;
    for (int j = 0; j < E; j++) {
        if (relax(edges[j]))
            changed = true;
    }
    if (!changed) break;  // Optim!
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 32: Algorithm Selection Guide -->
        <div class="slide" data-slide="32">
            <h2>ğŸ¯ Ghid de SelecÈ›ie a Algoritmului</h2>
            <div class="graph-ascii">
                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                         â”‚ Ai muchii cu cost negativ?  â”‚
                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                       â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ NU               â”‚                   â”‚ DA
                    â–¼                  â”‚                   â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Dijkstra            â”‚        â”‚     â”‚ Trebuie detectat    â”‚
        â”‚ O((V+E) log V)      â”‚        â”‚     â”‚ ciclu negativ?      â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                       â”‚                â”‚
                                       â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                       â”‚     â”‚ DA       â”‚          â”‚ NU
                                       â”‚     â–¼          â”‚          â–¼
                                       â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                       â”‚  â”‚Bellman-  â”‚  â”‚  â”‚ SPFA sau     â”‚
                                       â”‚  â”‚Ford      â”‚  â”‚  â”‚ Bellman-Ford â”‚
                                       â”‚  â”‚O(V Ã— E)  â”‚  â”‚  â”‚ optimizat    â”‚
                                       â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                       â”‚                â”‚
                                       â”‚     Grafuri foarte mari?
                                       â”‚                â”‚
                                       â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                       â”‚     â”‚ DA       â”‚          â”‚ NU
                                       â”‚     â–¼          â”‚          â”‚
                                       â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚          â”‚
                                       â”‚  â”‚ A* sau   â”‚  â”‚          â”‚
                                       â”‚  â”‚ CHs      â”‚  â”‚          â”‚
                                       â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚          â”‚
            </div>
        </div>

        <!-- Slide 33: Exercise Preview 1 -->
        <div class="slide" data-slide="33">
            <h2>ğŸ’» ExerciÈ›iul 1: Implementare Dijkstra</h2>
            <div class="info-box info">
                <h4>ğŸ“‹ Obiectiv</h4>
                <p>ImplementaÈ›i algoritmul Dijkstra complet, cu min-heap È™i reconstrucÈ›ia drumului.</p>
            </div>
            <h3>CerinÈ›e:</h3>
            <ol>
                <li>DefiniÈ›i structurile <code>HeapNode</code> È™i <code>MinHeap</code></li>
                <li>ImplementaÈ›i <code>heap_create</code>, <code>heapify_up</code>, <code>heapify_down</code></li>
                <li>ImplementaÈ›i <code>heap_insert</code>, <code>heap_extract_min</code>, <code>heap_decrease_key</code></li>
                <li>ImplementaÈ›i funcÈ›ia <code>dijkstra()</code> principalÄƒ</li>
                <li>ImplementaÈ›i <code>print_path()</code> pentru afiÈ™area drumului</li>
            </ol>
            <div class="code-block">
                <div class="code-header">
                    <span>Format Input</span>
                    <span class="lang-badge">Text</span>
                </div>
                <pre><code>5 7 0        // N noduri, M muchii, S sursÄƒ
0 1 10       // muchie: U V cost
0 2 5
1 2 2
...</code></pre>
            </div>
        </div>

        <!-- Slide 34: Exercise Preview 2 -->
        <div class="slide" data-slide="34">
            <h2>ğŸ’» ExerciÈ›iul 2: Implementare Bellman-Ford</h2>
            <div class="info-box info">
                <h4>ğŸ“‹ Obiectiv</h4>
                <p>ImplementaÈ›i algoritmul Bellman-Ford cu detectare de cicluri negative È™i propagare.</p>
            </div>
            <h3>CerinÈ›e:</h3>
            <ol>
                <li>DefiniÈ›i structurile <code>Edge</code>, <code>Graph</code> (edge list)</li>
                <li>ImplementaÈ›i funcÈ›iile de creare È™i adÄƒugare muchii</li>
                <li>ImplementaÈ›i faza de relaxare (V-1 iteraÈ›ii)</li>
                <li>ImplementaÈ›i detectarea ciclurilor negative</li>
                <li>MarcaÈ›i toate nodurile afectate de cicluri negative cu <code>-INF</code></li>
                <li>AfiÈ™aÈ›i rezultatele cu distanÈ›e È™i drumuri</li>
            </ol>
            <div class="info-box warning">
                <h4>âš ï¸ Bonus Challenge</h4>
                <p>ImplementaÈ›i gÄƒsirea È™i afiÈ™area efectivÄƒ a unui ciclu negativ!</p>
            </div>
        </div>

        <!-- Slide 35: Key Takeaways -->
        <div class="slide" data-slide="35">
            <h2>ğŸ“Œ Concluzii Cheie</h2>
            <div class="summary-grid">
                <div class="summary-item">
                    <div class="icon">âš¡</div>
                    <h4>Dijkstra</h4>
                    <p>Greedy, rapid, dar fÄƒrÄƒ muchii negative</p>
                </div>
                <div class="summary-item">
                    <div class="icon">ğŸ”„</div>
                    <h4>Bellman-Ford</h4>
                    <p>DP, versatil, detecteazÄƒ cicluri</p>
                </div>
                <div class="summary-item">
                    <div class="icon">ğŸ“Š</div>
                    <h4>Complexitate</h4>
                    <p>O((V+E)logV) vs O(VÃ—E)</p>
                </div>
                <div class="summary-item">
                    <div class="icon">ğŸ¯</div>
                    <h4>Min-Heap</h4>
                    <p>EsenÈ›ial pentru Dijkstra eficient</p>
                </div>
                <div class="summary-item">
                    <div class="icon">ğŸ›¤ï¸</div>
                    <h4>prev[]</h4>
                    <p>Array pentru reconstrucÈ›ie drum</p>
                </div>
                <div class="summary-item">
                    <div class="icon">âš ï¸</div>
                    <h4>Cicluri Negative</h4>
                    <p>Fac problema nedefinitÄƒ!</p>
                </div>
            </div>
        </div>

        <!-- Slide 36: Resources -->
        <div class="slide" data-slide="36">
            <h2>ğŸ“š Resurse Recomandate</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>ğŸ“– CÄƒrÈ›i EsenÈ›iale</h3>
                    <ul>
                        <li><strong>CLRS</strong> - "Introduction to Algorithms", Cap. 24</li>
                        <li><strong>Sedgewick</strong> - "Algorithms", Cap. 4.4</li>
                        <li><strong>Skiena</strong> - "Algorithm Design Manual", Cap. 6</li>
                    </ul>
                    <h3>ğŸŒ Resurse Online</h3>
                    <ul>
                        <li>Visualgo.net - Vizualizare interactivÄƒ</li>
                        <li>CP-Algorithms.com - ImplementÄƒri detaliate</li>
                        <li>GeeksforGeeks - Exemple È™i exerciÈ›ii</li>
                    </ul>
                </div>
                <div class="column">
                    <h3>ğŸ¬ Video Tutoriale</h3>
                    <ul>
                        <li>MIT OpenCourseWare - Lecture 16</li>
                        <li>Abdul Bari - Dijkstra & Bellman-Ford</li>
                        <li>WilliamFiset - Graph Theory Playlist</li>
                    </ul>
                    <h3>ğŸ’» PracticÄƒ</h3>
                    <ul>
                        <li>LeetCode: #743, #787, #1514</li>
                        <li>Codeforces: Div2 C/D problems</li>
                        <li>CSES Problem Set: Shortest Routes</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 37: Questions -->
        <div class="slide title-slide" data-slide="37">
            <h1>â“ ÃntrebÄƒri?</h1>
            <div class="subtitle">Suntem aici pentru clarificÄƒri!</div>
            <div style="margin-top: 50px; padding: 30px; background: var(--bg-secondary); border-radius: 12px; display: inline-block;">
                <p style="color: var(--text-secondary); margin-bottom: 20px;">SÄƒptÄƒmÃ¢na viitoare:</p>
                <h3 style="color: var(--accent-purple);">ğŸ“Š SÄƒptÄƒmÃ¢na 14: Recapitulare È™i OptimizÄƒri</h3>
                <p>SintezÄƒ a tuturor algoritmilor, tehnici avansate, pregÄƒtire pentru examen</p>
            </div>
            <div style="margin-top: 40px;">
                <p>Navigare: <kbd>â†</kbd> <kbd>â†’</kbd> <kbd>Home</kbd> <kbd>End</kbd> <kbd>Space</kbd></p>
            </div>
        </div>

    </div>

    <script>
        // Initialize highlight.js
        hljs.highlightAll();

        // Slide navigation
        let currentSlide = 1;
        const totalSlides = document.querySelectorAll('.slide').length;
        document.getElementById('totalSlides').textContent = totalSlides;

        function showSlide(n) {
            const slides = document.querySelectorAll('.slide');
            
            if (n < 1) n = 1;
            if (n > totalSlides) n = totalSlides;
            
            currentSlide = n;
            
            slides.forEach((slide, index) => {
                slide.classList.remove('active');
                if (index === currentSlide - 1) {
                    slide.classList.add('active');
                }
            });
            
            // Update counter
            document.getElementById('currentSlide').textContent = currentSlide;
            
            // Update progress bar
            const progress = (currentSlide / totalSlides) * 100;
            document.getElementById('progressBar').style.width = progress + '%';
            
            // Update button states
            document.getElementById('prevBtn').disabled = currentSlide === 1;
            document.getElementById('nextBtn').disabled = currentSlide === totalSlides;
        }

        function changeSlide(direction) {
            showSlide(currentSlide + direction);
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowRight':
                case ' ':
                    e.preventDefault();
                    changeSlide(1);
                    break;
                case 'ArrowLeft':
                    changeSlide(-1);
                    break;
                case 'Home':
                    showSlide(1);
                    break;
                case 'End':
                    showSlide(totalSlides);
                    break;
            }
        });

        // Touch support for mobile
        let touchStartX = 0;
        document.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
        });

        document.addEventListener('touchend', (e) => {
            const touchEndX = e.changedTouches[0].clientX;
            const diff = touchStartX - touchEndX;
            
            if (Math.abs(diff) > 50) {
                if (diff > 0) changeSlide(1);
                else changeSlide(-1);
            }
        });

        // Initialize first slide
        showSlide(1);
    </script>
</body>
</html>
