<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SÄƒptÄƒmÃ¢na 11: Tabele de Dispersie (Hash Tables) | ATP</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-yellow: #d29922;
            --accent-red: #f85149;
            --accent-purple: #a371f7;
            --accent-orange: #f0883e;
            --border-color: #30363d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        /* Progress Bar */
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            transition: width 0.3s ease;
            z-index: 1000;
        }

        /* Slide Container */
        .slides-container {
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 60px 80px;
            display: none;
            opacity: 0;
            transition: opacity 0.5s ease;
            overflow-y: auto;
        }

        .slide.active {
            display: block;
            opacity: 1;
        }

        /* Typography */
        h1 {
            font-size: 2.8em;
            margin-bottom: 30px;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        h2 {
            font-size: 2.2em;
            margin-bottom: 25px;
            color: var(--accent-blue);
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 10px;
        }

        h3 {
            font-size: 1.6em;
            margin: 20px 0 15px;
            color: var(--accent-green);
        }

        h4 {
            font-size: 1.3em;
            margin: 15px 0 10px;
            color: var(--accent-yellow);
        }

        p {
            font-size: 1.2em;
            line-height: 1.7;
            margin-bottom: 15px;
            color: var(--text-primary);
        }

        /* Lists */
        ul, ol {
            font-size: 1.15em;
            line-height: 1.8;
            margin-left: 30px;
            margin-bottom: 20px;
        }

        li {
            margin-bottom: 10px;
        }

        li::marker {
            color: var(--accent-blue);
        }

        /* Code Blocks */
        .code-block {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin: 20px 0;
            overflow: hidden;
        }

        .code-header {
            background: var(--bg-tertiary);
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
        }

        .code-header span:first-child {
            color: var(--text-secondary);
            font-size: 0.9em;
        }

        .lang-badge {
            background: var(--accent-blue);
            color: var(--bg-primary);
            padding: 2px 10px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .code-block pre {
            margin: 0;
            padding: 20px;
            overflow-x: auto;
        }

        .code-block code {
            font-family: 'Fira Code', 'JetBrains Mono', 'Consolas', monospace;
            font-size: 0.95em;
            line-height: 1.5;
        }

        /* Inline Code */
        code:not([class*="language-"]) {
            background: var(--bg-tertiary);
            padding: 2px 8px;
            border-radius: 4px;
            font-family: 'Fira Code', monospace;
            font-size: 0.9em;
            color: var(--accent-orange);
        }

        /* Info Boxes */
        .info-box {
            padding: 20px 25px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid;
        }

        .info-box.tip {
            background: rgba(63, 185, 80, 0.1);
            border-color: var(--accent-green);
        }

        .info-box.warning {
            background: rgba(210, 153, 34, 0.1);
            border-color: var(--accent-yellow);
        }

        .info-box.danger {
            background: rgba(248, 81, 73, 0.1);
            border-color: var(--accent-red);
        }

        .info-box.info {
            background: rgba(88, 166, 255, 0.1);
            border-color: var(--accent-blue);
        }

        .info-box-title {
            font-weight: bold;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .info-box.tip .info-box-title { color: var(--accent-green); }
        .info-box.warning .info-box-title { color: var(--accent-yellow); }
        .info-box.danger .info-box-title { color: var(--accent-red); }
        .info-box.info .info-box-title { color: var(--accent-blue); }

        /* Two Column Layout */
        .two-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 20px 0;
        }

        .column {
            background: var(--bg-secondary);
            padding: 25px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        /* ASCII Art Box */
        .ascii-box {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Fira Code', monospace;
            font-size: 0.85em;
            line-height: 1.4;
            white-space: pre;
            overflow-x: auto;
            color: var(--accent-green);
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 1em;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border: 1px solid var(--border-color);
        }

        th {
            background: var(--bg-tertiary);
            color: var(--accent-blue);
            font-weight: 600;
        }

        tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Quote Box */
        .quote-box {
            background: var(--bg-secondary);
            border-left: 4px solid var(--accent-purple);
            padding: 25px 30px;
            margin: 25px 0;
            border-radius: 0 8px 8px 0;
            font-style: italic;
            font-size: 1.2em;
        }

        .quote-author {
            color: var(--accent-purple);
            margin-top: 15px;
            font-style: normal;
            font-weight: bold;
        }

        /* Navigation */
        .nav-container {
            position: fixed;
            bottom: 20px;
            right: 30px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .nav-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.2s;
        }

        .nav-btn:hover {
            background: var(--accent-blue);
            color: var(--bg-primary);
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Slide Counter */
        .slide-counter {
            position: fixed;
            bottom: 25px;
            left: 30px;
            font-size: 1em;
            color: var(--text-secondary);
            z-index: 100;
        }

        /* Title Slide Special Styling */
        .title-slide {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            height: 100%;
        }

        .title-slide h1 {
            font-size: 3.5em;
            margin-bottom: 20px;
        }

        .title-slide .subtitle {
            font-size: 1.8em;
            color: var(--text-secondary);
            margin-bottom: 40px;
        }

        .title-slide .meta {
            color: var(--text-secondary);
            font-size: 1.2em;
        }

        .title-slide .week-badge {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            color: white;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 30px;
        }

        /* Comparison Grid */
        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin: 20px 0;
        }

        .comparison-item {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .comparison-item.good {
            border-color: var(--accent-green);
        }

        .comparison-item.bad {
            border-color: var(--accent-red);
        }

        .comparison-item h4 {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Diagram Container */
        .diagram-container {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 30px;
            margin: 20px 0;
            text-align: center;
        }

        /* Key Points Grid */
        .key-points {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .key-point {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            text-align: center;
        }

        .key-point-icon {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .key-point-title {
            color: var(--accent-blue);
            font-weight: bold;
            margin-bottom: 8px;
        }

        /* Complexity Table Highlight */
        .complexity-good { color: var(--accent-green); font-weight: bold; }
        .complexity-ok { color: var(--accent-yellow); }
        .complexity-bad { color: var(--accent-red); font-weight: bold; }

        /* Person Card */
        .person-card {
            display: flex;
            gap: 30px;
            background: var(--bg-secondary);
            padding: 30px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            margin: 20px 0;
        }

        .person-photo {
            width: 200px;
            height: 200px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 5em;
            color: var(--text-secondary);
        }

        .person-info {
            flex: 1;
        }

        .person-info h3 {
            margin-top: 0;
        }

        /* Timeline */
        .timeline {
            position: relative;
            margin: 30px 0;
            padding-left: 30px;
        }

        .timeline::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: var(--accent-blue);
        }

        .timeline-item {
            position: relative;
            margin-bottom: 25px;
            padding-left: 25px;
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: -34px;
            top: 5px;
            width: 12px;
            height: 12px;
            background: var(--accent-blue);
            border-radius: 50%;
        }

        .timeline-year {
            color: var(--accent-purple);
            font-weight: bold;
            font-size: 1.1em;
        }

        /* Keyboard Shortcuts Info */
        .shortcuts-info {
            position: fixed;
            top: 20px;
            right: 30px;
            font-size: 0.85em;
            color: var(--text-secondary);
            z-index: 100;
        }

        .kbd {
            background: var(--bg-tertiary);
            padding: 3px 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            font-family: monospace;
        }

        /* Animation for slide content */
        .slide.active .animate-in {
            animation: fadeInUp 0.5s ease forwards;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .slide {
                padding: 40px 50px;
            }
            h1 { font-size: 2.2em; }
            h2 { font-size: 1.8em; }
            .two-columns, .comparison-grid {
                grid-template-columns: 1fr;
            }
            .key-points {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }
    </style>
</head>
<body>
    <div class="progress-bar" id="progressBar"></div>
    
    <div class="shortcuts-info">
        <span class="kbd">â†</span> <span class="kbd">â†’</span> Navigare | <span class="kbd">Home</span> <span class="kbd">End</span>
    </div>

    <div class="slides-container" id="slidesContainer">
        
        <!-- Slide 1: Title -->
        <div class="slide active" data-slide="1">
            <div class="title-slide">
                <div class="week-badge">SÄ‚PTÄ‚MÃ‚NA 11</div>
                <h1>Tabele de Dispersie</h1>
                <div class="subtitle">Hash Tables</div>
                <p class="meta">
                    Algoritmi È™i Tehnici de Programare (ATP)<br>
                    Academia de Studii Economice BucureÈ™ti - CSIE<br>
                    <br>
                    Ianuarie 2026
                </p>
            </div>
        </div>

        <!-- Slide 2: Learning Objectives -->
        <div class="slide" data-slide="2">
            <h2>ğŸ¯ Obiective de ÃnvÄƒÈ›are</h2>
            <div class="animate-in">
                <ol>
                    <li><strong>Rememorare:</strong> Principiile fundamentale ale tabelelor de dispersie È™i terminologia asociatÄƒ</li>
                    <li><strong>ÃnÈ›elegere:</strong> Mecanismele funcÈ›iilor hash È™i impactul distribuÈ›iei cheilor</li>
                    <li><strong>Aplicare:</strong> Tehnicile de rezolvare a coliziunilor: chaining È™i open addressing</li>
                    <li><strong>AnalizÄƒ:</strong> Complexitatea temporalÄƒ È™i spaÈ›ialÄƒ pentru operaÈ›iile de bazÄƒ</li>
                    <li><strong>Evaluare:</strong> Compromisurile Ã®ntre diferite strategii de hashing</li>
                    <li><strong>Creare:</strong> ImplementÄƒri complete cu funcÈ›ii hash personalizate È™i redimensionare</li>
                </ol>
            </div>
            <div class="info-box tip animate-in">
                <div class="info-box-title">ğŸ’¡ De reÈ›inut</div>
                Hash tables oferÄƒ acces O(1) Ã®n medie - una dintre cele mai eficiente structuri de date!
            </div>
        </div>

        <!-- Slide 3: Historical Context -->
        <div class="slide" data-slide="3">
            <h2>ğŸ“œ Context Istoric</h2>
            <div class="timeline animate-in">
                <div class="timeline-item">
                    <span class="timeline-year">1953</span>
                    <p><strong>H.P. Luhn</strong> (IBM) - Primul brevet pentru indexare bazatÄƒ pe hashing</p>
                </div>
                <div class="timeline-item">
                    <span class="timeline-year">1956</span>
                    <p><strong>Arnold Dumey</strong> - Prima descriere academicÄƒ a hash tables Ã®n compilatoare</p>
                </div>
                <div class="timeline-item">
                    <span class="timeline-year">1963</span>
                    <p><strong>W.W. Peterson</strong> - Formalizarea analizei coliziunilor, linear probing</p>
                </div>
                <div class="timeline-item">
                    <span class="timeline-year">1973</span>
                    <p><strong>Donald Knuth</strong> - "The Art of Computer Programming" Vol. 3 - fundamente teoretice</p>
                </div>
                <div class="timeline-item">
                    <span class="timeline-year">2001</span>
                    <p><strong>Pagh & Rodler</strong> - Cuckoo Hashing - worst-case O(1) lookup</p>
                </div>
            </div>
        </div>

        <!-- Slide 4: Key Figure -->
        <div class="slide" data-slide="4">
            <h2>ğŸ† Personalitate Cheie</h2>
            <div class="person-card animate-in">
                <div class="person-photo">ğŸ‘¨â€ğŸ”¬</div>
                <div class="person-info">
                    <h3>Donald Ervin Knuth (1938-)</h3>
                    <p>Profesor emerit la Universitatea Stanford, considerat "pÄƒrintele analizei algoritmilor".</p>
                    <h4>ContribuÈ›ii la Hashing:</h4>
                    <ul>
                        <li>Analiza matematicÄƒ riguroasÄƒ a linear probing</li>
                        <li>Demonstrarea superioritÄƒÈ›ii double hashing</li>
                        <li>Conceptul de secondary clustering</li>
                    </ul>
                </div>
            </div>
            <div class="quote-box animate-in">
                "Premature optimization is the root of all evil."
                <div class="quote-author">â€” Donald Knuth</div>
            </div>
        </div>

        <!-- Slide 5: What is a Hash Table -->
        <div class="slide" data-slide="5">
            <h2>Ce este o Hash Table?</h2>
            <p class="animate-in">O <strong>tabelÄƒ de dispersie</strong> este o structurÄƒ de date care implementeazÄƒ un dicÈ›ionar abstract, permiÈ›Ã¢nd asocierea eficientÄƒ a cheilor cu valori.</p>
            
            <div class="ascii-box animate-in">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    HASH TABLE ARCHITECTURE                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚    Key â”€â”€â–º Hash Function â”€â”€â–º Index â”€â”€â–º Bucket â”€â”€â–º Value         â”‚
â”‚                                                                  â”‚
â”‚    "Alice" â”€â”€â–º h("Alice") â”€â”€â–º 3 â”€â”€â–º table[3] â”€â”€â–º {data...}      â”‚
â”‚    "Bob"   â”€â”€â–º h("Bob")   â”€â”€â–º 7 â”€â”€â–º table[7] â”€â”€â–º {data...}      â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
            
            <div class="key-points animate-in">
                <div class="key-point">
                    <div class="key-point-icon">âš¡</div>
                    <div class="key-point-title">Rapiditate</div>
                    <p>O(1) pentru insert, search, delete</p>
                </div>
                <div class="key-point">
                    <div class="key-point-icon">ğŸ¯</div>
                    <div class="key-point-title">Acces Direct</div>
                    <p>CalculeazÄƒ poziÈ›ia din cheie</p>
                </div>
                <div class="key-point">
                    <div class="key-point-icon">ğŸ’¾</div>
                    <div class="key-point-title">Flexibilitate</div>
                    <p>Orice tip de cheie/valoare</p>
                </div>
            </div>
        </div>

        <!-- Slide 6: Terminology -->
        <div class="slide" data-slide="6">
            <h2>ğŸ“– Terminologie EsenÈ›ialÄƒ</h2>
            <table class="animate-in">
                <tr>
                    <th>Termen</th>
                    <th>DefiniÈ›ie</th>
                    <th>Exemplu</th>
                </tr>
                <tr>
                    <td><code>Bucket / Slot</code></td>
                    <td>PoziÈ›ie individualÄƒ Ã®n tabelÄƒ</td>
                    <td><code>table[5]</code></td>
                </tr>
                <tr>
                    <td><code>Hash Function</code></td>
                    <td>FuncÈ›ia care converteÈ™te cheia Ã®n index</td>
                    <td><code>h("Ana") = 7</code></td>
                </tr>
                <tr>
                    <td><code>Collision</code></td>
                    <td>CÃ¢nd h(kâ‚) = h(kâ‚‚) pentru kâ‚ â‰  kâ‚‚</td>
                    <td><code>h("Ana") = h("Ion") = 7</code></td>
                </tr>
                <tr>
                    <td><code>Load Factor (Î±)</code></td>
                    <td>Raportul n/m (elemente/dimensiune)</td>
                    <td><code>100 elem / 150 slots = 0.67</code></td>
                </tr>
                <tr>
                    <td><code>Clustering</code></td>
                    <td>Gruparea datelor Ã®n zone adiacente</td>
                    <td>Slots 5,6,7,8 toate ocupate</td>
                </tr>
                <tr>
                    <td><code>Probing</code></td>
                    <td>CÄƒutarea unui slot liber la coliziune</td>
                    <td>Linear, Quadratic, Double</td>
                </tr>
            </table>
        </div>

        <!-- Slide 7: Hash Function Concept -->
        <div class="slide" data-slide="7">
            <h2>ğŸ”‘ FuncÈ›ia Hash - Concept</h2>
            <p class="animate-in">O funcÈ›ie hash idealÄƒ trebuie sÄƒ satisfacÄƒ proprietatea de <strong>distribuÈ›ie uniformÄƒ</strong>: fiecare cheie sÄƒ aibÄƒ probabilitate egalÄƒ de a fi plasatÄƒ Ã®n oricare bucket.</p>
            
            <div class="two-columns animate-in">
                <div class="column">
                    <h4>âœ… FuncÈ›ie Hash BunÄƒ</h4>
                    <div class="ascii-box" style="font-size: 0.8em;">
Keys: Ana, Bob, Carol, Dan, Eva
      â†“     â†“     â†“      â†“    â†“
      2     7     1      5    9

[0][1][2][3][4][5][6][7][8][9]
   C  A        D     B     E
                    </div>
                    <p style="color: var(--accent-green);">DistribuÈ›ie uniformÄƒ</p>
                </div>
                <div class="column">
                    <h4>âŒ FuncÈ›ie Hash SlabÄƒ</h4>
                    <div class="ascii-box" style="font-size: 0.8em;">
Keys: Ana, Bob, Carol, Dan, Eva
      â†“     â†“     â†“      â†“    â†“
      2     2     3      3    2

[0][1][2][3][4][5][6][7][8][9]
   ABECD                      
                    </div>
                    <p style="color: var(--accent-red);">Clustering sever</p>
                </div>
            </div>
        </div>

        <!-- Slide 8: Division Method -->
        <div class="slide" data-slide="8">
            <h2>Metoda ÃmpÄƒrÈ›irii (Division Method)</h2>
            <p class="animate-in">Cea mai simplÄƒ È™i rÄƒspÃ¢nditÄƒ metodÄƒ: <code>h(k) = k mod m</code></p>
            
            <div class="code-block animate-in">
                <div class="code-header">
                    <span>Hash cu metoda Ã®mpÄƒrÈ›irii pentru È™iruri</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">size_t hash_division(const char *key, size_t table_size) {
    size_t hash = 0;
    while (*key) {
        hash = hash * 31 + (unsigned char)(*key++);
    }
    return hash % table_size;
}

/* Exemplu de utilizare */
size_t index = hash_division("student", 101);
/* 101 este numÄƒr prim - alegere bunÄƒ pentru table_size */</code></pre>
            </div>
            
            <div class="info-box warning animate-in">
                <div class="info-box-title">âš ï¸ AtenÈ›ie la alegerea lui m</div>
                <ul>
                    <li><strong>EvitÄƒ puterile lui 2</strong> (m = 2^k) - foloseÈ™te doar ultimii k biÈ›i</li>
                    <li><strong>EvitÄƒ m = 2^k - 1</strong> - permutÄƒrile au acelaÈ™i hash</li>
                    <li><strong>Recomandare:</strong> m = numÄƒr prim, nu aproape de puteri ale lui 2</li>
                </ul>
            </div>
        </div>

        <!-- Slide 9: Multiplication Method -->
        <div class="slide" data-slide="9">
            <h2>Metoda ÃnmulÈ›irii (Multiplication Method)</h2>
            <p class="animate-in">Formula: <code>h(k) = âŒŠm Â· (kÂ·A mod 1)âŒ‹</code> unde A este o constantÄƒ 0 &lt; A &lt; 1</p>
            
            <div class="code-block animate-in">
                <div class="code-header">
                    <span>Hash cu metoda Ã®nmulÈ›irii</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">#define A 0.6180339887  /* (âˆš5 - 1) / 2 - Golden Ratio */

size_t hash_multiplication(unsigned int key, size_t table_size) {
    double product = key * A;
    double fractional = product - (unsigned long)product;
    return (size_t)(table_size * fractional);
}

/* Avantaj: valoarea lui m nu este criticÄƒ */
/* Golden Ratio oferÄƒ distribuÈ›ie foarte bunÄƒ */</code></pre>
            </div>
            
            <div class="info-box tip animate-in">
                <div class="info-box-title">ğŸ’¡ De ce Golden Ratio?</div>
                Knuth a demonstrat cÄƒ A = (âˆš5 - 1) / 2 â‰ˆ 0.618 produce cea mai uniformÄƒ distribuÈ›ie, minimizÃ¢nd clustering-ul.
            </div>
        </div>

        <!-- Slide 10: String Hash Functions -->
        <div class="slide" data-slide="10">
            <h2>FuncÈ›ii Hash pentru È˜iruri</h2>
            
            <table class="animate-in">
                <tr>
                    <th>FuncÈ›ie</th>
                    <th>Formula</th>
                    <th>Caracteristici</th>
                </tr>
                <tr>
                    <td><code>djb2</code></td>
                    <td>hash = hash Ã— 33 + c</td>
                    <td>RapidÄƒ, distribuÈ›ie bunÄƒ</td>
                </tr>
                <tr>
                    <td><code>sdbm</code></td>
                    <td>hash = c + (hash &lt;&lt; 6) + (hash &lt;&lt; 16) - hash</td>
                    <td>DistribuÈ›ie excelentÄƒ</td>
                </tr>
                <tr>
                    <td><code>FNV-1a</code></td>
                    <td>hash = (hash ^ c) Ã— 16777619</td>
                    <td>Foarte uniformÄƒ, popularÄƒ</td>
                </tr>
            </table>
            
            <div class="code-block animate-in">
                <div class="code-header">
                    <span>djb2 - Dan Bernstein</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">unsigned long hash_djb2(const char *str) {
    unsigned long hash = 5381;
    int c;
    
    while ((c = *str++))
        hash = ((hash << 5) + hash) + c;  /* hash * 33 + c */
    
    return hash;
}</code></pre>
            </div>
        </div>

        <!-- Slide 11: sdbm Hash -->
        <div class="slide" data-slide="11">
            <h2>FuncÈ›ia sdbm</h2>
            
            <div class="code-block animate-in">
                <div class="code-header">
                    <span>sdbm - folositÄƒ Ã®n Berkeley DB</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">unsigned long hash_sdbm(const char *str) {
    unsigned long hash = 0;
    int c;
    
    while ((c = *str++))
        hash = c + (hash << 6) + (hash << 16) - hash;
    
    return hash;
}

/* Echivalent matematic: hash = hash * 65599 + c */
/* 65599 este un numÄƒr prim ales pentru distribuÈ›ie optimÄƒ */</code></pre>
            </div>
            
            <div class="code-block animate-in">
                <div class="code-header">
                    <span>FNV-1a (Fowler-Noll-Vo)</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">#define FNV_OFFSET 2166136261u
#define FNV_PRIME  16777619u

unsigned long hash_fnv1a(const char *str) {
    unsigned long hash = FNV_OFFSET;
    
    while (*str) {
        hash ^= (unsigned char)*str++;
        hash *= FNV_PRIME;
    }
    
    return hash;
}</code></pre>
            </div>
        </div>

        <!-- Slide 12: Collisions Introduction -->
        <div class="slide" data-slide="12">
            <h2>ğŸ’¥ Problema Coliziunilor</h2>
            <p class="animate-in">O <strong>coliziune</strong> apare cÃ¢nd douÄƒ chei diferite produc acelaÈ™i index: h(kâ‚) = h(kâ‚‚) pentru kâ‚ â‰  kâ‚‚</p>
            
            <div class="ascii-box animate-in">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     COLIZIUNE                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚    h("Alice") = 3   â”€â”€â”€â”€â”                                        â”‚
â”‚                         â”œâ”€â”€â”€â”€â–º table[3] = ???                    â”‚
â”‚    h("Carol") = 3   â”€â”€â”€â”€â”˜                                        â”‚
â”‚                                                                   â”‚
â”‚    Ambele chei vor acelaÈ™i slot! Ce facem?                       â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
            
            <div class="two-columns animate-in">
                <div class="column">
                    <h4>ğŸ”— Separate Chaining</h4>
                    <p>Fiecare bucket conÈ›ine o listÄƒ Ã®nlÄƒnÈ›uitÄƒ de elemente cu acelaÈ™i hash</p>
                </div>
                <div class="column">
                    <h4>ğŸ“ Open Addressing</h4>
                    <p>CÄƒutÄƒm alt slot liber Ã®n tabelÄƒ folosind o secvenÈ›Äƒ de probing</p>
                </div>
            </div>
        </div>

        <!-- Slide 13: Separate Chaining -->
        <div class="slide" data-slide="13">
            <h2>ğŸ”— Separate Chaining (ÃnlÄƒnÈ›uire)</h2>
            
            <div class="ascii-box animate-in">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SEPARATE CHAINING                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  [0] â”€â”€â–º NULL                                               â”‚
â”‚                                                              â”‚
â”‚  [1] â”€â”€â–º â”Œâ”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”                             â”‚
â”‚          â”‚"Bob"  â”‚â”€â”€â”€â–ºâ”‚"Eve"  â”‚â”€â”€â”€â–º NULL                    â”‚
â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”˜                             â”‚
â”‚                                                              â”‚
â”‚  [2] â”€â”€â–º NULL                                               â”‚
â”‚                                                              â”‚
â”‚  [3] â”€â”€â–º â”Œâ”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚          â”‚"Alice"â”‚â”€â”€â”€â–ºâ”‚"Carol"â”‚â”€â”€â”€â–ºâ”‚"Dave" â”‚â”€â”€â”€â–º NULL       â”‚
â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                                                              â”‚
â”‚  [4] â”€â”€â–º â”Œâ”€â”€â”€â”€â”€â”€â”€â”                                          â”‚
â”‚          â”‚"Frank"â”‚â”€â”€â”€â–º NULL                                 â”‚
â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”˜                                          â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
            
            <div class="info-box info animate-in">
                <div class="info-box-title">â„¹ï¸ Caracteristici</div>
                <ul>
                    <li>Simplu de implementat</li>
                    <li>FuncÈ›ioneazÄƒ bine cu load factor &gt; 1</li>
                    <li>È˜tergerea este directÄƒ (eliminare din listÄƒ)</li>
                </ul>
            </div>
        </div>

        <!-- Slide 14: Chaining Implementation -->
        <div class="slide" data-slide="14">
            <h2>Implementare Chaining</h2>
            
            <div class="code-block animate-in">
                <div class="code-header">
                    <span>Structuri de date pentru chaining</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/* Nod Ã®n lista Ã®nlÄƒnÈ›uitÄƒ */
typedef struct HashNode {
    char *key;
    void *value;
    struct HashNode *next;
} HashNode;

/* Tabela de dispersie */
typedef struct HashTable {
    HashNode **buckets;    /* Array de pointeri la liste */
    size_t size;           /* Dimensiunea tabelei */
    size_t count;          /* NumÄƒrul de elemente */
} HashTable;

/* Creare tabelÄƒ */
HashTable* ht_create(size_t size) {
    HashTable *ht = malloc(sizeof(HashTable));
    ht->buckets = calloc(size, sizeof(HashNode*));
    ht->size = size;
    ht->count = 0;
    return ht;
}</code></pre>
            </div>
        </div>

        <!-- Slide 15: Chaining Insert -->
        <div class="slide" data-slide="15">
            <h2>Chaining - Inserare</h2>
            
            <div class="code-block animate-in">
                <div class="code-header">
                    <span>Inserare Ã®n hash table cu chaining</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void ht_insert(HashTable *ht, const char *key, void *value) {
    /* CalculeazÄƒ indexul */
    size_t index = hash_djb2(key) % ht->size;
    
    /* VerificÄƒ dacÄƒ cheia existÄƒ deja */
    HashNode *current = ht->buckets[index];
    while (current) {
        if (strcmp(current->key, key) == 0) {
            current->value = value;  /* ActualizeazÄƒ valoarea */
            return;
        }
        current = current->next;
    }
    
    /* CreeazÄƒ nod nou - inserare la Ã®nceput (O(1)) */
    HashNode *new_node = malloc(sizeof(HashNode));
    new_node->key = strdup(key);
    new_node->value = value;
    new_node->next = ht->buckets[index];
    ht->buckets[index] = new_node;
    
    ht->count++;
    
    /* VerificÄƒ load factor pentru redimensionare */
    if ((double)ht->count / ht->size > 2.0) {
        ht_resize(ht, ht->size * 2);
    }
}</code></pre>
            </div>
        </div>

        <!-- Slide 16: Chaining Search -->
        <div class="slide" data-slide="16">
            <h2>Chaining - CÄƒutare È™i È˜tergere</h2>
            
            <div class="code-block animate-in">
                <div class="code-header">
                    <span>CÄƒutare</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void* ht_search(HashTable *ht, const char *key) {
    size_t index = hash_djb2(key) % ht->size;
    
    HashNode *current = ht->buckets[index];
    while (current) {
        if (strcmp(current->key, key) == 0)
            return current->value;
        current = current->next;
    }
    return NULL;  /* Nu a fost gÄƒsit */
}</code></pre>
            </div>
            
            <div class="code-block animate-in">
                <div class="code-header">
                    <span>È˜tergere</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">bool ht_delete(HashTable *ht, const char *key) {
    size_t index = hash_djb2(key) % ht->size;
    
    HashNode *current = ht->buckets[index];
    HashNode *prev = NULL;
    
    while (current) {
        if (strcmp(current->key, key) == 0) {
            if (prev) prev->next = current->next;
            else      ht->buckets[index] = current->next;
            free(current->key);
            free(current);
            ht->count--;
            return true;
        }
        prev = current;
        current = current->next;
    }
    return false;
}</code></pre>
            </div>
        </div>

        <!-- Slide 17: Open Addressing Intro -->
        <div class="slide" data-slide="17">
            <h2>ğŸ“ Open Addressing (Adresare DeschisÄƒ)</h2>
            <p class="animate-in">Toate elementele sunt stocate direct Ã®n tabelÄƒ. La coliziune, cÄƒutÄƒm alt slot liber.</p>
            
            <div class="ascii-box animate-in">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    OPEN ADDRESSING                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  Insert "Carol" where h("Carol") = 3, but slot 3 is full:   â”‚
â”‚                                                              â”‚
â”‚  [0]     [1]     [2]     [3]     [4]     [5]     [6]        â”‚
â”‚   -       -       -    "Alice"    -       -       -          â”‚
â”‚                           â–²                                  â”‚
â”‚                           â”‚                                  â”‚
â”‚                     h("Carol")=3                             â”‚
â”‚                           â”‚                                  â”‚
â”‚                           â–¼                                  â”‚
â”‚   -       -       -    "Alice" "Carol"   -       -          â”‚
â”‚                                   â–²                          â”‚
â”‚                                   â”‚                          â”‚
â”‚                           Probe: (3+1) mod 7 = 4            â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
            
            <div class="info-box warning animate-in">
                <div class="info-box-title">âš ï¸ RestricÈ›ii</div>
                Load factor trebuie sÄƒ fie Î± &lt; 1 (tabela nu poate fi plinÄƒ)
            </div>
        </div>

        <!-- Slide 18: Linear Probing -->
        <div class="slide" data-slide="18">
            <h2>Linear Probing</h2>
            <p class="animate-in">SecvenÈ›a de probing: <code>h(k, i) = (h'(k) + i) mod m</code></p>
            
            <div class="code-block animate-in">
                <div class="code-header">
                    <span>Inserare cu linear probing</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">#define EMPTY    NULL
#define DELETED  ((void*)-1)

void ht_insert_linear(HashTable *ht, const char *key, void *value) {
    size_t index = hash_djb2(key) % ht->size;
    size_t original = index;
    
    do {
        if (ht->buckets[index] == EMPTY || 
            ht->buckets[index] == DELETED) {
            /* Slot disponibil */
            HashNode *node = malloc(sizeof(HashNode));
            node->key = strdup(key);
            node->value = value;
            ht->buckets[index] = node;
            ht->count++;
            return;
        }
        
        if (strcmp(((HashNode*)ht->buckets[index])->key, key) == 0) {
            /* Cheie existentÄƒ - actualizeazÄƒ */
            ((HashNode*)ht->buckets[index])->value = value;
            return;
        }
        
        index = (index + 1) % ht->size;  /* Linear probe */
    } while (index != original);
    
    /* Tabela plinÄƒ - trebuie redimensionatÄƒ */
}</code></pre>
            </div>
        </div>

        <!-- Slide 19: Primary Clustering -->
        <div class="slide" data-slide="19">
            <h2>âš ï¸ Primary Clustering</h2>
            <p class="animate-in">Linear probing suferÄƒ de <strong>primary clustering</strong>: elementele se grupeazÄƒ Ã®n zone contigue.</p>
            
            <div class="ascii-box animate-in">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PRIMARY CLUSTERING                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  DupÄƒ multe inserÄƒri:                                        â”‚
â”‚                                                              â”‚
â”‚  [0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10][11][12][13]   â”‚
â”‚   X   X   X   X   X   -   -   X   X   X   X   X   -   -     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚      CLUSTER 1                  CLUSTER 2                    â”‚
â”‚                                                              â”‚
â”‚  Problema: Inserarea Ã®n cluster Ã®l mÄƒreÈ™te!                 â”‚
â”‚  Un element care hash-uieÈ™te la 2 va ajunge la 5            â”‚
â”‚  â†’ Clusterul creÈ™te â†’ PerformanÈ›a scade                     â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
            
            <div class="info-box danger animate-in">
                <div class="info-box-title">âŒ Efect</div>
                Pe mÄƒsurÄƒ ce tabela se umple, cÄƒutÄƒrile devin din ce Ã®n ce mai lente, apropiindu-se de O(n).
            </div>
        </div>

        <!-- Slide 20: Quadratic Probing -->
        <div class="slide" data-slide="20">
            <h2>Quadratic Probing</h2>
            <p class="animate-in">SecvenÈ›a: <code>h(k, i) = (h'(k) + câ‚Â·i + câ‚‚Â·iÂ²) mod m</code></p>
            
            <div class="code-block animate-in">
                <div class="code-header">
                    <span>CÄƒutare cu quadratic probing</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void* ht_search_quadratic(HashTable *ht, const char *key) {
    size_t index = hash_djb2(key) % ht->size;
    size_t i = 0;
    
    while (ht->buckets[index] != EMPTY) {
        if (ht->buckets[index] != DELETED) {
            HashNode *node = ht->buckets[index];
            if (strcmp(node->key, key) == 0)
                return node->value;
        }
        
        i++;
        /* Quadratic: c1=1, c2=1 -> 1, 2, 4, 7, 11, ... */
        index = (hash_djb2(key) + i + i*i) % ht->size;
        
        if (i >= ht->size) break;  /* Am verificat toate sloturile */
    }
    
    return NULL;
}</code></pre>
            </div>
            
            <div class="info-box tip animate-in">
                <div class="info-box-title">ğŸ’¡ Avantaj</div>
                EvitÄƒ primary clustering, dar poate suferi de <strong>secondary clustering</strong> - cheile cu acelaÈ™i hash urmeazÄƒ aceeaÈ™i secvenÈ›Äƒ.
            </div>
        </div>

        <!-- Slide 21: Double Hashing -->
        <div class="slide" data-slide="21">
            <h2>Double Hashing</h2>
            <p class="animate-in">Cea mai bunÄƒ metodÄƒ de open addressing: <code>h(k, i) = (hâ‚(k) + iÂ·hâ‚‚(k)) mod m</code></p>
            
            <div class="code-block animate-in">
                <div class="code-header">
                    <span>Double hashing</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/* FuncÈ›ie hash secundarÄƒ - trebuie sÄƒ returneze valoare != 0 */
size_t hash2(const char *key, size_t table_size) {
    size_t hash = hash_sdbm(key);
    /* AsigurÄƒ cÄƒ rezultatul e nenul È™i relativ prim cu table_size */
    return 1 + (hash % (table_size - 1));
}

void* ht_search_double(HashTable *ht, const char *key) {
    size_t h1 = hash_djb2(key) % ht->size;
    size_t h2 = hash2(key, ht->size);
    size_t index = h1;
    
    for (size_t i = 0; i < ht->size; i++) {
        if (ht->buckets[index] == EMPTY)
            return NULL;
            
        if (ht->buckets[index] != DELETED) {
            if (strcmp(((HashNode*)ht->buckets[index])->key, key) == 0)
                return ((HashNode*)ht->buckets[index])->value;
        }
        
        index = (h1 + i * h2) % ht->size;
    }
    
    return NULL;
}</code></pre>
            </div>
        </div>

        <!-- Slide 22: Probing Comparison -->
        <div class="slide" data-slide="22">
            <h2>ComparaÈ›ie Metode de Probing</h2>
            
            <table class="animate-in">
                <tr>
                    <th>MetodÄƒ</th>
                    <th>SecvenÈ›Äƒ</th>
                    <th>Pro</th>
                    <th>Contra</th>
                </tr>
                <tr>
                    <td><strong>Linear</strong></td>
                    <td>h + i</td>
                    <td>Cache-friendly</td>
                    <td>Primary clustering</td>
                </tr>
                <tr>
                    <td><strong>Quadratic</strong></td>
                    <td>h + i + iÂ²</td>
                    <td>EvitÄƒ primary clustering</td>
                    <td>Secondary clustering, poate rata sloturi</td>
                </tr>
                <tr>
                    <td><strong>Double</strong></td>
                    <td>hâ‚ + iÂ·hâ‚‚</td>
                    <td>DistribuÈ›ie optimÄƒ</td>
                    <td>NecesitÄƒ 2 funcÈ›ii hash</td>
                </tr>
            </table>
            
            <div class="ascii-box animate-in" style="font-size: 0.75em;">
Linear:    0  1  2  3  4  5  6  7  8  9  (pas constant)
Quadratic: 0  1  3  6  10 15 21 28 36 45 (pas crescÄƒtor)  
Double:    0  3  6  9  12 15 18 21 24 27 (pas = h2(k), ex: 3)
            </div>
        </div>

        <!-- Slide 23: Deletion in Open Addressing -->
        <div class="slide" data-slide="23">
            <h2>âš ï¸ È˜tergerea Ã®n Open Addressing</h2>
            <p class="animate-in">È˜tergerea este problematicÄƒ - nu putem pur È™i simplu marca slotul ca gol!</p>
            
            <div class="ascii-box animate-in">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PROBLEMA È˜TERGERII                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Initial:                                                    â”‚
â”‚  [0]    [1]    [2]    [3]    [4]    [5]                     â”‚
â”‚  "A"    "B"    "C"     -      -      -                       â”‚
â”‚   â†‘      â†‘      â†‘                                            â”‚
â”‚  h=0   h=0    h=0   (A,B,C toate hash la 0)                 â”‚
â”‚                                                              â”‚
â”‚  DupÄƒ È™tergerea lui "B":                                     â”‚
â”‚  [0]    [1]    [2]    [3]    [4]    [5]                     â”‚
â”‚  "A"     âˆ…     "C"     -      -      -                       â”‚
â”‚                 â†‘                                             â”‚
â”‚            !! "C" devine inaccesibil !!                      â”‚
â”‚            (cÄƒutarea se opreÈ™te la âˆ…)                        â”‚
â”‚                                                              â”‚
â”‚  SOLUÈšIE: Marker DELETED                                     â”‚
â”‚  [0]    [1]    [2]    [3]    [4]    [5]                     â”‚
â”‚  "A"   [DEL]  "C"     -      -      -                       â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
            
            <div class="code-block animate-in">
                <div class="code-header">
                    <span>È˜tergere cu marker DELETED</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">bool ht_delete_open(HashTable *ht, const char *key) {
    size_t index = find_slot(ht, key);  /* GÄƒseÈ™te slotul */
    
    if (index != INVALID && ht->buckets[index] != EMPTY) {
        free(((HashNode*)ht->buckets[index])->key);
        free(ht->buckets[index]);
        ht->buckets[index] = DELETED;  /* NU EMPTY! */
        ht->count--;
        return true;
    }
    return false;
}</code></pre>
            </div>
        </div>

        <!-- Slide 24: Complexity Analysis -->
        <div class="slide" data-slide="24">
            <h2>ğŸ“Š Analiza ComplexitÄƒÈ›ii</h2>
            
            <table class="animate-in">
                <tr>
                    <th>OperaÈ›ie</th>
                    <th>Chaining (avg)</th>
                    <th>Chaining (worst)</th>
                    <th>Open Addr (avg)</th>
                    <th>Open Addr (worst)</th>
                </tr>
                <tr>
                    <td><strong>Insert</strong></td>
                    <td class="complexity-good">O(1)</td>
                    <td class="complexity-bad">O(n)</td>
                    <td class="complexity-ok">O(1/(1-Î±))</td>
                    <td class="complexity-bad">O(n)</td>
                </tr>
                <tr>
                    <td><strong>Search</strong></td>
                    <td class="complexity-good">O(1 + Î±)</td>
                    <td class="complexity-bad">O(n)</td>
                    <td class="complexity-ok">O(1/(1-Î±))</td>
                    <td class="complexity-bad">O(n)</td>
                </tr>
                <tr>
                    <td><strong>Delete</strong></td>
                    <td class="complexity-good">O(1 + Î±)</td>
                    <td class="complexity-bad">O(n)</td>
                    <td class="complexity-ok">O(1/(1-Î±))</td>
                    <td class="complexity-bad">O(n)</td>
                </tr>
                <tr>
                    <td><strong>Space</strong></td>
                    <td colspan="2">O(n + m)</td>
                    <td colspan="2">O(m)</td>
                </tr>
            </table>
            
            <p class="animate-in" style="margin-top: 20px;">Unde: <code>Î± = n/m</code> (load factor), <code>n</code> = elemente, <code>m</code> = dimensiune tabelÄƒ</p>
            
            <div class="info-box info animate-in">
                <div class="info-box-title">â„¹ï¸ Praguri de redimensionare</div>
                <ul>
                    <li><strong>Chaining:</strong> RedimensioneazÄƒ cÃ¢nd Î± &gt; 2.0</li>
                    <li><strong>Open Addressing:</strong> RedimensioneazÄƒ cÃ¢nd Î± &gt; 0.7</li>
                </ul>
            </div>
        </div>

        <!-- Slide 25: Resizing -->
        <div class="slide" data-slide="25">
            <h2>ğŸ”„ Redimensionarea Tabelei</h2>
            
            <div class="code-block animate-in">
                <div class="code-header">
                    <span>Redimensionare (rehashing)</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void ht_resize(HashTable *ht, size_t new_size) {
    HashNode **old_buckets = ht->buckets;
    size_t old_size = ht->size;
    
    /* AlocÄƒ noua tabelÄƒ */
    ht->buckets = calloc(new_size, sizeof(HashNode*));
    ht->size = new_size;
    ht->count = 0;
    
    /* ReinsereazÄƒ toate elementele */
    for (size_t i = 0; i < old_size; i++) {
        HashNode *current = old_buckets[i];
        while (current) {
            HashNode *next = current->next;
            
            /* RecalculeazÄƒ indexul pentru noua dimensiune */
            size_t new_index = hash_djb2(current->key) % new_size;
            
            /* InsereazÄƒ Ã®n noua poziÈ›ie */
            current->next = ht->buckets[new_index];
            ht->buckets[new_index] = current;
            ht->count++;
            
            current = next;
        }
    }
    
    free(old_buckets);
}</code></pre>
            </div>
            
            <div class="info-box warning animate-in">
                <div class="info-box-title">âš ï¸ Complexitate</div>
                Redimensionarea este O(n), dar se face rar. Amortizat, inserarea rÄƒmÃ¢ne O(1).
            </div>
        </div>

        <!-- Slide 26: POSIX hsearch -->
        <div class="slide" data-slide="26">
            <h2>ğŸ› ï¸ Biblioteca Standard: hsearch</h2>
            
            <div class="code-block animate-in">
                <div class="code-header">
                    <span>POSIX hsearch (search.h)</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">#include &lt;search.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
    ENTRY item, *found;
    
    /* CreeazÄƒ hash table cu 100 de sloturi */
    if (hcreate(100) == 0) {
        perror("hcreate");
        return 1;
    }
    
    /* Inserare */
    item.key = "student_id";
    item.data = (void *)"Ion Popescu";
    hsearch(item, ENTER);
    
    item.key = "nota";
    item.data = (void *)"10";
    hsearch(item, ENTER);
    
    /* CÄƒutare */
    item.key = "student_id";
    found = hsearch(item, FIND);
    if (found)
        printf("Student: %s\n", (char *)found->data);
    
    hdestroy();  /* ElibereazÄƒ memoria */
    return 0;
}</code></pre>
            </div>
            
            <div class="info-box warning animate-in">
                <div class="info-box-title">âš ï¸ LimitÄƒri hsearch</div>
                <ul>
                    <li>O singurÄƒ tabelÄƒ globalÄƒ per proces</li>
                    <li>Nu suportÄƒ È™tergerea</li>
                    <li>Dimensiunea fixÄƒ</li>
                </ul>
            </div>
        </div>

        <!-- Slide 27: Common Mistakes -->
        <div class="slide" data-slide="27">
            <h2>âŒ GreÈ™eli Frecvente</h2>
            
            <div class="comparison-grid animate-in">
                <div class="comparison-item bad">
                    <h4>âŒ FuncÈ›ie hash slabÄƒ</h4>
                    <div class="code-block" style="margin: 10px 0;">
                        <pre><code class="language-c">/* GREÈ˜IT: ReturneazÄƒ doar primul caracter */
size_t bad_hash(const char *s) {
    return s[0];
}</code></pre>
                    </div>
                    <p>Toate cuvintele cu aceeaÈ™i literÄƒ iniÈ›ialÄƒ colizioneazÄƒ!</p>
                </div>
                
                <div class="comparison-item good">
                    <h4>âœ… FuncÈ›ie hash bunÄƒ</h4>
                    <div class="code-block" style="margin: 10px 0;">
                        <pre><code class="language-c">/* CORECT: ConsiderÄƒ toate caracterele */
size_t good_hash(const char *s) {
    size_t h = 5381;
    while (*s) h = h * 33 + *s++;
    return h;
}</code></pre>
                    </div>
                    <p>DistribuÈ›ie uniformÄƒ pe Ã®ntreg È™irul</p>
                </div>
                
                <div class="comparison-item bad">
                    <h4>âŒ Uitarea DELETED marker</h4>
                    <div class="code-block" style="margin: 10px 0;">
                        <pre><code class="language-c">/* GREÈ˜IT Ã®n open addressing */
ht->buckets[index] = NULL;</code></pre>
                    </div>
                    <p>Ãntrerupe lanÈ›ul de probing</p>
                </div>
                
                <div class="comparison-item good">
                    <h4>âœ… Folosirea DELETED</h4>
                    <div class="code-block" style="margin: 10px 0;">
                        <pre><code class="language-c">/* CORECT */
ht->buckets[index] = DELETED;</code></pre>
                    </div>
                    <p>CÄƒutarea continuÄƒ corect</p>
                </div>
            </div>
        </div>

        <!-- Slide 28: More Mistakes -->
        <div class="slide" data-slide="28">
            <h2>âŒ Mai Multe GreÈ™eli</h2>
            
            <div class="comparison-grid animate-in">
                <div class="comparison-item bad">
                    <h4>âŒ Load factor prea mare</h4>
                    <div class="code-block" style="margin: 10px 0;">
                        <pre><code class="language-c">/* Open addressing cu Î± > 0.9 */
if (count > size * 0.95) resize();
/* Prea tÃ¢rziu! */</code></pre>
                    </div>
                    <p>PerformanÈ›a degradeazÄƒ sever</p>
                </div>
                
                <div class="comparison-item good">
                    <h4>âœ… Load factor controlat</h4>
                    <div class="code-block" style="margin: 10px 0;">
                        <pre><code class="language-c">/* Redimensionare la 70% */
if (count > size * 0.7) resize();
/* PerformanÈ›Äƒ optimÄƒ */</code></pre>
                    </div>
                    <p>MenÈ›ine O(1) Ã®n practicÄƒ</p>
                </div>
                
                <div class="comparison-item bad">
                    <h4>âŒ Dimensiune putere a lui 2</h4>
                    <div class="code-block" style="margin: 10px 0;">
                        <pre><code class="language-c">/* table_size = 1024 */
index = hash % 1024;
/* FoloseÈ™te doar ultimii 10 biÈ›i! */</code></pre>
                    </div>
                    <p>DistribuÈ›ie non-uniformÄƒ</p>
                </div>
                
                <div class="comparison-item good">
                    <h4>âœ… Dimensiune numÄƒr prim</h4>
                    <div class="code-block" style="margin: 10px 0;">
                        <pre><code class="language-c">/* table_size = 1021 (prim) */
index = hash % 1021;
/* DistribuÈ›ie uniformÄƒ */</code></pre>
                    </div>
                    <p>FoloseÈ™te toÈ›i biÈ›ii efectiv</p>
                </div>
            </div>
        </div>

        <!-- Slide 29: Memory Model -->
        <div class="slide" data-slide="29">
            <h2>ğŸ§  Model de Memorie</h2>
            
            <div class="two-columns animate-in">
                <div class="column">
                    <h4>Chaining</h4>
                    <div class="ascii-box" style="font-size: 0.75em;">
Stack:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ HashTable *htâ”‚â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
                   â–¼
Heap:          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚ buckets: â”€â”€â”€â”€â”‚â”€â”€â”
               â”‚ size: 7      â”‚  â”‚
               â”‚ count: 4     â”‚  â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
                                 â–¼
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚[0][1][2][3][4][5][6]
               â”‚ â†“  â†“              
               â”‚ â”‚  â””â”€â”€â–º Node â”€â”€â–º Node
               â”‚ â””â”€â”€â”€â”€â–º Node
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    </div>
                </div>
                <div class="column">
                    <h4>Open Addressing</h4>
                    <div class="ascii-box" style="font-size: 0.75em;">
Stack:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ HashTable *htâ”‚â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
                   â–¼
Heap:          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚ buckets: â”€â”€â”€â”€â”‚â”€â”€â”
               â”‚ size: 7      â”‚  â”‚
               â”‚ count: 4     â”‚  â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
                                 â–¼
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚[A][B][-][C][-][D][-]
               â”‚ Toate datele inline
               â”‚ Cache-friendly!
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    </div>
                </div>
            </div>
            
            <div class="info-box info animate-in">
                <div class="info-box-title">â„¹ï¸ ImplicaÈ›ii pentru Cache</div>
                Open addressing este mai cache-friendly deoarece datele sunt contigue. Chaining necesitÄƒ urmÄƒrirea pointerilor (cache misses).
            </div>
        </div>

        <!-- Slide 30: Debugging -->
        <div class="slide" data-slide="30">
            <h2>ğŸ” Debugging cu GDB È™i Valgrind</h2>
            
            <div class="code-block animate-in">
                <div class="code-header">
                    <span>Comenzi GDB utile</span>
                    <span class="lang-badge">GDB</span>
                </div>
                <pre><code class="language-bash"># Compilare cu simboluri debug
gcc -g -Wall -o hash_table hash_table.c

# Pornire GDB
gdb ./hash_table

# Ãn GDB:
(gdb) break ht_insert          # Breakpoint la inserare
(gdb) run                       # PorneÈ™te execuÈ›ia
(gdb) print *ht                 # AfiÈ™eazÄƒ structura
(gdb) print ht->buckets[3]      # InspecteazÄƒ bucket-ul 3
(gdb) x/10xw ht->buckets        # AfiÈ™eazÄƒ 10 words din buckets
(gdb) watch ht->count           # Watchpoint pe count</code></pre>
            </div>
            
            <div class="code-block animate-in">
                <div class="code-header">
                    <span>Valgrind pentru memory leaks</span>
                    <span class="lang-badge">Bash</span>
                </div>
                <pre><code class="language-bash"># Verificare memory leaks
valgrind --leak-check=full --show-leak-kinds=all ./hash_table

# Output dorit:
# All heap blocks were freed -- no leaks are possible

# Erori comune detectate:
# - "definitely lost" - ai uitat sÄƒ eliberezi memorie
# - "Invalid read" - accesezi memorie eliberatÄƒ  
# - "Invalid write" - buffer overflow</code></pre>
            </div>
        </div>

        <!-- Slide 31: Best Practices -->
        <div class="slide" data-slide="31">
            <h2>âœ… Bune Practici</h2>
            
            <div class="two-columns animate-in">
                <div class="column">
                    <h4 style="color: var(--accent-green);">DO âœ“</h4>
                    <ul>
                        <li>FoloseÈ™te dimensiuni prime pentru tabelÄƒ</li>
                        <li>MonitorizeazÄƒ load factor</li>
                        <li>RedimensioneazÄƒ proactiv (0.7 pentru open addr)</li>
                        <li>TesteazÄƒ funcÈ›ia hash cu date reale</li>
                        <li>FoloseÈ™te <code>strdup()</code> pentru chei</li>
                        <li>VerificÄƒ cu Valgrind pentru memory leaks</li>
                        <li>ImplementeazÄƒ <code>ht_destroy()</code> complet</li>
                    </ul>
                </div>
                <div class="column">
                    <h4 style="color: var(--accent-red);">DON'T âœ—</h4>
                    <ul>
                        <li>Nu folosi dimensiuni putere a lui 2</li>
                        <li>Nu ignora load factor-ul</li>
                        <li>Nu È™terge direct (NULL) Ã®n open addressing</li>
                        <li>Nu presupune distribuÈ›ie perfectÄƒ</li>
                        <li>Nu stoca pointeri la chei temporare</li>
                        <li>Nu uita sÄƒ eliberezi memoria nodurilor</li>
                        <li>Nu te baza pe ordinea elementelor</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 32: When to Use -->
        <div class="slide" data-slide="32">
            <h2>ğŸ¤” CÃ¢nd sÄƒ FoloseÈ™ti Hash Tables?</h2>
            
            <div class="two-columns animate-in">
                <div class="column" style="border-color: var(--accent-green);">
                    <h4 style="color: var(--accent-green);">âœ… FoloseÈ™te Hash Table cÃ¢nd:</h4>
                    <ul>
                        <li>Ai nevoie de acces rapid O(1)</li>
                        <li>Datele nu trebuie ordonate</li>
                        <li>Cheile sunt unice sau suportÄƒ duplicare</li>
                        <li>È˜tii aproximativ numÄƒrul de elemente</li>
                        <li>Memoria nu este o constrÃ¢ngere criticÄƒ</li>
                    </ul>
                    <p style="margin-top: 15px;"><strong>Exemple:</strong> cache, dicÈ›ionare, seturi, counting, memoization</p>
                </div>
                <div class="column" style="border-color: var(--accent-red);">
                    <h4 style="color: var(--accent-red);">âŒ EvitÄƒ Hash Table cÃ¢nd:</h4>
                    <ul>
                        <li>Ai nevoie de date ordonate</li>
                        <li>Faci multe operaÈ›ii de range</li>
                        <li>Memoria este foarte limitatÄƒ</li>
                        <li>Worst-case O(1) este obligatoriu</li>
                        <li>FuncÈ›ia hash e foarte costisitoare</li>
                    </ul>
                    <p style="margin-top: 15px;"><strong>Alternative:</strong> BST, AVL, B-tree, skip list</p>
                </div>
            </div>
        </div>

        <!-- Slide 33: Real World Examples -->
        <div class="slide" data-slide="33">
            <h2>ğŸŒ Exemple din Lumea RealÄƒ</h2>
            
            <div class="key-points animate-in">
                <div class="key-point">
                    <div class="key-point-icon">ğŸ</div>
                    <div class="key-point-title">Python dict</div>
                    <p>Open addressing cu perturbÄƒri</p>
                </div>
                <div class="key-point">
                    <div class="key-point-icon">â˜•</div>
                    <div class="key-point-title">Java HashMap</div>
                    <p>Chaining + TreeMap la 8 elem</p>
                </div>
                <div class="key-point">
                    <div class="key-point-icon">ğŸ”´</div>
                    <div class="key-point-title">Redis</div>
                    <p>Dict propriu cu rehashing incremental</p>
                </div>
            </div>
            
            <div class="key-points animate-in">
                <div class="key-point">
                    <div class="key-point-icon">ğŸŒ</div>
                    <div class="key-point-title">DNS Cache</div>
                    <p>Mapare hostname â†’ IP</p>
                </div>
                <div class="key-point">
                    <div class="key-point-icon">ğŸ”</div>
                    <div class="key-point-title">Password Storage</div>
                    <p>bcrypt, Argon2 hashes</p>
                </div>
                <div class="key-point">
                    <div class="key-point-icon">ğŸ“¦</div>
                    <div class="key-point-title">Symbol Tables</div>
                    <p>Compilatoare, interpretoare</p>
                </div>
            </div>
        </div>

        <!-- Slide 34: Laboratory Preview -->
        <div class="slide" data-slide="34">
            <h2>ğŸ’» Previzualizare Laborator</h2>
            
            <div class="two-columns animate-in">
                <div class="column">
                    <h3>ExerciÈ›iul 1: Chaining</h3>
                    <ul>
                        <li>Implementare completÄƒ HashNode È™i HashTable</li>
                        <li>FuncÈ›ia hash djb2</li>
                        <li>Insert, Search, Delete</li>
                        <li>Redimensionare automatÄƒ la Î± &gt; 2.0</li>
                        <li>Statistici: load factor, lungimi liste</li>
                        <li>~10 TODO markers</li>
                    </ul>
                </div>
                <div class="column">
                    <h3>ExerciÈ›iul 2: Open Addressing</h3>
                    <ul>
                        <li>Linear probing cu DELETED markers</li>
                        <li>Double hashing pentru comparaÈ›ie</li>
                        <li>Detectarea clustering-ului</li>
                        <li>Redimensionare la Î± &gt; 0.7</li>
                        <li>Benchmark cu 10.000+ inserÄƒri</li>
                        <li>~12 TODO markers</li>
                    </ul>
                </div>
            </div>
            
            <div class="info-box tip animate-in">
                <div class="info-box-title">ğŸ’¡ Sfat</div>
                Ãncepe cu funcÈ›ia hash È™i testeazÄƒ-o separat Ã®nainte de a implementa tabela completÄƒ!
            </div>
        </div>

        <!-- Slide 35: Key Takeaways -->
        <div class="slide" data-slide="35">
            <h2>ğŸ¯ Concluzii Cheie</h2>
            
            <div class="key-points animate-in">
                <div class="key-point">
                    <div class="key-point-icon">âš¡</div>
                    <div class="key-point-title">O(1) Amortizat</div>
                    <p>Insert, Search, Delete Ã®n timp constant mediu</p>
                </div>
                <div class="key-point">
                    <div class="key-point-icon">ğŸ”‘</div>
                    <div class="key-point-title">FuncÈ›ie Hash</div>
                    <p>DistribuÈ›ie uniformÄƒ, dimensiune primÄƒ</p>
                </div>
                <div class="key-point">
                    <div class="key-point-icon">ğŸ’¥</div>
                    <div class="key-point-title">Coliziuni</div>
                    <p>Chaining vs Open Addressing</p>
                </div>
            </div>
            
            <div class="key-points animate-in">
                <div class="key-point">
                    <div class="key-point-icon">ğŸ“Š</div>
                    <div class="key-point-title">Load Factor</div>
                    <p>Chaining: Î± &lt; 2, Open: Î± &lt; 0.7</p>
                </div>
                <div class="key-point">
                    <div class="key-point-icon">ğŸ—‘ï¸</div>
                    <div class="key-point-title">DELETED Marker</div>
                    <p>EsenÈ›ial Ã®n open addressing</p>
                </div>
                <div class="key-point">
                    <div class="key-point-icon">ğŸ”„</div>
                    <div class="key-point-title">Redimensionare</div>
                    <p>Rehashing complet, O(n) rar</p>
                </div>
            </div>
        </div>

        <!-- Slide 36: Resources -->
        <div class="slide" data-slide="36">
            <h2>ğŸ“š Resurse</h2>
            
            <div class="two-columns animate-in">
                <div class="column">
                    <h4>ğŸ“– CÄƒrÈ›i</h4>
                    <ul>
                        <li><strong>CLRS</strong> - "Introduction to Algorithms", Cap. 11</li>
                        <li><strong>Knuth</strong> - "TAOCP" Vol. 3, Cap. 6.4</li>
                        <li><strong>Sedgewick</strong> - "Algorithms in C", Cap. 14</li>
                    </ul>
                    
                    <h4 style="margin-top: 25px;">ğŸ¥ Video</h4>
                    <ul>
                        <li>MIT OCW 6.006 - Lecture 8: Hashing</li>
                        <li>CS50 - Hash Tables</li>
                    </ul>
                </div>
                <div class="column">
                    <h4>ğŸŒ Online</h4>
                    <ul>
                        <li><a href="https://visualgo.net/en/hashtable" style="color: var(--accent-blue);">VisualGo - Hash Table Visualization</a></li>
                        <li><a href="https://www.cs.usfca.edu/~galles/visualization/OpenHash.html" style="color: var(--accent-blue);">USF - Open Addressing Visualization</a></li>
                        <li>GeeksforGeeks - Hashing Tutorial</li>
                    </ul>
                    
                    <h4 style="margin-top: 25px;">ğŸ”¬ Papers</h4>
                    <ul>
                        <li>Pagh & Rodler - "Cuckoo Hashing"</li>
                        <li>Knuth - "Analysis of Linear Probing"</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 37: Questions -->
        <div class="slide" data-slide="37">
            <div class="title-slide">
                <div class="key-point-icon" style="font-size: 5em;">â“</div>
                <h1>ÃntrebÄƒri?</h1>
                <div class="subtitle">SÄƒptÄƒmÃ¢na 11: Hash Tables</div>
                <br><br>
                <div class="info-box info" style="text-align: left; max-width: 600px;">
                    <div class="info-box-title">ğŸ“… SÄƒptÄƒmÃ¢na UrmÄƒtoare</div>
                    <p><strong>Grafuri - Concepte de BazÄƒ</strong></p>
                    <ul>
                        <li>ReprezentÄƒri: matrice vs. liste de adiacenÈ›Äƒ</li>
                        <li>Parcurgeri: BFS È™i DFS</li>
                        <li>AplicaÈ›ii practice</li>
                    </ul>
                </div>
            </div>
        </div>

    </div>

    <div class="slide-counter" id="slideCounter">1 / 37</div>
    
    <div class="nav-container">
        <button class="nav-btn" id="prevBtn" onclick="prevSlide()">â† Ãnapoi</button>
        <button class="nav-btn" id="nextBtn" onclick="nextSlide()">Ãnainte â†’</button>
    </div>

    <script>
        let currentSlide = 1;
        const totalSlides = 37;

        function showSlide(n) {
            const slides = document.querySelectorAll('.slide');
            
            if (n < 1) currentSlide = 1;
            else if (n > totalSlides) currentSlide = totalSlides;
            else currentSlide = n;

            slides.forEach(slide => {
                slide.classList.remove('active');
            });

            const activeSlide = document.querySelector(`[data-slide="${currentSlide}"]`);
            if (activeSlide) {
                activeSlide.classList.add('active');
            }

            // Update progress bar
            const progress = (currentSlide / totalSlides) * 100;
            document.getElementById('progressBar').style.width = progress + '%';

            // Update counter
            document.getElementById('slideCounter').textContent = `${currentSlide} / ${totalSlides}`;

            // Update buttons
            document.getElementById('prevBtn').disabled = currentSlide === 1;
            document.getElementById('nextBtn').disabled = currentSlide === totalSlides;

            // Highlight code
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
        }

        function nextSlide() {
            showSlide(currentSlide + 1);
        }

        function prevSlide() {
            showSlide(currentSlide - 1);
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowRight':
                case ' ':
                    e.preventDefault();
                    nextSlide();
                    break;
                case 'ArrowLeft':
                    prevSlide();
                    break;
                case 'Home':
                    showSlide(1);
                    break;
                case 'End':
                    showSlide(totalSlides);
                    break;
            }
        });

        // Touch support for mobile
        let touchStartX = 0;
        let touchEndX = 0;

        document.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
        });

        document.addEventListener('touchend', (e) => {
            touchEndX = e.changedTouches[0].screenX;
            if (touchStartX - touchEndX > 50) nextSlide();
            if (touchEndX - touchStartX > 50) prevSlide();
        });

        // Initialize
        showSlide(1);
    </script>
</body>
</html>
