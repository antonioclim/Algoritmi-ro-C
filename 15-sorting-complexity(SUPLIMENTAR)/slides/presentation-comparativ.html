<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SÄƒptÄƒmÃ¢na 15: Comparativ Pseudocod/C/Python | ATP</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-yellow: #d29922;
            --accent-red: #f85149;
            --accent-purple: #a371f7;
            --border-color: #30363d;
            --pseudocode-bg: #1a2332;
            --c-bg: #1a1f29;
            --python-bg: #1f2a1a;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        #progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-green), var(--accent-yellow));
            transition: width 0.3s ease;
            z-index: 1000;
        }

        .slide {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 50px 60px;
            opacity: 0;
            transition: opacity 0.4s ease;
            overflow-y: auto;
        }

        .slide.active {
            display: flex;
            flex-direction: column;
            opacity: 1;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 15px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        h2 {
            font-size: 1.8em;
            color: var(--accent-blue);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border-color);
        }

        .three-column {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            flex: 1;
            margin: 15px 0;
        }

        .code-panel {
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }

        .code-panel.pseudocode { background: var(--pseudocode-bg); }
        .code-panel.c-lang { background: var(--c-bg); }
        .code-panel.python { background: var(--python-bg); }

        .panel-header {
            padding: 10px 15px;
            font-weight: 600;
            font-size: 0.95em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .pseudocode .panel-header { background: #2a3a52; color: var(--accent-blue); }
        .c-lang .panel-header { background: #2a2f39; color: var(--accent-yellow); }
        .python .panel-header { background: #2f3a2a; color: var(--accent-green); }

        .lang-icon {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            font-weight: 700;
        }

        .pseudocode .lang-icon { background: var(--accent-blue); color: var(--bg-primary); }
        .c-lang .lang-icon { background: var(--accent-yellow); color: var(--bg-primary); }
        .python .lang-icon { background: var(--accent-green); color: var(--bg-primary); }

        .panel-content {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
        }

        pre {
            font-size: 0.8em;
            line-height: 1.5;
            overflow-x: auto;
        }

        code {
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
        }

        .title-slide {
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .title-slide h1 { font-size: 3em; margin-bottom: 30px; }
        .title-slide .subtitle { font-size: 1.5em; color: var(--text-secondary); margin-bottom: 20px; }

        .note-box {
            background: var(--bg-secondary);
            border-left: 4px solid var(--accent-purple);
            padding: 12px 15px;
            margin: 10px 0;
            font-size: 0.95em;
            border-radius: 0 6px 6px 0;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            right: 30px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .control-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 10px 18px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .control-btn:hover {
            background: var(--accent-blue);
            color: var(--bg-primary);
        }

        #slide-counter {
            position: fixed;
            bottom: 20px;
            left: 30px;
            color: var(--text-secondary);
            z-index: 100;
        }

        .keyboard-hints {
            position: fixed;
            bottom: 55px;
            left: 30px;
            font-size: 0.8em;
            color: var(--text-secondary);
        }

        .keyboard-hints kbd {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="progress-bar"></div>

    <div id="presentation">
        <!-- Slide 1: Titlu -->
        <div class="slide title-slide active" data-slide="1">
            <h1>Algoritmi de Sortare AvansaÈ›i</h1>
            <p class="subtitle">ComparaÈ›ie: Pseudocod | C | Python</p>
            <p style="color: var(--text-secondary);">SÄƒptÄƒmÃ¢na 15 â€¢ ATP â€¢ ASE BucureÈ™ti</p>
        </div>

        <!-- Slide 2: Quick Sort - PartiÈ›ionare -->
        <div class="slide" data-slide="2">
            <h2>Quick Sort - PartiÈ›ionare Lomuto</h2>
            <div class="three-column">
                <div class="code-panel pseudocode">
                    <div class="panel-header"><span class="lang-icon">ğŸ“</span>Pseudocod</div>
                    <div class="panel-content">
<pre>PARTITION(A, low, high):
    pivot â† A[high]
    i â† low - 1
    
    FOR j â† low TO high - 1:
        IF A[j] â‰¤ pivot:
            i â† i + 1
            SWAP A[i] â†” A[j]
    
    SWAP A[i + 1] â†” A[high]
    RETURN i + 1

QUICKSORT(A, low, high):
    IF low < high:
        pi â† PARTITION(A, low, high)
        QUICKSORT(A, low, pi - 1)
        QUICKSORT(A, pi + 1, high)</pre>
                    </div>
                </div>
                <div class="code-panel c-lang">
                    <div class="panel-header"><span class="lang-icon">C</span>Limbaj C</div>
                    <div class="panel-content">
<pre><code class="language-c">int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    
    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    
    swap(&arr[i + 1], &arr[high]);
    return i + 1;
}

void quicksort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quicksort(arr, low, pi - 1);
        quicksort(arr, pi + 1, high);
    }
}</code></pre>
                    </div>
                </div>
                <div class="code-panel python">
                    <div class="panel-header"><span class="lang-icon">ğŸ</span>Python</div>
                    <div class="panel-content">
<pre><code class="language-python">def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1
    
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

def quicksort(arr, low, high):
    if low < high:
        pi = partition(arr, low, high)
        quicksort(arr, low, pi - 1)
        quicksort(arr, pi + 1, high)

# Python built-in (Timsort):
# arr.sort() sau sorted(arr)</code></pre>
                    </div>
                </div>
            </div>
            <div class="note-box">
                <strong>ObservaÈ›ie:</strong> Python permite swap Ã®ntr-o singurÄƒ linie: <code>a, b = b, a</code>
            </div>
        </div>

        <!-- Slide 3: Quick Sort - Pivot Aleator -->
        <div class="slide" data-slide="3">
            <h2>Quick Sort - Pivot Aleator (Randomized)</h2>
            <div class="three-column">
                <div class="code-panel pseudocode">
                    <div class="panel-header"><span class="lang-icon">ğŸ“</span>Pseudocod</div>
                    <div class="panel-content">
<pre>RANDOM-PARTITION(A, low, high):
    // Alegem index aleator
    rand_idx â† RANDOM(low, high)
    
    // MutÄƒm pivotul la final
    SWAP A[rand_idx] â†” A[high]
    
    // PartiÈ›ionare standard
    RETURN PARTITION(A, low, high)

// Complexitate medie: O(n log n)
// Worst-case evitat probabilistic</pre>
                    </div>
                </div>
                <div class="code-panel c-lang">
                    <div class="panel-header"><span class="lang-icon">C</span>Limbaj C</div>
                    <div class="panel-content">
<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int partition_random(int arr[], int low, int high) {
    // IniÈ›ializare: srand(time(NULL));
    int rand_idx = low + rand() % (high - low + 1);
    
    swap(&arr[rand_idx], &arr[high]);
    
    return partition(arr, low, high);
}

void quicksort_random(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition_random(arr, low, high);
        quicksort_random(arr, low, pi - 1);
        quicksort_random(arr, pi + 1, high);
    }
}</code></pre>
                    </div>
                </div>
                <div class="code-panel python">
                    <div class="panel-header"><span class="lang-icon">ğŸ</span>Python</div>
                    <div class="panel-content">
<pre><code class="language-python">import random

def partition_random(arr, low, high):
    # Alegem pivot aleator
    rand_idx = random.randint(low, high)
    
    # MutÄƒm la final
    arr[rand_idx], arr[high] = arr[high], arr[rand_idx]
    
    return partition(arr, low, high)

def quicksort_random(arr, low, high):
    if low < high:
        pi = partition_random(arr, low, high)
        quicksort_random(arr, low, pi - 1)
        quicksort_random(arr, pi + 1, high)

# One-liner pythonic (nu e eficient):
# sorted_arr = sorted(arr)</code></pre>
                    </div>
                </div>
            </div>
            <div class="note-box">
                <strong>De ce pivot aleator?</strong> EvitÄƒ worst-case O(nÂ²) pe date sortate sau cu pattern-uri.
            </div>
        </div>

        <!-- Slide 4: Merge Sort -->
        <div class="slide" data-slide="4">
            <h2>Merge Sort - Divide et Impera</h2>
            <div class="three-column">
                <div class="code-panel pseudocode">
                    <div class="panel-header"><span class="lang-icon">ğŸ“</span>Pseudocod</div>
                    <div class="panel-content">
<pre>MERGE(A, left, mid, right):
    n1 â† mid - left + 1
    n2 â† right - mid
    
    L[1..n1] â† A[left..mid]
    R[1..n2] â† A[mid+1..right]
    
    i â† 1, j â† 1, k â† left
    WHILE i â‰¤ n1 AND j â‰¤ n2:
        IF L[i] â‰¤ R[j]:
            A[k] â† L[i]; i++
        ELSE:
            A[k] â† R[j]; j++
        k++
    
    // Copiem restul
    WHILE i â‰¤ n1: A[k++] â† L[i++]
    WHILE j â‰¤ n2: A[k++] â† R[j++]

MERGE-SORT(A, left, right):
    IF left < right:
        mid â† (left + right) / 2
        MERGE-SORT(A, left, mid)
        MERGE-SORT(A, mid+1, right)
        MERGE(A, left, mid, right)</pre>
                    </div>
                </div>
                <div class="code-panel c-lang">
                    <div class="panel-header"><span class="lang-icon">C</span>Limbaj C</div>
                    <div class="panel-content">
<pre><code class="language-c">void merge(int arr[], int l, int m, int r) {
    int n1 = m - l + 1, n2 = r - m;
    int *L = malloc(n1 * sizeof(int));
    int *R = malloc(n2 * sizeof(int));
    
    for (int i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];
    
    int i = 0, j = 0, k = l;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j])
            arr[k++] = L[i++];
        else
            arr[k++] = R[j++];
    }
    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];
    
    free(L); free(R);
}

void merge_sort(int arr[], int l, int r) {
    if (l < r) {
        int m = l + (r - l) / 2;
        merge_sort(arr, l, m);
        merge_sort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}</code></pre>
                    </div>
                </div>
                <div class="code-panel python">
                    <div class="panel-header"><span class="lang-icon">ğŸ</span>Python</div>
                    <div class="panel-content">
<pre><code class="language-python">def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    return result

# Alternativ (in-place e mai complex)</code></pre>
                    </div>
                </div>
            </div>
            <div class="note-box">
                <strong>Python:</strong> Versiunea funcÈ›ionalÄƒ e mai elegantÄƒ dar creeazÄƒ copii. C trebuie sÄƒ gestioneze memoria explicit.
            </div>
        </div>

        <!-- Slide 5: Heap Sort -->
        <div class="slide" data-slide="5">
            <h2>Heap Sort - Heapify È™i Sortare</h2>
            <div class="three-column">
                <div class="code-panel pseudocode">
                    <div class="panel-header"><span class="lang-icon">ğŸ“</span>Pseudocod</div>
                    <div class="panel-content">
<pre>HEAPIFY(A, n, i):
    largest â† i
    left â† 2*i + 1
    right â† 2*i + 2
    
    IF left < n AND A[left] > A[largest]:
        largest â† left
    IF right < n AND A[right] > A[largest]:
        largest â† right
    
    IF largest â‰  i:
        SWAP A[i] â†” A[largest]
        HEAPIFY(A, n, largest)

HEAP-SORT(A, n):
    // Build max-heap
    FOR i â† n/2 - 1 DOWNTO 0:
        HEAPIFY(A, n, i)
    
    // Extract max repetat
    FOR i â† n - 1 DOWNTO 1:
        SWAP A[0] â†” A[i]
        HEAPIFY(A, i, 0)</pre>
                    </div>
                </div>
                <div class="code-panel c-lang">
                    <div class="panel-header"><span class="lang-icon">C</span>Limbaj C</div>
                    <div class="panel-content">
<pre><code class="language-c">void heapify(int arr[], int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    
    if (left < n && arr[left] > arr[largest])
        largest = left;
    if (right < n && arr[right] > arr[largest])
        largest = right;
    
    if (largest != i) {
        swap(&arr[i], &arr[largest]);
        heapify(arr, n, largest);
    }
}

void heap_sort(int arr[], int n) {
    // Build max-heap
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);
    
    // Extract max
    for (int i = n - 1; i > 0; i--) {
        swap(&arr[0], &arr[i]);
        heapify(arr, i, 0);
    }
}</code></pre>
                    </div>
                </div>
                <div class="code-panel python">
                    <div class="panel-header"><span class="lang-icon">ğŸ</span>Python</div>
                    <div class="panel-content">
<pre><code class="language-python">def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < n and arr[left] > arr[largest]:
        largest = left
    if right < n and arr[right] > arr[largest]:
        largest = right
    
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)
    
    # Build max-heap
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # Extract max
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)

# Python heapq (min-heap):
# import heapq
# heapq.heapify(arr)</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 6: Counting Sort -->
        <div class="slide" data-slide="6">
            <h2>Counting Sort - O(n + k) Liniar</h2>
            <div class="three-column">
                <div class="code-panel pseudocode">
                    <div class="panel-header"><span class="lang-icon">ğŸ“</span>Pseudocod</div>
                    <div class="panel-content">
<pre>COUNTING-SORT(A, n, k):
    // k = valoarea maximÄƒ
    C[0..k] â† 0  // Array de numÄƒrare
    B[1..n] â† 0  // Array rezultat
    
    // Pas 1: NumÄƒrare
    FOR i â† 1 TO n:
        C[A[i]] â† C[A[i]] + 1
    
    // Pas 2: Prefix sum
    FOR i â† 1 TO k:
        C[i] â† C[i] + C[i-1]
    
    // Pas 3: Plasare (stabil)
    FOR i â† n DOWNTO 1:
        B[C[A[i]]] â† A[i]
        C[A[i]] â† C[A[i]] - 1
    
    RETURN B

// Complexitate: O(n + k)
// Stabil: DA</pre>
                    </div>
                </div>
                <div class="code-panel c-lang">
                    <div class="panel-header"><span class="lang-icon">C</span>Limbaj C</div>
                    <div class="panel-content">
<pre><code class="language-c">void counting_sort(int arr[], int n, int max_val) {
    int *count = calloc(max_val + 1, sizeof(int));
    int *output = malloc(n * sizeof(int));
    
    // NumÄƒrare
    for (int i = 0; i < n; i++)
        count[arr[i]]++;
    
    // Prefix sum
    for (int i = 1; i <= max_val; i++)
        count[i] += count[i - 1];
    
    // Plasare stabilÄƒ (de la sfÃ¢rÈ™it)
    for (int i = n - 1; i >= 0; i--) {
        output[count[arr[i]] - 1] = arr[i];
        count[arr[i]]--;
    }
    
    // Copiem rezultatul
    for (int i = 0; i < n; i++)
        arr[i] = output[i];
    
    free(count);
    free(output);
}</code></pre>
                    </div>
                </div>
                <div class="code-panel python">
                    <div class="panel-header"><span class="lang-icon">ğŸ</span>Python</div>
                    <div class="panel-content">
<pre><code class="language-python">def counting_sort(arr, max_val=None):
    if not arr:
        return arr
    
    if max_val is None:
        max_val = max(arr)
    
    count = [0] * (max_val + 1)
    output = [0] * len(arr)
    
    # NumÄƒrare
    for x in arr:
        count[x] += 1
    
    # Prefix sum
    for i in range(1, len(count)):
        count[i] += count[i - 1]
    
    # Plasare stabilÄƒ
    for x in reversed(arr):
        output[count[x] - 1] = x
        count[x] -= 1
    
    return output

# Varianta simplÄƒ (nu e stabilÄƒ):
# from collections import Counter
# sorted_arr = sorted(arr)</code></pre>
                    </div>
                </div>
            </div>
            <div class="note-box">
                <strong>CÃ¢nd folosim?</strong> CÃ¢nd k (intervalul de valori) este mic relativ la n. Ex: sortare note 1-10, caractere ASCII.
            </div>
        </div>

        <!-- Slide 7: Radix Sort LSD -->
        <div class="slide" data-slide="7">
            <h2>Radix Sort LSD - Sortare pe Cifre</h2>
            <div class="three-column">
                <div class="code-panel pseudocode">
                    <div class="panel-header"><span class="lang-icon">ğŸ“</span>Pseudocod</div>
                    <div class="panel-content">
<pre>RADIX-SORT-LSD(A, n, d):
    // d = numÄƒrul de cifre
    FOR digit â† 1 TO d:
        // Sortare stabilÄƒ pe cifra curentÄƒ
        COUNTING-SORT-BY-DIGIT(A, n, digit)

GET-DIGIT(x, pos, base):
    RETURN (x / base^pos) MOD base

COUNTING-SORT-BY-DIGIT(A, n, pos):
    count[0..9] â† 0
    
    FOR i â† 1 TO n:
        d â† GET-DIGIT(A[i], pos, 10)
        count[d]++
    
    // Prefix sum È™i plasare
    // (similar cu Counting Sort)</pre>
                    </div>
                </div>
                <div class="code-panel c-lang">
                    <div class="panel-header"><span class="lang-icon">C</span>Limbaj C</div>
                    <div class="panel-content">
<pre><code class="language-c">int get_max(int arr[], int n) {
    int max = arr[0];
    for (int i = 1; i < n; i++)
        if (arr[i] > max) max = arr[i];
    return max;
}

void count_sort_digit(int arr[], int n, int exp) {
    int *output = malloc(n * sizeof(int));
    int count[10] = {0};
    
    for (int i = 0; i < n; i++)
        count[(arr[i] / exp) % 10]++;
    
    for (int i = 1; i < 10; i++)
        count[i] += count[i - 1];
    
    for (int i = n - 1; i >= 0; i--) {
        int d = (arr[i] / exp) % 10;
        output[count[d] - 1] = arr[i];
        count[d]--;
    }
    
    for (int i = 0; i < n; i++)
        arr[i] = output[i];
    free(output);
}

void radix_sort(int arr[], int n) {
    int m = get_max(arr, n);
    for (int exp = 1; m / exp > 0; exp *= 10)
        count_sort_digit(arr, n, exp);
}</code></pre>
                    </div>
                </div>
                <div class="code-panel python">
                    <div class="panel-header"><span class="lang-icon">ğŸ</span>Python</div>
                    <div class="panel-content">
<pre><code class="language-python">def counting_sort_digit(arr, exp):
    n = len(arr)
    output = [0] * n
    count = [0] * 10
    
    for x in arr:
        d = (x // exp) % 10
        count[d] += 1
    
    for i in range(1, 10):
        count[i] += count[i - 1]
    
    for x in reversed(arr):
        d = (x // exp) % 10
        output[count[d] - 1] = x
        count[d] -= 1
    
    return output

def radix_sort(arr):
    if not arr:
        return arr
    
    max_val = max(arr)
    exp = 1
    
    while max_val // exp > 0:
        arr = counting_sort_digit(arr, exp)
        exp *= 10
    
    return arr</code></pre>
                    </div>
                </div>
            </div>
            <div class="note-box">
                <strong>Complexitate:</strong> O(d Ã— (n + k)) unde d = numÄƒr cifre, k = baza (10). Pentru numere de 32-bit: O(n).
            </div>
        </div>

        <!-- Slide 8: Introsort -->
        <div class="slide" data-slide="8">
            <h2>Introsort - Algoritm Hibrid Industrial</h2>
            <div class="three-column">
                <div class="code-panel pseudocode">
                    <div class="panel-header"><span class="lang-icon">ğŸ“</span>Pseudocod</div>
                    <div class="panel-content">
<pre>INTROSORT(A, n):
    max_depth â† 2 Ã— floor(logâ‚‚(n))
    INTROSORT-HELPER(A, 0, n-1, max_depth)

INTROSORT-HELPER(A, low, high, depth):
    size â† high - low + 1
    
    // Array mic â†’ Insertion Sort
    IF size < 16:
        INSERTION-SORT(A, low, high)
        RETURN
    
    // Recursiune prea adÃ¢ncÄƒ â†’ Heap Sort
    IF depth = 0:
        HEAP-SORT(A, low, high)
        RETURN
    
    // Normal â†’ Quick Sort
    pivot â† PARTITION(A, low, high)
    INTROSORT-HELPER(A, low, pivot-1, depth-1)
    INTROSORT-HELPER(A, pivot+1, high, depth-1)

// Folosit Ã®n: C++ std::sort()</pre>
                    </div>
                </div>
                <div class="code-panel c-lang">
                    <div class="panel-header"><span class="lang-icon">C</span>Limbaj C</div>
                    <div class="panel-content">
<pre><code class="language-c">#include &lt;math.h&gt;
#define THRESHOLD 16

void insertion_sort_range(int arr[], int lo, int hi) {
    for (int i = lo + 1; i <= hi; i++) {
        int key = arr[i], j = i - 1;
        while (j >= lo && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}

void introsort_impl(int arr[], int lo, int hi, int depth) {
    int size = hi - lo + 1;
    
    if (size < THRESHOLD) {
        insertion_sort_range(arr, lo, hi);
        return;
    }
    
    if (depth == 0) {
        // Heap sort pe subarray
        heap_sort_range(arr, lo, hi);
        return;
    }
    
    int p = partition(arr, lo, hi);
    introsort_impl(arr, lo, p - 1, depth - 1);
    introsort_impl(arr, p + 1, hi, depth - 1);
}

void introsort(int arr[], int n) {
    int depth = 2 * (int)log2(n);
    introsort_impl(arr, 0, n - 1, depth);
}</code></pre>
                    </div>
                </div>
                <div class="code-panel python">
                    <div class="panel-header"><span class="lang-icon">ğŸ</span>Python</div>
                    <div class="panel-content">
<pre><code class="language-python">import math

THRESHOLD = 16

def insertion_sort_range(arr, lo, hi):
    for i in range(lo + 1, hi + 1):
        key = arr[i]
        j = i - 1
        while j >= lo and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

def introsort_impl(arr, lo, hi, depth):
    size = hi - lo + 1
    
    if size < THRESHOLD:
        insertion_sort_range(arr, lo, hi)
        return
    
    if depth == 0:
        # Heap sort pe subarray
        heapify_range(arr, lo, hi)
        return
    
    p = partition(arr, lo, hi)
    introsort_impl(arr, lo, p - 1, depth - 1)
    introsort_impl(arr, p + 1, hi, depth - 1)

def introsort(arr):
    n = len(arr)
    depth = 2 * int(math.log2(n)) if n > 1 else 0
    introsort_impl(arr, 0, n - 1, depth)

# Python nativ foloseÈ™te Timsort:
# arr.sort()</code></pre>
                    </div>
                </div>
            </div>
            <div class="note-box">
                <strong>Python's Timsort:</strong> Hibrid Merge Sort + Insertion Sort, optimizat pentru date din lumea realÄƒ.
            </div>
        </div>

        <!-- Slide 9: Benchmark Comparison -->
        <div class="slide" data-slide="9">
            <h2>ComparaÈ›ie PerformanÈ›Äƒ - 100.000 elemente</h2>
            <div class="three-column">
                <div class="code-panel pseudocode">
                    <div class="panel-header"><span class="lang-icon">ğŸ“Š</span>Rezultate Random</div>
                    <div class="panel-content">
<pre style="font-size: 0.85em;">
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘      BENCHMARK SORTING            â•‘
â•‘      n = 100,000 elements         â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Algorithm     â”‚ Time    â”‚ Stable  â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Quick Sort    â”‚ 12 ms   â”‚   No    â•‘
â•‘ Merge Sort    â”‚ 18 ms   â”‚   Yes   â•‘
â•‘ Heap Sort     â”‚ 22 ms   â”‚   No    â•‘
â•‘ Introsort     â”‚ 11 ms   â”‚   No    â•‘
â•‘ Timsort       â”‚ 15 ms   â”‚   Yes   â•‘
â•‘ Counting*     â”‚  3 ms   â”‚   Yes   â•‘
â•‘ Radix*        â”‚  5 ms   â”‚   Yes   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
* Pentru interval mic de valori

Winner: Introsort (General)
        Counting (Special)
</pre>
                    </div>
                </div>
                <div class="code-panel c-lang">
                    <div class="panel-header"><span class="lang-icon">C</span>Cod Benchmark C</div>
                    <div class="panel-content">
<pre><code class="language-c">#include &lt;time.h&gt;

double benchmark(void (*sort_fn)(int*, int), 
                 int arr[], int n) {
    clock_t start = clock();
    sort_fn(arr, n);
    clock_t end = clock();
    return (double)(end - start) * 1000 
           / CLOCKS_PER_SEC;
}

int main() {
    int n = 100000;
    int *arr = generate_random(n);
    int *copy = malloc(n * sizeof(int));
    
    // Test Quick Sort
    memcpy(copy, arr, n * sizeof(int));
    printf("Quick: %.2f ms\n", 
           benchmark(quick_sort, copy, n));
    
    // Test Merge Sort
    memcpy(copy, arr, n * sizeof(int));
    printf("Merge: %.2f ms\n", 
           benchmark(merge_sort, copy, n));
    
    free(arr);
    free(copy);
    return 0;
}</code></pre>
                    </div>
                </div>
                <div class="code-panel python">
                    <div class="panel-header"><span class="lang-icon">ğŸ</span>Cod Benchmark Python</div>
                    <div class="panel-content">
<pre><code class="language-python">import time
import random

def benchmark(sort_fn, arr):
    data = arr.copy()
    start = time.perf_counter()
    sort_fn(data)
    end = time.perf_counter()
    return (end - start) * 1000

# Generate test data
n = 100000
arr = [random.randint(0, n) for _ in range(n)]

# Test implementÄƒri proprii
print(f"Quick: {benchmark(quicksort, arr):.2f} ms")
print(f"Merge: {benchmark(merge_sort, arr):.2f} ms")
print(f"Heap:  {benchmark(heap_sort, arr):.2f} ms")

# Test built-in (Timsort)
print(f"sorted(): {benchmark(sorted, arr):.2f} ms")

# Rezultat tipic:
# sorted() este MULT mai rapid
# datoritÄƒ implementÄƒrii Ã®n C</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 10: Summary -->
        <div class="slide" data-slide="10">
            <h2>ğŸ“‹ Rezumat Comparativ</h2>
            <div class="three-column">
                <div class="code-panel pseudocode">
                    <div class="panel-header"><span class="lang-icon">ğŸ“</span>Avantaje Pseudocod</div>
                    <div class="panel-content">
<pre style="font-size: 1em; line-height: 1.8;">
âœ“ Independent de limbaj
âœ“ Focalizat pe algoritm
âœ“ UÈ™or de Ã®nÈ›eles
âœ“ Perfect pentru analizÄƒ
âœ“ Standard Ã®n literaturÄƒ

Folosit Ã®n:
â€¢ CÄƒrÈ›i (CLRS, Sedgewick)
â€¢ Articole academice
â€¢ DocumentaÈ›ie algoritmi
â€¢ Examene È™i interviuri
</pre>
                    </div>
                </div>
                <div class="code-panel c-lang">
                    <div class="panel-header"><span class="lang-icon">C</span>Avantaje C</div>
                    <div class="panel-content">
<pre style="font-size: 1em; line-height: 1.8;">
âœ“ Control total memorie
âœ“ PerformanÈ›Äƒ maximÄƒ
âœ“ Portabil
âœ“ Standard Ã®n industrie
âœ“ Acces low-level

ConsideraÈ›ii:
â€¢ Gestionare manualÄƒ memorie
â€¢ Pointer arithmetic
â€¢ Buffer overflows
â€¢ Validare input
â€¢ Thread safety
</pre>
                    </div>
                </div>
                <div class="code-panel python">
                    <div class="panel-header"><span class="lang-icon">ğŸ</span>Avantaje Python</div>
                    <div class="panel-content">
<pre style="font-size: 1em; line-height: 1.8;">
âœ“ Cod concis È™i clar
âœ“ Rapid de implementat
âœ“ Built-ins optimizate
âœ“ Excelent pentru prototip
âœ“ Garbage collection

Folosit Ã®n:
â€¢ Prototipare rapidÄƒ
â€¢ Data science
â€¢ Scripting
â€¢ Interviuri (Whiteboard)
â€¢ CompetiÈ›ii (uneori)
</pre>
                    </div>
                </div>
            </div>
            <div class="note-box" style="text-align: center; font-size: 1.1em;">
                <strong>Recomandare:</strong> ÃnÈ›elegeÈ›i algoritmul Ã®n pseudocod â†’ ImplementaÈ›i Ã®n C pentru performanÈ›Äƒ â†’ FolosiÈ›i Python pentru prototip/verificare
            </div>
        </div>

        <!-- Slide 11: Final -->
        <div class="slide title-slide" data-slide="11">
            <h1>MulÈ›umesc!</h1>
            <p class="subtitle">Algoritmi de Sortare - Comparativ</p>
            <p style="color: var(--text-secondary);">
                SÄƒptÄƒmÃ¢na 15 â€¢ ATP<br>
                Academia de Studii Economice din BucureÈ™ti
            </p>
        </div>
    </div>

    <div id="slide-counter"></div>
    <div class="keyboard-hints">
        <kbd>â†</kbd> <kbd>â†’</kbd> navigare
    </div>
    
    <div id="controls">
        <button class="control-btn" onclick="prevSlide()">â—€</button>
        <button class="control-btn" onclick="nextSlide()">â–¶</button>
    </div>

    <script>
        let currentSlide = 1;
        const totalSlides = document.querySelectorAll('.slide').length;

        function showSlide(n) {
            if (n < 1) n = 1;
            if (n > totalSlides) n = totalSlides;
            
            document.querySelectorAll('.slide').forEach(s => s.classList.remove('active'));
            document.querySelector(`[data-slide="${n}"]`).classList.add('active');
            currentSlide = n;
            
            document.getElementById('progress-bar').style.width = ((currentSlide / totalSlides) * 100) + '%';
            document.getElementById('slide-counter').textContent = `${currentSlide} / ${totalSlides}`;
        }

        function nextSlide() { showSlide(currentSlide + 1); }
        function prevSlide() { showSlide(currentSlide - 1); }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === ' ') nextSlide();
            else if (e.key === 'ArrowLeft') prevSlide();
            else if (e.key === 'Home') showSlide(1);
            else if (e.key === 'End') showSlide(totalSlides);
        });

        showSlide(1);
        hljs.highlightAll();
    </script>
</body>
</html>
