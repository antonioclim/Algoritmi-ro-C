<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SÄƒptÄƒmÃ¢na 15: Algoritmi de Sortare AvansaÈ›i | ATP</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-yellow: #d29922;
            --accent-red: #f85149;
            --accent-purple: #a371f7;
            --accent-orange: #f0883e;
            --border-color: #30363d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        #progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            transition: width 0.3s ease;
            z-index: 1000;
        }

        #presentation {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        .slide {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 60px 80px;
            opacity: 0;
            transition: opacity 0.4s ease;
            overflow-y: auto;
        }

        .slide.active {
            display: flex;
            flex-direction: column;
            opacity: 1;
        }

        h1 {
            font-size: 2.8em;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 20px;
            line-height: 1.2;
        }

        h2 {
            font-size: 2.2em;
            font-weight: 600;
            color: var(--accent-blue);
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border-color);
        }

        h3 {
            font-size: 1.5em;
            color: var(--accent-green);
            margin: 20px 0 15px 0;
        }

        p {
            font-size: 1.3em;
            line-height: 1.7;
            color: var(--text-primary);
            margin-bottom: 20px;
        }

        ul, ol {
            font-size: 1.25em;
            line-height: 1.8;
            margin-left: 30px;
            margin-bottom: 20px;
        }

        li {
            margin-bottom: 12px;
        }

        li::marker {
            color: var(--accent-blue);
        }

        .code-block {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin: 20px 0;
            overflow: hidden;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .lang-badge {
            background: var(--accent-blue);
            color: var(--bg-primary);
            padding: 3px 10px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.85em;
        }

        pre {
            padding: 20px;
            overflow-x: auto;
            font-size: 0.95em;
            line-height: 1.5;
        }

        code {
            font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
        }

        .highlight-box {
            background: var(--bg-secondary);
            border-left: 4px solid var(--accent-blue);
            padding: 20px 25px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .warning-box {
            background: rgba(248, 81, 73, 0.1);
            border-left: 4px solid var(--accent-red);
            padding: 20px 25px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .success-box {
            background: rgba(63, 185, 80, 0.1);
            border-left: 4px solid var(--accent-green);
            padding: 20px 25px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .info-box {
            background: rgba(136, 198, 255, 0.1);
            border-left: 4px solid var(--accent-purple);
            padding: 20px 25px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            margin: 20px 0;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 1.1em;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 15px 20px;
            text-align: left;
            border: 1px solid var(--border-color);
        }

        .comparison-table th {
            background: var(--bg-tertiary);
            color: var(--accent-blue);
            font-weight: 600;
        }

        .comparison-table tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        .complexity {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.9em;
        }

        .complexity.excellent {
            background: rgba(63, 185, 80, 0.2);
            color: var(--accent-green);
        }

        .complexity.good {
            background: rgba(88, 166, 255, 0.2);
            color: var(--accent-blue);
        }

        .complexity.average {
            background: rgba(210, 153, 34, 0.2);
            color: var(--accent-yellow);
        }

        .complexity.poor {
            background: rgba(248, 81, 73, 0.2);
            color: var(--accent-red);
        }

        .ascii-diagram {
            font-family: 'JetBrains Mono', 'Consolas', monospace;
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            overflow-x: auto;
            white-space: pre;
            font-size: 0.9em;
            line-height: 1.4;
        }

        .title-slide {
            justify-content: center;
            align-items: center;
            text-align: center;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
        }

        .title-slide h1 {
            font-size: 3.5em;
            margin-bottom: 30px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .title-slide .subtitle {
            font-size: 1.8em;
            color: var(--text-secondary);
            margin-bottom: 40px;
        }

        .title-slide .info {
            font-size: 1.2em;
            color: var(--text-secondary);
        }

        .historical-figure {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 30px;
            margin: 20px 0;
        }

        .historical-figure h3 {
            color: var(--accent-yellow);
            margin-bottom: 15px;
        }

        .quote {
            font-style: italic;
            color: var(--text-secondary);
            border-left: 3px solid var(--accent-purple);
            padding-left: 20px;
            margin: 20px 0;
            font-size: 1.1em;
        }

        .step-list {
            counter-reset: step;
            list-style: none;
            margin-left: 0;
        }

        .step-list li {
            position: relative;
            padding-left: 50px;
            margin-bottom: 20px;
        }

        .step-list li::before {
            counter-increment: step;
            content: counter(step);
            position: absolute;
            left: 0;
            top: 0;
            width: 35px;
            height: 35px;
            background: var(--accent-blue);
            color: var(--bg-primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
        }

        #controls {
            position: fixed;
            bottom: 30px;
            right: 40px;
            display: flex;
            gap: 15px;
            z-index: 100;
        }

        .control-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.2s ease;
        }

        .control-btn:hover {
            background: var(--accent-blue);
            color: var(--bg-primary);
        }

        #slide-counter {
            position: fixed;
            bottom: 30px;
            left: 40px;
            font-size: 1em;
            color: var(--text-secondary);
            z-index: 100;
        }

        .keyboard-hints {
            position: fixed;
            bottom: 80px;
            left: 40px;
            font-size: 0.85em;
            color: var(--text-secondary);
            z-index: 100;
        }

        .keyboard-hints kbd {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .animate-in {
            animation: fadeIn 0.5s ease forwards;
        }
    </style>
</head>
<body>
    <div id="progress-bar"></div>
    
    <div id="presentation">
        <!-- Slide 1: Titlu -->
        <div class="slide title-slide active" data-slide="1">
            <h1>Algoritmi de Sortare AvansaÈ›i<br>È™i Analiza ComplexitÄƒÈ›ii</h1>
            <p class="subtitle">SÄƒptÄƒmÃ¢na 15</p>
            <p class="info">
                Algoritmi È™i Tehnici de Programare<br>
                Academia de Studii Economice din BucureÈ™ti
            </p>
        </div>

        <!-- Slide 2: Obiective -->
        <div class="slide" data-slide="2">
            <h2>ğŸ¯ Obiective de ÃnvÄƒÈ›are</h2>
            <ol>
                <li><strong>ReÈ›ineÈ›i</strong>: DefiniÈ›iile notaÈ›iilor asimptotice (O, Î©, Î˜) È™i complexitÄƒÈ›ile algoritmilor de sortare</li>
                <li><strong>ÃnÈ›elegeÈ›i</strong>: De ce Quick Sort are O(nÂ²) worst-case dar O(n log n) average</li>
                <li><strong>AplicaÈ›i</strong>: Implementarea Quick Sort, Merge Sort, Heap Sort, Counting Sort, Radix Sort</li>
                <li><strong>AnalizaÈ›i</strong>: Compararea empiricÄƒ pe diferite distribuÈ›ii de date</li>
                <li><strong>EvaluaÈ›i</strong>: Alegerea algoritmului optim pentru context specific</li>
                <li><strong>CreaÈ›i</strong>: Implementarea unui algoritm hibrid (Introsort)</li>
            </ol>
        </div>

        <!-- Slide 3: Context Istoric -->
        <div class="slide" data-slide="3">
            <h2>ğŸ“œ Context Istoric</h2>
            <div class="two-column">
                <div>
                    <div class="historical-figure">
                        <h3>C.A.R. Hoare (1934-)</h3>
                        <p>Inventatorul Quick Sort (1961)</p>
                        <ul>
                            <li>Premiul Turing 1980</li>
                            <li>Logica Hoare pentru verificare</li>
                            <li>Monitor-uri pentru concurenÈ›Äƒ</li>
                        </ul>
                    </div>
                    <div class="quote">
                        "There are two ways of constructing software design: one way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies."
                    </div>
                </div>
                <div>
                    <div class="historical-figure">
                        <h3>John von Neumann (1903-1957)</h3>
                        <p>Inventatorul Merge Sort (1945)</p>
                        <ul>
                            <li>Arhitectura von Neumann</li>
                            <li>Teoria jocurilor</li>
                            <li>Computere ENIAC, EDVAC</li>
                        </ul>
                    </div>
                    <div class="quote">
                        "If people do not believe that mathematics is simple, it is only because they do not realize how complicated life is."
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 4: NotaÈ›ii Asimptotice -->
        <div class="slide" data-slide="4">
            <h2>ğŸ“Š NotaÈ›ii Asimptotice</h2>
            <div class="two-column">
                <div>
                    <h3>Big-O (Upper Bound)</h3>
                    <div class="highlight-box">
                        <p><strong>f(n) = O(g(n))</strong></p>
                        <p>âˆƒ c > 0, nâ‚€ astfel Ã®ncÃ¢t:</p>
                        <p>f(n) â‰¤ c Â· g(n), âˆ€n â‰¥ nâ‚€</p>
                    </div>
                    <p>Descrie <strong>limita superioarÄƒ</strong> - "cel mult atÃ¢t"</p>
                </div>
                <div>
                    <h3>Big-Î© (Lower Bound)</h3>
                    <div class="highlight-box">
                        <p><strong>f(n) = Î©(g(n))</strong></p>
                        <p>âˆƒ c > 0, nâ‚€ astfel Ã®ncÃ¢t:</p>
                        <p>f(n) â‰¥ c Â· g(n), âˆ€n â‰¥ nâ‚€</p>
                    </div>
                    <p>Descrie <strong>limita inferioarÄƒ</strong> - "cel puÈ›in atÃ¢t"</p>
                </div>
            </div>
            <div class="info-box">
                <h3>Big-Î˜ (Tight Bound)</h3>
                <p><strong>f(n) = Î˜(g(n))</strong> dacÄƒ f(n) = O(g(n)) È™i f(n) = Î©(g(n))</p>
                <p>Descrie comportamentul <strong>exact</strong> - rata de creÈ™tere precisÄƒ.</p>
            </div>
        </div>

        <!-- Slide 5: Tabel Comparativ Algoritmi -->
        <div class="slide" data-slide="5">
            <h2>ğŸ“‹ ComparaÈ›ie Algoritmi de Sortare</h2>
            <table class="comparison-table">
                <tr>
                    <th>Algoritm</th>
                    <th>Best</th>
                    <th>Average</th>
                    <th>Worst</th>
                    <th>SpaÈ›iu</th>
                    <th>Stabil?</th>
                </tr>
                <tr>
                    <td>Quick Sort</td>
                    <td><span class="complexity excellent">O(n log n)</span></td>
                    <td><span class="complexity excellent">O(n log n)</span></td>
                    <td><span class="complexity poor">O(nÂ²)</span></td>
                    <td>O(log n)</td>
                    <td>âŒ</td>
                </tr>
                <tr>
                    <td>Merge Sort</td>
                    <td><span class="complexity excellent">O(n log n)</span></td>
                    <td><span class="complexity excellent">O(n log n)</span></td>
                    <td><span class="complexity excellent">O(n log n)</span></td>
                    <td>O(n)</td>
                    <td>âœ…</td>
                </tr>
                <tr>
                    <td>Heap Sort</td>
                    <td><span class="complexity excellent">O(n log n)</span></td>
                    <td><span class="complexity excellent">O(n log n)</span></td>
                    <td><span class="complexity excellent">O(n log n)</span></td>
                    <td>O(1)</td>
                    <td>âŒ</td>
                </tr>
                <tr>
                    <td>Counting Sort</td>
                    <td><span class="complexity excellent">O(n + k)</span></td>
                    <td><span class="complexity excellent">O(n + k)</span></td>
                    <td><span class="complexity excellent">O(n + k)</span></td>
                    <td>O(k)</td>
                    <td>âœ…</td>
                </tr>
                <tr>
                    <td>Radix Sort</td>
                    <td><span class="complexity excellent">O(dÂ·n)</span></td>
                    <td><span class="complexity excellent">O(dÂ·n)</span></td>
                    <td><span class="complexity excellent">O(dÂ·n)</span></td>
                    <td>O(n + k)</td>
                    <td>âœ…</td>
                </tr>
            </table>
            <p><em>k = interval valori, d = numÄƒr cifre</em></p>
        </div>

        <!-- Slide 6: Quick Sort - Concept -->
        <div class="slide" data-slide="6">
            <h2>âš¡ Quick Sort - Conceptul Divide et Impera</h2>
            <div class="ascii-diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  QUICK SORT - STRATEGIA DIVIDE ET IMPERA                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                    â”‚
â”‚   Array: [3, 8, 2, 5, 1, 4, 7, 6]    pivot = 5                    â”‚
â”‚                                                                    â”‚
â”‚   1. PARTIÈšIONARE:                                                 â”‚
â”‚      MutÄƒm elementele astfel Ã®ncÃ¢t:                                â”‚
â”‚      - Toate valorile < pivot sunt la stÃ¢nga                       â”‚
â”‚      - Toate valorile > pivot sunt la dreapta                      â”‚
â”‚                                                                    â”‚
â”‚   Rezultat: [3, 2, 1, 4] [5] [8, 7, 6]                            â”‚
â”‚              â””â”€â”€â”€â”¬â”€â”€â”€â”˜   â”‚   â””â”€â”€â”€â”¬â”€â”€â”€â”˜                             â”‚
â”‚              < pivot   pivot   > pivot                             â”‚
â”‚                                                                    â”‚
â”‚   2. RECURSIV: SortÄƒm cele douÄƒ subarray-uri                       â”‚
â”‚                                                                    â”‚
â”‚   3. COMBINÄ‚: Array-ul este deja sortat! (no merge needed)         â”‚
â”‚                                                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
            <div class="success-box">
                <p><strong>Avantaj principal:</strong> Sortare in-place, cache-friendly, foarte rapid Ã®n practicÄƒ!</p>
            </div>
        </div>

        <!-- Slide 7: Quick Sort - PartiÈ›ionare Lomuto -->
        <div class="slide" data-slide="7">
            <h2>Quick Sort - PartiÈ›ionare Lomuto</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>PartiÈ›ionare Lomuto</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/**
 * PartiÈ›ionare Lomuto - simplu de Ã®nÈ›eles
 * Pivot = ultimul element
 */
int partition_lomuto(int arr[], int low, int high) {
    int pivot = arr[high];  // Pivot = ultimul element
    int i = low - 1;        // Index pentru elementele mici
    
    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    
    // Punem pivot-ul la poziÈ›ia corectÄƒ
    swap(&arr[i + 1], &arr[high]);
    return i + 1;  // ReturnÄƒm poziÈ›ia pivotului
}</code></pre>
            </div>
            <div class="warning-box">
                <p><strong>âš ï¸ ProblemÄƒ:</strong> DacÄƒ array-ul este deja sortat, pivot-ul este mereu cel mai mare/mic element â†’ O(nÂ²)!</p>
            </div>
        </div>

        <!-- Slide 8: Quick Sort - Pivot Aleator -->
        <div class="slide" data-slide="8">
            <h2>Quick Sort - Pivot Aleator (Randomized)</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Pivot aleator pentru evitarea worst-case</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/**
 * PartiÈ›ionare cu pivot aleator
 * Complexitate medie garantatÄƒ: O(n log n)
 */
int partition_random(int arr[], int low, int high) {
    // Alegem un pivot aleator
    int random_idx = low + rand() % (high - low + 1);
    
    // Ãl mutÄƒm la final
    swap(&arr[random_idx], &arr[high]);
    
    // ContinuÄƒm cu partiÈ›ionarea standard
    return partition_lomuto(arr, low, high);
}

void quick_sort_randomized(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition_random(arr, low, high);
        quick_sort_randomized(arr, low, pi - 1);
        quick_sort_randomized(arr, pi + 1, high);
    }
}</code></pre>
            </div>
            <div class="success-box">
                <p><strong>âœ“ SoluÈ›ie:</strong> Pivot aleator previne worst-case pentru orice input determinist.</p>
            </div>
        </div>

        <!-- Slide 9: Quick Sort - Median of Three -->
        <div class="slide" data-slide="9">
            <h2>Quick Sort - Median of Three</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Median din 3 elemente ca pivot</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/**
 * Alege mediana dintre arr[low], arr[mid], arr[high]
 * ÃmbunÄƒtÄƒÈ›eÈ™te semnificativ performanÈ›a pe date parÈ›ial sortate
 */
int median_of_three(int arr[], int low, int high) {
    int mid = low + (high - low) / 2;
    
    // SortÄƒm cele 3 poziÈ›ii
    if (arr[low] > arr[mid])  swap(&arr[low], &arr[mid]);
    if (arr[low] > arr[high]) swap(&arr[low], &arr[high]);
    if (arr[mid] > arr[high]) swap(&arr[mid], &arr[high]);
    
    // Mediana este acum arr[mid], o mutÄƒm lÃ¢ngÄƒ high
    swap(&arr[mid], &arr[high - 1]);
    return arr[high - 1];
}</code></pre>
            </div>
            <div class="highlight-box">
                <p><strong>Utilizat Ã®n:</strong> std::sort() din C++ (parte din Introsort)</p>
            </div>
        </div>

        <!-- Slide 10: Merge Sort -->
        <div class="slide" data-slide="10">
            <h2>ğŸ”€ Merge Sort - Algoritmul Lui von Neumann</h2>
            <div class="ascii-diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MERGE SORT - DIVIDE & CONQUER                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚   [38, 27, 43, 3, 9, 82, 10]                                       â”‚
â”‚            â”‚                                                        â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”                                               â”‚
â”‚     â–¼              â–¼                                               â”‚
â”‚  [38,27,43,3]   [9,82,10]       DIVIDE                             â”‚
â”‚     â”‚              â”‚                                               â”‚
â”‚  â”Œâ”€â”€â”´â”€â”€â”       â”Œâ”€â”€â”€â”´â”€â”€â”€â”                                          â”‚
â”‚  â–¼     â–¼       â–¼       â–¼                                          â”‚
â”‚ [38,27][43,3] [9,82]  [10]                                        â”‚
â”‚  â”‚   â”‚  â”‚  â”‚   â”‚  â”‚    â”‚                                          â”‚
â”‚  â–¼   â–¼  â–¼  â–¼   â–¼  â–¼    â–¼                                          â”‚
â”‚ [38][27][43][3][9][82][10]     BASE CASE                          â”‚
â”‚  â”‚   â”‚  â”‚   â”‚  â”‚   â”‚   â”‚                                          â”‚
â”‚  â””â”€â”¬â”€â”˜  â””â”€â”¬â”€â”˜  â””â”€â”¬â”€â”˜   â”‚                                          â”‚
â”‚    â–¼      â–¼      â–¼     â–¼                                          â”‚
â”‚ [27,38] [3,43] [9,82] [10]     MERGE                              â”‚
â”‚    â”‚      â”‚      â”‚     â”‚                                          â”‚
â”‚    â””â”€â”€â”¬â”€â”€â”€â”˜      â””â”€â”€â”¬â”€â”€â”˜                                          â”‚
â”‚       â–¼             â–¼                                             â”‚
â”‚   [3,27,38,43]  [9,10,82]                                         â”‚
â”‚        â”‚            â”‚                                             â”‚
â”‚        â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                                             â”‚
â”‚              â–¼                                                     â”‚
â”‚     [3, 9, 10, 27, 38, 43, 82]  SORTED!                           â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
        </div>

        <!-- Slide 11: Merge Sort - Cod -->
        <div class="slide" data-slide="11">
            <h2>Merge Sort - Implementare</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>FuncÈ›ia de merge</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    
    int *L = malloc(n1 * sizeof(int));
    int *R = malloc(n2 * sizeof(int));
    
    // Copiem datele Ã®n array-uri temporare
    for (int i = 0; i < n1; i++) L[i] = arr[left + i];
    for (int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];
    
    // InterclasÄƒm
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) arr[k++] = L[i++];
        else              arr[k++] = R[j++];
    }
    
    // Copiem restul
    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];
    
    free(L); free(R);
}</code></pre>
            </div>
        </div>

        <!-- Slide 12: Heap Sort -->
        <div class="slide" data-slide="12">
            <h2>ğŸ”ï¸ Heap Sort - In-Place cu O(n log n) garantat</h2>
            <div class="two-column">
                <div>
                    <h3>Structura Max-Heap</h3>
                    <div class="ascii-diagram">
         90
        /  \
      85    80
     /  \   / \
   70   60 50  30
   /
  40

Array: [90,85,80,70,60,50,30,40]
Index:   0  1  2  3  4  5  6  7

Parent(i) = (i-1)/2
Left(i)   = 2*i + 1
Right(i)  = 2*i + 2
                    </div>
                </div>
                <div>
                    <h3>Algoritmul</h3>
                    <ol class="step-list">
                        <li>Build Max-Heap din array <strong>O(n)</strong></li>
                        <li>Extract-Max repetat: Swap root cu ultimul, heapify <strong>O(n log n)</strong></li>
                        <li>Array-ul devine sortat crescÄƒtor</li>
                    </ol>
                    <div class="success-box">
                        <p><strong>Avantaje:</strong></p>
                        <ul>
                            <li>In-place (O(1) spaÈ›iu)</li>
                            <li>O(n log n) garantat</li>
                            <li>FÄƒrÄƒ worst-case patologic</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 13: Heap Sort - Cod -->
        <div class="slide" data-slide="13">
            <h2>Heap Sort - Implementare</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Heapify È™i Heap Sort</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void heapify(int arr[], int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    
    if (left < n && arr[left] > arr[largest])
        largest = left;
    if (right < n && arr[right] > arr[largest])
        largest = right;
    
    if (largest != i) {
        swap(&arr[i], &arr[largest]);
        heapify(arr, n, largest);  // Recursiv Ã®n jos
    }
}

void heap_sort(int arr[], int n) {
    // Build heap - O(n)
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);
    
    // Extract max repetat
    for (int i = n - 1; i > 0; i--) {
        swap(&arr[0], &arr[i]);    // Max la final
        heapify(arr, i, 0);        // ReparÄƒ heap-ul
    }
}</code></pre>
            </div>
        </div>

        <!-- Slide 14: Counting Sort -->
        <div class="slide" data-slide="14">
            <h2>ğŸ”¢ Counting Sort - O(n + k) Non-Comparativ</h2>
            <div class="ascii-diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  COUNTING SORT - PENTRU INTERVAL MIC DE VALORI                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚   Input:  [4, 2, 2, 8, 3, 3, 1]     Range: 1-8                     â”‚
â”‚                                                                     â”‚
â”‚   Pas 1: NUMÄ‚RARE                                                   â”‚
â”‚   Count: [0, 1, 2, 2, 1, 0, 0, 0, 1]                               â”‚
â”‚   Index:  0  1  2  3  4  5  6  7  8                                â”‚
â”‚                                                                     â”‚
â”‚   Pas 2: PREFIX SUM (pentru stabilitate)                           â”‚
â”‚   Cumul: [0, 1, 3, 5, 6, 6, 6, 6, 7]                               â”‚
â”‚                                                                     â”‚
â”‚   Pas 3: PLASARE (de la sfÃ¢rÈ™it pentru stabilitate)                â”‚
â”‚   Output: [1, 2, 2, 3, 3, 4, 8]                                    â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
            <div class="info-box">
                <p><strong>CÃ¢nd folosim?</strong> CÃ¢nd k (intervalul) este comparabil cu n. Ex: sortare note 1-10, caractere ASCII, vÃ¢rste.</p>
            </div>
        </div>

        <!-- Slide 15: Counting Sort - Cod -->
        <div class="slide" data-slide="15">
            <h2>Counting Sort - Implementare StabilÄƒ</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Counting Sort O(n + k)</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void counting_sort(int arr[], int n, int max_val) {
    int *count = calloc(max_val + 1, sizeof(int));
    int *output = malloc(n * sizeof(int));
    
    // Pas 1: NumÄƒrare
    for (int i = 0; i < n; i++)
        count[arr[i]]++;
    
    // Pas 2: Prefix sum (poziÈ›ii cumulative)
    for (int i = 1; i <= max_val; i++)
        count[i] += count[i - 1];
    
    // Pas 3: Plasare (de la sfÃ¢rÈ™it pentru stabilitate!)
    for (int i = n - 1; i >= 0; i--) {
        output[count[arr[i]] - 1] = arr[i];
        count[arr[i]]--;
    }
    
    // Copiem rezultatul
    for (int i = 0; i < n; i++)
        arr[i] = output[i];
    
    free(count);
    free(output);
}</code></pre>
            </div>
        </div>

        <!-- Slide 16: Radix Sort -->
        <div class="slide" data-slide="16">
            <h2>ğŸ¯ Radix Sort - Sortare pe Cifre</h2>
            <div class="ascii-diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  RADIX SORT LSD (Least Significant Digit First)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚   Input:  [170, 45, 75, 90, 802, 24, 2, 66]                        â”‚
â”‚                                                                     â”‚
â”‚   CIFRA UNITÄ‚ÈšILOR (1s):                                           â”‚
â”‚   [170, 90, 802, 2, 24, 45, 75, 66]                                â”‚
â”‚         0   0   2  2   4   5   5   6                               â”‚
â”‚                                                                     â”‚
â”‚   CIFRA ZECILOR (10s):                                             â”‚
â”‚   [802, 2, 24, 45, 66, 170, 75, 90]                                â”‚
â”‚     0   0   2   4   6    7   7   9                                 â”‚
â”‚                                                                     â”‚
â”‚   CIFRA SUTELOR (100s):                                            â”‚
â”‚   [2, 24, 45, 66, 75, 90, 170, 802]                                â”‚
â”‚    0   0   0   0   0   0    1    8                                 â”‚
â”‚                                                                     â”‚
â”‚   Output: SORTAT!                                                   â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
            <div class="highlight-box">
                <p><strong>Complexitate:</strong> O(d Ã— (n + k)) unde d = numÄƒrul de cifre, k = baza (10 pentru decimal)</p>
            </div>
        </div>

        <!-- Slide 17: Introsort -->
        <div class="slide" data-slide="17">
            <h2>ğŸš€ Introsort - Algoritm Hibrid Industrial</h2>
            <div class="two-column">
                <div>
                    <h3>Strategia</h3>
                    <p>CombinaÈ›ie inteligentÄƒ de 3 algoritmi:</p>
                    <ol class="step-list">
                        <li><strong>Quick Sort</strong> pentru majoritatea sortÄƒrii (rapid Ã®n practicÄƒ)</li>
                        <li><strong>Heap Sort</strong> cÃ¢nd recursiunea devine prea adÃ¢ncÄƒ (evitÄƒ O(nÂ²))</li>
                        <li><strong>Insertion Sort</strong> pentru subarray-uri mici (< 16 elemente)</li>
                    </ol>
                </div>
                <div>
                    <h3>Utilizare</h3>
                    <div class="success-box">
                        <p><strong>Folosit Ã®n:</strong></p>
                        <ul>
                            <li>C++ std::sort()</li>
                            <li>.NET Array.Sort()</li>
                            <li>GNU libstdc++</li>
                        </ul>
                    </div>
                    <div class="info-box">
                        <p><strong>Prag de adÃ¢ncime:</strong></p>
                        <p>maxDepth = 2 Ã— logâ‚‚(n)</p>
                        <p>DacÄƒ depÄƒÈ™it â†’ switch la Heap Sort</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 18: Introsort - Cod -->
        <div class="slide" data-slide="18">
            <h2>Introsort - Implementare</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Introsort cu 3 algoritmi</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">#define INSERTION_THRESHOLD 16

void introsort_helper(int arr[], int low, int high, int depth_limit) {
    int size = high - low + 1;
    
    // Pentru subarray-uri mici: Insertion Sort
    if (size < INSERTION_THRESHOLD) {
        insertion_sort(arr + low, size);
        return;
    }
    
    // DacÄƒ recursiunea e prea adÃ¢ncÄƒ: Heap Sort
    if (depth_limit == 0) {
        heap_sort(arr + low, size);
        return;
    }
    
    // Altfel: Quick Sort cu median-of-three
    int pivot = partition_mot(arr, low, high);
    introsort_helper(arr, low, pivot - 1, depth_limit - 1);
    introsort_helper(arr, pivot + 1, high, depth_limit - 1);
}

void introsort(int arr[], int n) {
    int depth_limit = 2 * (int)log2(n);
    introsort_helper(arr, 0, n - 1, depth_limit);
}</code></pre>
            </div>
        </div>

        <!-- Slide 19: CÃ¢nd Folosim Ce? -->
        <div class="slide" data-slide="19">
            <h2>ğŸ¯ Ghid de SelecÈ›ie Algoritm</h2>
            <table class="comparison-table">
                <tr>
                    <th>SituaÈ›ie</th>
                    <th>Algoritm Recomandat</th>
                    <th>De Ce?</th>
                </tr>
                <tr>
                    <td>Array mic (n < 50)</td>
                    <td><span class="complexity good">Insertion Sort</span></td>
                    <td>Overhead mic, rapid Ã®n practicÄƒ</td>
                </tr>
                <tr>
                    <td>Date aproape sortate</td>
                    <td><span class="complexity good">Insertion Sort</span></td>
                    <td>O(n) pentru date aproape sortate</td>
                </tr>
                <tr>
                    <td>Interval mic de valori</td>
                    <td><span class="complexity excellent">Counting Sort</span></td>
                    <td>O(n+k) liniar</td>
                </tr>
                <tr>
                    <td>Sortare stringuri</td>
                    <td><span class="complexity excellent">Radix Sort MSD</span></td>
                    <td>Eficient pentru chei de lungime fixÄƒ</td>
                </tr>
                <tr>
                    <td>Memorie limitatÄƒ</td>
                    <td><span class="complexity good">Heap Sort</span></td>
                    <td>O(1) spaÈ›iu suplimentar</td>
                </tr>
                <tr>
                    <td>Stabilitate necesarÄƒ</td>
                    <td><span class="complexity good">Merge Sort</span></td>
                    <td>Stabil, predictibil</td>
                </tr>
                <tr>
                    <td>Caz general</td>
                    <td><span class="complexity excellent">Introsort / Quick Sort</span></td>
                    <td>Cel mai rapid Ã®n practicÄƒ</td>
                </tr>
            </table>
        </div>

        <!-- Slide 20: Benchmark Real -->
        <div class="slide" data-slide="20">
            <h2>ğŸ“Š Rezultate Benchmark (10.000 elemente)</h2>
            <div class="ascii-diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TIMP DE EXECUÈšIE (milisecunde)                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Algoritm          â”‚  Random    â”‚  Sorted    â”‚  Reversed  â”‚ Nearly Sorted  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Quick Sort        â”‚   1.2 ms   â”‚  45.2 ms   â”‚  46.1 ms   â”‚    1.8 ms      â”‚
â”‚ Quick (random)    â”‚   1.3 ms   â”‚   1.2 ms   â”‚   1.3 ms   â”‚    1.4 ms      â”‚
â”‚ Merge Sort        â”‚   2.1 ms   â”‚   1.8 ms   â”‚   1.9 ms   â”‚    2.0 ms      â”‚
â”‚ Heap Sort         â”‚   2.4 ms   â”‚   2.3 ms   â”‚   2.4 ms   â”‚    2.3 ms      â”‚
â”‚ Introsort         â”‚   1.2 ms   â”‚   1.1 ms   â”‚   1.2 ms   â”‚    1.2 ms      â”‚
â”‚ Counting Sort*    â”‚   0.3 ms   â”‚   0.3 ms   â”‚   0.3 ms   â”‚    0.3 ms      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ * Counting Sort testat cu valori Ã®n intervalul [0, 1000]                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
            <div class="warning-box">
                <p><strong>ObservaÈ›ie:</strong> Quick Sort clasic are worst-case pe date sortate! Pivotul aleator rezolvÄƒ problema.</p>
            </div>
        </div>

        <!-- Slide 21: AplicaÈ›ii Industriale -->
        <div class="slide" data-slide="21">
            <h2>ğŸ­ AplicaÈ›ii Ã®n Industrie</h2>
            <div class="two-column">
                <div>
                    <h3>Baze de Date</h3>
                    <ul>
                        <li><strong>PostgreSQL:</strong> Uses hybrid of Quick Sort + external merge</li>
                        <li><strong>MySQL:</strong> File sorts use merge sort for stability</li>
                        <li><strong>Redis:</strong> SORT uses Quick Sort</li>
                    </ul>
                    
                    <h3>Sisteme de Operare</h3>
                    <ul>
                        <li><strong>Linux qsort():</strong> Merge sort (garanteazÄƒ O(n log n))</li>
                        <li><strong>glibc:</strong> Introsort pentru arrays</li>
                        <li><strong>BSD:</strong> Hybrid smoothsort</li>
                    </ul>
                </div>
                <div>
                    <h3>Search Engines</h3>
                    <ul>
                        <li><strong>Inverted index:</strong> Merge sort pentru stabilitate la same-score docs</li>
                        <li><strong>Result ranking:</strong> Partial sorting (Top-K) cu heap</li>
                    </ul>
                    
                    <h3>Data Processing</h3>
                    <ul>
                        <li><strong>Hadoop/Spark:</strong> External merge sort pentru big data</li>
                        <li><strong>Pandas:</strong> Introsort cu Timsort fallback</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 22: ExerciÈ›ii -->
        <div class="slide" data-slide="22">
            <h2>ğŸ’» ExerciÈ›ii de Laborator</h2>
            <div class="two-column">
                <div>
                    <div class="highlight-box">
                        <h3>ExerciÈ›iul 1: Benchmark</h3>
                        <p>ImplementaÈ›i È™i comparaÈ›i:</p>
                        <ul>
                            <li>Quick Sort (3 variante)</li>
                            <li>Merge Sort</li>
                            <li>Heap Sort</li>
                        </ul>
                        <p>MÄƒsuraÈ›i timp È™i comparaÈ›ii pe date random/sorted/reversed.</p>
                    </div>
                </div>
                <div>
                    <div class="highlight-box">
                        <h3>ExerciÈ›iul 2: External Sort</h3>
                        <p>SortaÈ›i un fiÈ™ier mare care nu Ã®ncape Ã®n memorie:</p>
                        <ul>
                            <li>CreaÈ›i runs sortate</li>
                            <li>K-way merge cu min-heap</li>
                            <li>ValidaÈ›i rezultatul</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 23: Teme -->
        <div class="slide" data-slide="23">
            <h2>ğŸ“ Teme pentru AcasÄƒ</h2>
            <div class="two-column">
                <div>
                    <div class="info-box">
                        <h3>Tema 1: Sistem Adaptiv (50p)</h3>
                        <p>CreaÈ›i un sistem care:</p>
                        <ul>
                            <li>AnalizeazÄƒ caracteristicile datelor</li>
                            <li>SelecteazÄƒ automat algoritmul optim</li>
                            <li>ComparÄƒ cu alegerea naivÄƒ</li>
                        </ul>
                    </div>
                </div>
                <div>
                    <div class="info-box">
                        <h3>Tema 2: Shell Sort (50p)</h3>
                        <p>ImplementaÈ›i Shell Sort cu:</p>
                        <ul>
                            <li>4 secvenÈ›e de gap diferite</li>
                            <li>Benchmark comparativ</li>
                            <li>Vizualizare pas cu pas</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 24: Rezumat -->
        <div class="slide" data-slide="24">
            <h2>ğŸ“‹ Rezumat</h2>
            <div class="two-column">
                <div>
                    <h3>Ce am Ã®nvÄƒÈ›at</h3>
                    <ul>
                        <li>NotaÈ›iile O, Î©, Î˜ pentru analizÄƒ</li>
                        <li>Quick Sort È™i optimizÄƒrile (pivot aleator, median-of-three)</li>
                        <li>Merge Sort - stabil, predictibil</li>
                        <li>Heap Sort - in-place, garantat O(n log n)</li>
                        <li>Algoritmi non-comparativi (Counting, Radix)</li>
                        <li>Introsort - soluÈ›ia industrialÄƒ hibridÄƒ</li>
                    </ul>
                </div>
                <div>
                    <h3>Puncte Cheie</h3>
                    <div class="success-box">
                        <ul>
                            <li>Quick Sort e cel mai rapid Ã®n practicÄƒ (cu pivot aleator)</li>
                            <li>Merge Sort pentru stabilitate È™i predictibilitate</li>
                            <li>Counting/Radix Sort pentru cazuri speciale (liniari!)</li>
                            <li>Alegerea depinde de context!</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 25: Preview SÄƒptÄƒmÃ¢na UrmÄƒtoare -->
        <div class="slide" data-slide="25">
            <h2>ğŸ”® Preview: SÄƒptÄƒmÃ¢na 16</h2>
            <h3>Paradigme Algoritmice - Greedy È™i Backtracking</h3>
            <div class="two-column">
                <div>
                    <div class="highlight-box">
                        <h3>Greedy</h3>
                        <ul>
                            <li>Activity Selection</li>
                            <li>Fractional Knapsack</li>
                            <li>Huffman Coding</li>
                        </ul>
                        <p><em>Alegerea localÄƒ optimÄƒ â†’ SoluÈ›ie globalÄƒ?</em></p>
                    </div>
                </div>
                <div>
                    <div class="highlight-box">
                        <h3>Backtracking</h3>
                        <ul>
                            <li>N-Queens Problem</li>
                            <li>Sudoku Solver</li>
                            <li>Generare permutÄƒri/combinÄƒri</li>
                        </ul>
                        <p><em>Explorare sistematicÄƒ cu pruning</em></p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 26: Final -->
        <div class="slide title-slide" data-slide="26">
            <h1>ÃntrebÄƒri?</h1>
            <p class="subtitle">Algoritmi de Sortare AvansaÈ›i</p>
            <p class="info">
                ğŸ“§ Contact: profesor@ase.ro<br>
                ğŸ“š Materiale: github.com/course-atp<br><br>
                Academia de Studii Economice din BucureÈ™ti
            </p>
        </div>
    </div>

    <div id="slide-counter"></div>
    <div class="keyboard-hints">
        <kbd>â†</kbd> <kbd>â†’</kbd> navigare | <kbd>Home</kbd> <kbd>End</kbd> prima/ultima
    </div>
    
    <div id="controls">
        <button class="control-btn" onclick="prevSlide()">â—€ Anterior</button>
        <button class="control-btn" onclick="nextSlide()">UrmÄƒtor â–¶</button>
    </div>

    <script>
        let currentSlide = 1;
        const totalSlides = document.querySelectorAll('.slide').length;

        function showSlide(n) {
            if (n < 1) n = 1;
            if (n > totalSlides) n = totalSlides;
            
            document.querySelectorAll('.slide').forEach(slide => {
                slide.classList.remove('active');
            });
            
            document.querySelector(`[data-slide="${n}"]`).classList.add('active');
            currentSlide = n;
            
            document.getElementById('progress-bar').style.width = 
                ((currentSlide / totalSlides) * 100) + '%';
            document.getElementById('slide-counter').textContent = 
                `${currentSlide} / ${totalSlides}`;
        }

        function nextSlide() {
            showSlide(currentSlide + 1);
        }

        function prevSlide() {
            showSlide(currentSlide - 1);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === ' ') {
                nextSlide();
            } else if (e.key === 'ArrowLeft') {
                prevSlide();
            } else if (e.key === 'Home') {
                showSlide(1);
            } else if (e.key === 'End') {
                showSlide(totalSlides);
            }
        });

        // Initialize
        showSlide(1);
        hljs.highlightAll();
    </script>
</body>
</html>
