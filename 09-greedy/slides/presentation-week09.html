<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SÄƒptÄƒmÃ¢na 09: Arbori AVL | ATP - ASE BucureÈ™ti</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-yellow: #d29922;
            --accent-red: #f85149;
            --accent-purple: #a371f7;
            --border-color: #30363d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow: hidden;
        }

        /* Progress Bar */
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            transition: width 0.3s ease;
            z-index: 1000;
        }

        /* Slide Container */
        .slides-container {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 60px 80px;
            display: none;
            opacity: 0;
            transition: opacity 0.4s ease;
            overflow-y: auto;
        }

        .slide.active {
            display: block;
            opacity: 1;
        }

        /* Typography */
        h1 {
            font-size: 2.8em;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--accent-blue);
        }

        h2 {
            font-size: 2.2em;
            font-weight: 600;
            margin-bottom: 25px;
            color: var(--text-primary);
            border-bottom: 2px solid var(--accent-blue);
            padding-bottom: 10px;
        }

        h3 {
            font-size: 1.6em;
            font-weight: 500;
            margin: 20px 0 15px 0;
            color: var(--accent-green);
        }

        p {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: var(--text-secondary);
        }

        ul, ol {
            margin: 15px 0 15px 30px;
            font-size: 1.15em;
        }

        li {
            margin-bottom: 12px;
            color: var(--text-secondary);
        }

        li strong {
            color: var(--text-primary);
        }

        /* Title Slide */
        .title-slide {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
        }

        .title-slide h1 {
            font-size: 3.5em;
            margin-bottom: 10px;
        }

        .title-slide .subtitle {
            font-size: 1.8em;
            color: var(--accent-purple);
            margin-bottom: 30px;
        }

        .title-slide .course-info {
            font-size: 1.2em;
            color: var(--text-secondary);
        }

        .title-slide .week-badge {
            background: var(--accent-blue);
            color: var(--bg-primary);
            padding: 8px 25px;
            border-radius: 25px;
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 20px;
        }

        /* Code Blocks */
        .code-block {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin: 20px 0;
            overflow: hidden;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .lang-badge {
            background: var(--accent-blue);
            color: var(--bg-primary);
            padding: 3px 10px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .code-block pre {
            margin: 0;
            padding: 15px;
            overflow-x: auto;
        }

        .code-block code {
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 0.95em;
            line-height: 1.5;
        }

        /* Inline code */
        code:not([class*="language-"]) {
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 0.9em;
            color: var(--accent-yellow);
        }

        /* Info Boxes */
        .info-box {
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid;
        }

        .info-box.tip {
            background: rgba(63, 185, 80, 0.1);
            border-color: var(--accent-green);
        }

        .info-box.warning {
            background: rgba(210, 153, 34, 0.1);
            border-color: var(--accent-yellow);
        }

        .info-box.danger {
            background: rgba(248, 81, 73, 0.1);
            border-color: var(--accent-red);
        }

        .info-box.note {
            background: rgba(88, 166, 255, 0.1);
            border-color: var(--accent-blue);
        }

        .info-box-title {
            font-weight: 600;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .info-box.tip .info-box-title { color: var(--accent-green); }
        .info-box.warning .info-box-title { color: var(--accent-yellow); }
        .info-box.danger .info-box-title { color: var(--accent-red); }
        .info-box.note .info-box-title { color: var(--accent-blue); }

        /* ASCII Art / Diagrams */
        .diagram {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            font-family: 'SF Mono', 'Consolas', monospace;
            white-space: pre;
            line-height: 1.4;
            overflow-x: auto;
            color: var(--accent-green);
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 1em;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border: 1px solid var(--border-color);
        }

        th {
            background: var(--bg-tertiary);
            color: var(--accent-blue);
            font-weight: 600;
        }

        tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Two Column Layout */
        .two-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 20px 0;
        }

        .column {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        /* Quote */
        blockquote {
            border-left: 4px solid var(--accent-purple);
            padding: 15px 20px;
            margin: 20px 0;
            background: var(--bg-secondary);
            border-radius: 0 8px 8px 0;
            font-style: italic;
            color: var(--text-secondary);
        }

        blockquote cite {
            display: block;
            margin-top: 10px;
            color: var(--accent-purple);
            font-style: normal;
        }

        /* Navigation */
        .nav-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .nav-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.2s ease;
        }

        .nav-btn:hover {
            background: var(--accent-blue);
            color: var(--bg-primary);
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Slide Counter */
        .slide-counter {
            position: fixed;
            bottom: 25px;
            left: 30px;
            color: var(--text-secondary);
            font-size: 0.9em;
            z-index: 100;
        }

        /* Keyboard Hints */
        .kbd-hint {
            position: fixed;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--text-secondary);
            font-size: 0.85em;
            opacity: 0.7;
        }

        kbd {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 2px 8px;
            margin: 0 3px;
            font-family: inherit;
        }

        /* Highlight effect for steps */
        .highlight {
            background: linear-gradient(120deg, rgba(88, 166, 255, 0.2) 0%, rgba(163, 113, 247, 0.2) 100%);
            padding: 2px 5px;
            border-radius: 4px;
        }

        /* Badge */
        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 500;
        }

        .badge.green { background: var(--accent-green); color: var(--bg-primary); }
        .badge.yellow { background: var(--accent-yellow); color: var(--bg-primary); }
        .badge.red { background: var(--accent-red); color: var(--bg-primary); }
        .badge.blue { background: var(--accent-blue); color: var(--bg-primary); }
        .badge.purple { background: var(--accent-purple); color: var(--bg-primary); }

        /* Grid for cards */
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .card h4 {
            color: var(--accent-blue);
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .card p {
            font-size: 1em;
            margin: 0;
        }

        /* Rotation animation visual */
        .rotation-demo {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 30px 0;
        }

        .rotation-demo .tree-state {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            text-align: center;
        }

        .rotation-demo .arrow {
            font-size: 2em;
            color: var(--accent-yellow);
        }

        /* Objectives list */
        .objectives-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .objectives-list li {
            display: flex;
            align-items: flex-start;
            gap: 15px;
            margin-bottom: 15px;
            padding: 15px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border-left: 3px solid var(--accent-blue);
        }

        .objectives-list .obj-icon {
            font-size: 1.5em;
        }

        /* Timeline */
        .timeline {
            position: relative;
            padding-left: 30px;
        }

        .timeline::before {
            content: '';
            position: absolute;
            left: 8px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--border-color);
        }

        .timeline-item {
            position: relative;
            margin-bottom: 25px;
            padding-left: 25px;
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: -25px;
            top: 5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent-blue);
        }

        .timeline-item .year {
            color: var(--accent-purple);
            font-weight: 600;
        }

        /* Summary boxes grid */
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .summary-box {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .summary-box .icon {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .summary-box h4 {
            color: var(--accent-blue);
            margin-bottom: 8px;
        }

        .summary-box p {
            font-size: 0.95em;
            margin: 0;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .slide {
                padding: 40px 50px;
            }
            h1 { font-size: 2.2em; }
            h2 { font-size: 1.8em; }
            .two-columns { grid-template-columns: 1fr; }
            .summary-grid { grid-template-columns: repeat(2, 1fr); }
        }
    </style>
</head>
<body>
    <div class="progress-bar" id="progressBar"></div>
    
    <div class="slides-container" id="slidesContainer">
        
        <!-- Slide 1: Title -->
        <div class="slide title-slide active">
            <div class="week-badge">SÄ‚PTÄ‚MÃ‚NA 09</div>
            <h1>Arbori AVL</h1>
            <p class="subtitle">Adelson-Velsky È™i Landis Trees</p>
            <p class="course-info">
                Algoritmi È™i Tehnici de Programare<br>
                Academia de Studii Economice BucureÈ™ti - CSIE<br>
                <span style="color: var(--accent-yellow);">Anul Universitar 2024-2025</span>
            </p>
        </div>

        <!-- Slide 2: Learning Objectives -->
        <div class="slide">
            <h2>ğŸ¯ Obiective de ÃnvÄƒÈ›are</h2>
            <ul class="objectives-list">
                <li>
                    <span class="obj-icon">ğŸ”</span>
                    <div>
                        <strong>RecunoaÈ™te</strong> caracteristicile definitorii ale unui arbore AVL È™i diferenÈ›ele faÈ›Äƒ de un BST standard
                    </div>
                </li>
                <li>
                    <span class="obj-icon">ğŸ§ </span>
                    <div>
                        <strong>ÃnÈ›elege</strong> conceptul de balance factor È™i rolul sÄƒu Ã®n menÈ›inerea echilibrului
                    </div>
                </li>
                <li>
                    <span class="obj-icon">âš™ï¸</span>
                    <div>
                        <strong>AplicÄƒ</strong> cele patru tipuri de rotaÈ›ii (LL, RR, LR, RL) pentru reechilibrare
                    </div>
                </li>
                <li>
                    <span class="obj-icon">ğŸ“Š</span>
                    <div>
                        <strong>AnalizeazÄƒ</strong> complexitatea temporalÄƒ AVL vs BST neechilibrat
                    </div>
                </li>
                <li>
                    <span class="obj-icon">âš–ï¸</span>
                    <div>
                        <strong>EvalueazÄƒ</strong> cÃ¢nd utilizarea AVL este preferabilÄƒ faÈ›Äƒ de alte structuri
                    </div>
                </li>
                <li>
                    <span class="obj-icon">ğŸ› ï¸</span>
                    <div>
                        <strong>CreeazÄƒ</strong> implementÄƒri complete cu inserare È™i È™tergere auto-echilibratÄƒ
                    </div>
                </li>
            </ul>
        </div>

        <!-- Slide 3: Historical Context -->
        <div class="slide">
            <h2>ğŸ“œ Context Istoric</h2>
            <div class="timeline">
                <div class="timeline-item">
                    <span class="year">1960</span>
                    <p>Provocarea degenerÄƒrii BST-urilor devine evidentÄƒ Ã®n aplicaÈ›ii practice</p>
                </div>
                <div class="timeline-item">
                    <span class="year">1962</span>
                    <p><strong>Adelson-Velsky È™i Landis</strong> publicÄƒ algoritmul AVL Ã®n <em>Doklady Akademii Nauk SSSR</em></p>
                </div>
                <div class="timeline-item">
                    <span class="year">1970</span>
                    <p>Rudolf Bayer inventeazÄƒ <strong>B-trees</strong> pentru sisteme de fiÈ™iere</p>
                </div>
                <div class="timeline-item">
                    <span class="year">1972</span>
                    <p>ApariÈ›ia <strong>Red-Black trees</strong> - o alternativÄƒ cu echilibru mai relaxat</p>
                </div>
                <div class="timeline-item">
                    <span class="year">1985</span>
                    <p><strong>Splay trees</strong> - arbori auto-ajustabili pentru acces non-uniform</p>
                </div>
            </div>
            <div class="info-box note">
                <div class="info-box-title">ğŸ’¡ NotÄƒ</div>
                Arborii AVL sunt <strong>prima</strong> structurÄƒ de date de tip arbore binar de cÄƒutare auto-echilibrat din istorie.
            </div>
        </div>

        <!-- Slide 4: Key Figure -->
        <div class="slide">
            <h2>ğŸ‘¤ Personalitate Cheie</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Georgy Adelson-Velsky</h3>
                    <p style="color: var(--accent-purple);">1922 - 2014</p>
                    <p>Matematician È™i informatician sovietic, considerat unul dintre pionierii informaticii din URSS.</p>
                    <h4 style="color: var(--accent-green); margin-top: 20px;">ContribuÈ›ii majore:</h4>
                    <ul>
                        <li>Co-creator al arborilor AVL (1962)</li>
                        <li>Program È™ah <strong>Kaissa</strong> - primul campion mondial computerizat (1974)</li>
                        <li>ContribuÈ›ii la teoria jocurilor È™i AI</li>
                    </ul>
                </div>
                <div class="column">
                    <blockquote>
                        "Echilibrul nu este un scop Ã®n sine, ci un mijloc de a garanta eficienÈ›a Ã®n orice circumstanÈ›Äƒ."
                        <cite>â€” Georgy Adelson-Velsky</cite>
                    </blockquote>
                    <div class="info-box tip" style="margin-top: 20px;">
                        <div class="info-box-title">ğŸ† Realizare</div>
                        Kaissa a Ã®nvins toate celelalte programe de È™ah la primul Campionat Mondial de È˜ah pentru Computere din 1974.
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 5: Problem Statement -->
        <div class="slide">
            <h2>â“ Problema: Degenerarea BST</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>BST Echilibrat</h3>
                    <div class="diagram">      50
     /  \
   30    70
  /  \  /  \
 20  40 60  80</div>
                    <p><span class="badge green">O(log n)</span> pentru cÄƒutare</p>
                    <p>ÃnÄƒlÈ›ime: 3 pentru 7 noduri</p>
                </div>
                <div class="column">
                    <h3>BST Degenerat</h3>
                    <div class="diagram">10
  \
   20
     \
      30
        \
         40
           \
            50</div>
                    <p><span class="badge red">O(n)</span> pentru cÄƒutare</p>
                    <p>ÃnÄƒlÈ›ime: 5 pentru 5 noduri</p>
                </div>
            </div>
            <div class="info-box danger">
                <div class="info-box-title">âš ï¸ Problema</div>
                Inserarea elementelor Ã®n ordine crescÄƒtoare transformÄƒ BST-ul Ã®ntr-o listÄƒ liniarÄƒ!
            </div>
        </div>

        <!-- Slide 6: AVL Definition -->
        <div class="slide">
            <h2>ğŸ“ DefiniÈ›ia Arborelui AVL</h2>
            <div class="info-box note">
                <div class="info-box-title">ğŸ“ DefiniÈ›ie FormalÄƒ</div>
                Un <strong>arbore AVL</strong> este un arbore binar de cÄƒutare (BST) Ã®n care, pentru <em>fiecare</em> nod, diferenÈ›a absolutÄƒ Ã®ntre Ã®nÄƒlÈ›imile subarborelui stÃ¢ng È™i drept este cel mult 1.
            </div>
            <div class="diagram" style="text-align: center;">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     |height(left_subtree) - height(right_subtree)| â‰¤ 1      â”‚
â”‚                                                              â”‚
â”‚              Pentru FIECARE nod din arbore                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</div>
            <div class="two-columns" style="margin-top: 20px;">
                <div class="column" style="border-left: 3px solid var(--accent-green);">
                    <h4>âœ“ AVL Valid</h4>
                    <div class="diagram">    50(bf=0)
   /  \
  30   70(bf=-1)
 /  \    \
20  40   80</div>
                </div>
                <div class="column" style="border-left: 3px solid var(--accent-red);">
                    <h4>âœ— AVL Invalid</h4>
                    <div class="diagram">    50(bf=2) â† INVALID!
   /
  30(bf=1)
 /
20</div>
                </div>
            </div>
        </div>

        <!-- Slide 7: Balance Factor -->
        <div class="slide">
            <h2>âš–ï¸ Balance Factor</h2>
            <div class="info-box note">
                <div class="info-box-title">ğŸ“ DefiniÈ›ie</div>
                <strong>Balance Factor (bf)</strong> = height(left_subtree) - height(right_subtree)
            </div>
            <table>
                <thead>
                    <tr>
                        <th>Balance Factor</th>
                        <th>Interpretare</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>bf = -1</code></td>
                        <td>Subarbore drept mai Ã®nalt cu 1 nivel</td>
                        <td><span class="badge green">Valid</span></td>
                    </tr>
                    <tr>
                        <td><code>bf = 0</code></td>
                        <td>Subarbori perfect echilibraÈ›i</td>
                        <td><span class="badge green">Valid</span></td>
                    </tr>
                    <tr>
                        <td><code>bf = +1</code></td>
                        <td>Subarbore stÃ¢ng mai Ã®nalt cu 1 nivel</td>
                        <td><span class="badge green">Valid</span></td>
                    </tr>
                    <tr>
                        <td><code>bf < -1</code></td>
                        <td>Dezechilibru spre dreapta</td>
                        <td><span class="badge red">NecesitÄƒ RotaÈ›ie</span></td>
                    </tr>
                    <tr>
                        <td><code>bf > +1</code></td>
                        <td>Dezechilibru spre stÃ¢nga</td>
                        <td><span class="badge red">NecesitÄƒ RotaÈ›ie</span></td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Slide 8: Height Calculation -->
        <div class="slide">
            <h2>ğŸ“ Calculul ÃnÄƒlÈ›imii</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>ConvenÈ›ie</h3>
                    <ul>
                        <li>ÃnÄƒlÈ›imea unui nod <code>NULL</code> = <strong>0</strong></li>
                        <li>ÃnÄƒlÈ›imea unei frunze = <strong>1</strong></li>
                        <li>ÃnÄƒlÈ›imea unui nod = 1 + max(h_left, h_right)</li>
                    </ul>
                    <div class="diagram">    50 (h=3)
   /  \
  30   70 (h=2)
 (h=1)  \
        80 (h=1)</div>
                </div>
                <div class="column">
                    <h3>Implementare</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>FuncÈ›ii auxiliare</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">int height(AVLNode *n) {
    if (n == NULL) return 0;
    return n->height;
}

int max(int a, int b) {
    return (a > b) ? a : b;
}

int balance_factor(AVLNode *n) {
    if (n == NULL) return 0;
    return height(n->left) 
         - height(n->right);
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 9: Node Structure -->
        <div class="slide">
            <h2>ğŸ—ï¸ Structura Nodului AVL</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>DefiniÈ›ia structurii Ã®n C</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">typedef struct AVLNode {
    int key;                    /* Valoarea/cheia stocatÄƒ */
    struct AVLNode *left;       /* Pointer cÄƒtre copilul stÃ¢ng */
    struct AVLNode *right;      /* Pointer cÄƒtre copilul drept */
    int height;                 /* ÃnÄƒlÈ›imea nodului Ã®n arbore */
} AVLNode;

/* FuncÈ›ie de creare a unui nod nou */
AVLNode* create_node(int key) {
    AVLNode *node = (AVLNode*)malloc(sizeof(AVLNode));
    if (node == NULL) {
        fprintf(stderr, "Eroare: alocare memorie eÈ™uatÄƒ\n");
        exit(EXIT_FAILURE);
    }
    node->key = key;
    node->left = NULL;
    node->right = NULL;
    node->height = 1;  /* Nodul nou este iniÈ›ial o frunzÄƒ */
    return node;
}</code></pre>
            </div>
            <div class="info-box tip">
                <div class="info-box-title">ğŸ’¡ ObservaÈ›ie</div>
                Spre deosebire de BST simplu, nodurile AVL stocheazÄƒ explicit <strong>Ã®nÄƒlÈ›imea</strong> pentru calcul rapid al balance factor.
            </div>
        </div>

        <!-- Slide 10: Four Rotations Overview -->
        <div class="slide">
            <h2>ğŸ”„ Cele Patru Tipuri de RotaÈ›ii</h2>
            <div class="card-grid">
                <div class="card">
                    <h4>LL - Left-Left</h4>
                    <p>RotaÈ›ie simplÄƒ la <strong>dreapta</strong></p>
                    <p style="color: var(--accent-yellow);">bf > 1 È™i bf(left) â‰¥ 0</p>
                </div>
                <div class="card">
                    <h4>RR - Right-Right</h4>
                    <p>RotaÈ›ie simplÄƒ la <strong>stÃ¢nga</strong></p>
                    <p style="color: var(--accent-yellow);">bf < -1 È™i bf(right) â‰¤ 0</p>
                </div>
                <div class="card">
                    <h4>LR - Left-Right</h4>
                    <p>RotaÈ›ie <strong>dublÄƒ</strong>: stÃ¢nga + dreapta</p>
                    <p style="color: var(--accent-yellow);">bf > 1 È™i bf(left) < 0</p>
                </div>
                <div class="card">
                    <h4>RL - Right-Left</h4>
                    <p>RotaÈ›ie <strong>dublÄƒ</strong>: dreapta + stÃ¢nga</p>
                    <p style="color: var(--accent-yellow);">bf < -1 È™i bf(right) > 0</p>
                </div>
            </div>
            <table style="margin-top: 30px;">
                <thead>
                    <tr>
                        <th>bf(nod)</th>
                        <th>bf(copil)</th>
                        <th>Tip</th>
                        <th>AcÈ›iune</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>> 1</td>
                        <td>â‰¥ 0</td>
                        <td><span class="badge blue">LL</span></td>
                        <td>rotate_right(nod)</td>
                    </tr>
                    <tr>
                        <td>> 1</td>
                        <td>< 0</td>
                        <td><span class="badge purple">LR</span></td>
                        <td>rotate_left(left), rotate_right(nod)</td>
                    </tr>
                    <tr>
                        <td>< -1</td>
                        <td>â‰¤ 0</td>
                        <td><span class="badge blue">RR</span></td>
                        <td>rotate_left(nod)</td>
                    </tr>
                    <tr>
                        <td>< -1</td>
                        <td>> 0</td>
                        <td><span class="badge purple">RL</span></td>
                        <td>rotate_right(right), rotate_left(nod)</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Slide 11: Right Rotation -->
        <div class="slide">
            <h2>â†©ï¸ RotaÈ›ie la Dreapta (LL Case)</h2>
            <div class="rotation-demo">
                <div class="tree-state">
                    <h4>Ãnainte</h4>
                    <div class="diagram">     z (bf=2)
    /
   y (bfâ‰¥0)
  /
 x</div>
                </div>
                <div class="arrow">â†’</div>
                <div class="tree-state">
                    <h4>DupÄƒ</h4>
                    <div class="diagram">      y
     / \
    x   z</div>
                </div>
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>Implementare rotate_right</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">AVLNode* rotate_right(AVLNode *z) {
    AVLNode *y = z->left;       /* y va deveni noua rÄƒdÄƒcinÄƒ */
    AVLNode *T2 = y->right;     /* SalvÄƒm subarborele din mijloc */
    
    /* EfectuÄƒm rotaÈ›ia */
    y->right = z;               /* z devine copil drept al lui y */
    z->left = T2;               /* T2 devine copil stÃ¢ng al lui z */
    
    /* ActualizÄƒm Ã®nÄƒlÈ›imile (ordinea conteazÄƒ!) */
    z->height = 1 + max(height(z->left), height(z->right));
    y->height = 1 + max(height(y->left), height(y->right));
    
    return y;  /* ReturnÄƒm noua rÄƒdÄƒcinÄƒ a subarborelui */
}</code></pre>
            </div>
        </div>

        <!-- Slide 12: Left Rotation -->
        <div class="slide">
            <h2>â†ªï¸ RotaÈ›ie la StÃ¢nga (RR Case)</h2>
            <div class="rotation-demo">
                <div class="tree-state">
                    <h4>Ãnainte</h4>
                    <div class="diagram">z (bf=-2)
  \
   y (bfâ‰¤0)
    \
     x</div>
                </div>
                <div class="arrow">â†’</div>
                <div class="tree-state">
                    <h4>DupÄƒ</h4>
                    <div class="diagram">      y
     / \
    z   x</div>
                </div>
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>Implementare rotate_left</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">AVLNode* rotate_left(AVLNode *z) {
    AVLNode *y = z->right;      /* y va deveni noua rÄƒdÄƒcinÄƒ */
    AVLNode *T2 = y->left;      /* SalvÄƒm subarborele din mijloc */
    
    /* EfectuÄƒm rotaÈ›ia */
    y->left = z;                /* z devine copil stÃ¢ng al lui y */
    z->right = T2;              /* T2 devine copil drept al lui z */
    
    /* ActualizÄƒm Ã®nÄƒlÈ›imile (ordinea conteazÄƒ!) */
    z->height = 1 + max(height(z->left), height(z->right));
    y->height = 1 + max(height(y->left), height(y->right));
    
    return y;  /* ReturnÄƒm noua rÄƒdÄƒcinÄƒ a subarborelui */
}</code></pre>
            </div>
        </div>

        <!-- Slide 13: LR Rotation -->
        <div class="slide">
            <h2>â†©ï¸â†ªï¸ RotaÈ›ie DublÄƒ LR</h2>
            <p>AplicatÄƒ cÃ¢nd: <code>bf > 1</code> È™i <code>bf(left) < 0</code></p>
            <div class="rotation-demo">
                <div class="tree-state">
                    <h4>IniÈ›ial</h4>
                    <div class="diagram">    z
   /
  y
   \
    x</div>
                </div>
                <div class="arrow">â†’</div>
                <div class="tree-state">
                    <h4>Pas 1: Left(y)</h4>
                    <div class="diagram">    z
   /
  x
 /
y</div>
                </div>
                <div class="arrow">â†’</div>
                <div class="tree-state">
                    <h4>Pas 2: Right(z)</h4>
                    <div class="diagram">    x
   / \
  y   z</div>
                </div>
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>Implementare Ã®n funcÈ›ia de inserare</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/* Cazul LR - detectat Ã®n insert() */
if (bf > 1 && key > node->left->key) {
    node->left = rotate_left(node->left);  /* Pas 1 */
    return rotate_right(node);              /* Pas 2 */
}</code></pre>
            </div>
        </div>

        <!-- Slide 14: RL Rotation -->
        <div class="slide">
            <h2>â†ªï¸â†©ï¸ RotaÈ›ie DublÄƒ RL</h2>
            <p>AplicatÄƒ cÃ¢nd: <code>bf < -1</code> È™i <code>bf(right) > 0</code></p>
            <div class="rotation-demo">
                <div class="tree-state">
                    <h4>IniÈ›ial</h4>
                    <div class="diagram">z
  \
   y
  /
 x</div>
                </div>
                <div class="arrow">â†’</div>
                <div class="tree-state">
                    <h4>Pas 1: Right(y)</h4>
                    <div class="diagram">z
  \
   x
    \
     y</div>
                </div>
                <div class="arrow">â†’</div>
                <div class="tree-state">
                    <h4>Pas 2: Left(z)</h4>
                    <div class="diagram">    x
   / \
  z   y</div>
                </div>
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>Implementare Ã®n funcÈ›ia de inserare</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/* Cazul RL - detectat Ã®n insert() */
if (bf < -1 && key < node->right->key) {
    node->right = rotate_right(node->right);  /* Pas 1 */
    return rotate_left(node);                  /* Pas 2 */
}</code></pre>
            </div>
        </div>

        <!-- Slide 15: Complete Insert Function -->
        <div class="slide">
            <h2>â• FuncÈ›ia de Inserare CompletÄƒ</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>insert() cu auto-echilibrare</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">AVLNode* insert(AVLNode *node, int key) {
    /* 1. Inserare BST standard */
    if (node == NULL) return create_node(key);
    
    if (key < node->key)
        node->left = insert(node->left, key);
    else if (key > node->key)
        node->right = insert(node->right, key);
    else
        return node;  /* Chei duplicate nu sunt permise */
    
    /* 2. Actualizare Ã®nÄƒlÈ›ime */
    node->height = 1 + max(height(node->left), height(node->right));
    
    /* 3. Calcul balance factor È™i reechilibrare */
    int bf = balance_factor(node);
    
    /* Cazul LL */  if (bf > 1 && key < node->left->key)
        return rotate_right(node);
    /* Cazul RR */  if (bf < -1 && key > node->right->key)
        return rotate_left(node);
    /* Cazul LR */  if (bf > 1 && key > node->left->key) {
        node->left = rotate_left(node->left);
        return rotate_right(node);
    }
    /* Cazul RL */  if (bf < -1 && key < node->right->key) {
        node->right = rotate_right(node->right);
        return rotate_left(node);
    }
    return node;  /* Arbore echilibrat, returnÄƒm nodul neschimbat */
}</code></pre>
            </div>
        </div>

        <!-- Slide 16: Insert Example Step by Step -->
        <div class="slide">
            <h2>ğŸ“ Exemplu: Inserare 10, 20, 30</h2>
            <div class="rotation-demo">
                <div class="tree-state">
                    <h4>Insert 10</h4>
                    <div class="diagram">10</div>
                    <p style="color: var(--accent-green);">OK</p>
                </div>
                <div class="arrow">â†’</div>
                <div class="tree-state">
                    <h4>Insert 20</h4>
                    <div class="diagram">10
  \
   20</div>
                    <p style="color: var(--accent-green);">OK (bf=-1)</p>
                </div>
                <div class="arrow">â†’</div>
                <div class="tree-state">
                    <h4>Insert 30</h4>
                    <div class="diagram">10 (bf=-2)
  \
   20
    \
     30</div>
                    <p style="color: var(--accent-red);">RR Case!</p>
                </div>
                <div class="arrow">â†’</div>
                <div class="tree-state">
                    <h4>DupÄƒ RotaÈ›ie</h4>
                    <div class="diagram">   20
  /  \
10    30</div>
                    <p style="color: var(--accent-green);">Echilibrat!</p>
                </div>
            </div>
            <div class="info-box tip">
                <div class="info-box-title">ğŸ’¡ ObservaÈ›ie</div>
                FÄƒrÄƒ reechilibrare AVL, inserarea secvenÈ›ialÄƒ a 1.000 de elemente ar crea un arbore cu Ã®nÄƒlÈ›imea 999. Cu AVL, Ã®nÄƒlÈ›imea maximÄƒ este ~15!
            </div>
        </div>

        <!-- Slide 17: Delete Operation Overview -->
        <div class="slide">
            <h2>â– OperaÈ›ia de È˜tergere</h2>
            <p>È˜tergerea Ã®n AVL urmeazÄƒ aceiaÈ™i paÈ™i ca Ã®n BST, plus reechilibrare:</p>
            <div class="card-grid">
                <div class="card">
                    <h4>Cazul 1: FrunzÄƒ</h4>
                    <p>È˜tergere directÄƒ - eliberare memorie</p>
                </div>
                <div class="card">
                    <h4>Cazul 2: Un copil</h4>
                    <p>Ãnlocuire cu singurul copil</p>
                </div>
                <div class="card">
                    <h4>Cazul 3: Doi copii</h4>
                    <p>Ãnlocuire cu succesorul inorder, apoi È™tergere succesor</p>
                </div>
            </div>
            <div class="info-box warning" style="margin-top: 20px;">
                <div class="info-box-title">âš ï¸ Important</div>
                DupÄƒ È™tergere, trebuie verificat È™i corectat echilibrul pe <strong>Ã®ntregul drum</strong> de la nodul È™ters pÃ¢nÄƒ la rÄƒdÄƒcinÄƒ!
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>GÄƒsirea succesorului inorder</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">AVLNode* min_value_node(AVLNode *node) {
    AVLNode *current = node;
    while (current->left != NULL)
        current = current->left;
    return current;
}</code></pre>
            </div>
        </div>

        <!-- Slide 18: Complete Delete Function -->
        <div class="slide">
            <h2>ğŸ—‘ï¸ FuncÈ›ia de È˜tergere CompletÄƒ</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>delete_node() cu auto-echilibrare (partea 1)</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">AVLNode* delete_node(AVLNode *root, int key) {
    /* 1. È˜tergere BST standard */
    if (root == NULL) return root;
    
    if (key < root->key)
        root->left = delete_node(root->left, key);
    else if (key > root->key)
        root->right = delete_node(root->right, key);
    else {
        /* Nodul de È™ters gÄƒsit */
        if (root->left == NULL || root->right == NULL) {
            AVLNode *temp = root->left ? root->left : root->right;
            if (temp == NULL) {      /* Caz fÄƒrÄƒ copii */
                temp = root;
                root = NULL;
            } else {                  /* Caz cu un copil */
                *root = *temp;
            }
            free(temp);
        } else {
            /* Caz cu doi copii: gÄƒsim succesorul inorder */
            AVLNode *temp = min_value_node(root->right);
            root->key = temp->key;
            root->right = delete_node(root->right, temp->key);
        }
    }
    /* ContinuÄƒ pe slide-ul urmÄƒtor... */</code></pre>
            </div>
        </div>

        <!-- Slide 19: Delete Function Part 2 -->
        <div class="slide">
            <h2>ğŸ—‘ï¸ FuncÈ›ia de È˜tergere (continuare)</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>delete_node() - reechilibrare</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">    /* 2. DacÄƒ arborele avea un singur nod */
    if (root == NULL) return root;
    
    /* 3. Actualizare Ã®nÄƒlÈ›ime */
    root->height = 1 + max(height(root->left), height(root->right));
    
    /* 4. Verificare echilibru È™i rotaÈ›ii */
    int bf = balance_factor(root);
    
    /* Cazul LL */
    if (bf > 1 && balance_factor(root->left) >= 0)
        return rotate_right(root);
    /* Cazul LR */
    if (bf > 1 && balance_factor(root->left) < 0) {
        root->left = rotate_left(root->left);
        return rotate_right(root);
    }
    /* Cazul RR */
    if (bf < -1 && balance_factor(root->right) <= 0)
        return rotate_left(root);
    /* Cazul RL */
    if (bf < -1 && balance_factor(root->right) > 0) {
        root->right = rotate_right(root->right);
        return rotate_left(root);
    }
    return root;
}</code></pre>
            </div>
        </div>

        <!-- Slide 20: Traversal Functions -->
        <div class="slide">
            <h2>ğŸš¶ Parcurgeri (Traversals)</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Inorder (StÃ¢nga-RÄƒdÄƒcinÄƒ-Dreapta)</h3>
                    <p>AfiÈ™eazÄƒ elementele Ã®n ordine <strong>crescÄƒtoare</strong></p>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Parcurgere inorder</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">void inorder(AVLNode *root) {
    if (root != NULL) {
        inorder(root->left);
        printf("%d ", root->key);
        inorder(root->right);
    }
}</code></pre>
                    </div>
                </div>
                <div class="column">
                    <h3>Preorder È™i Postorder</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Preorder (R-S-D)</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">void preorder(AVLNode *root) {
    if (root != NULL) {
        printf("%d ", root->key);
        preorder(root->left);
        preorder(root->right);
    }
}</code></pre>
                    </div>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Postorder (S-D-R)</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">void postorder(AVLNode *root) {
    if (root != NULL) {
        postorder(root->left);
        postorder(root->right);
        printf("%d ", root->key);
    }
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 21: Search Operation -->
        <div class="slide">
            <h2>ğŸ” OperaÈ›ia de CÄƒutare</h2>
            <p>CÄƒutarea Ã®n AVL este <strong>identicÄƒ</strong> cu cÄƒutarea Ã®n BST standard:</p>
            <div class="two-columns">
                <div class="column">
                    <h3>Varianta RecursivÄƒ</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>search() recursiv</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">AVLNode* search(AVLNode *root, int key) {
    /* Caz de bazÄƒ: rÄƒdÄƒcinÄƒ null 
       sau cheia gÄƒsitÄƒ */
    if (root == NULL || root->key == key)
        return root;
    
    /* Cheia mai micÄƒ: cautÄƒ stÃ¢nga */
    if (key < root->key)
        return search(root->left, key);
    
    /* Cheia mai mare: cautÄƒ dreapta */
    return search(root->right, key);
}</code></pre>
                    </div>
                </div>
                <div class="column">
                    <h3>Varianta IterativÄƒ</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>search() iterativ</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">AVLNode* search_iter(AVLNode *root, int key) {
    while (root != NULL && root->key != key) {
        if (key < root->key)
            root = root->left;
        else
            root = root->right;
    }
    return root;
}</code></pre>
                    </div>
                    <div class="info-box tip">
                        <div class="info-box-title">ğŸ’¡ Avantaj AVL</div>
                        CÄƒutarea garantatÄƒ Ã®n <strong>O(log n)</strong> datoritÄƒ echilibrului!
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 22: Memory Management -->
        <div class="slide">
            <h2>ğŸ§¹ Eliberarea Memoriei</h2>
            <p>Este <strong>esenÈ›ial</strong> sÄƒ eliberÄƒm toatÄƒ memoria alocatÄƒ pentru a evita memory leaks:</p>
            <div class="code-block">
                <div class="code-header">
                    <span>FuncÈ›ie de eliberare completÄƒ a arborelui</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void free_tree(AVLNode *root) {
    if (root != NULL) {
        free_tree(root->left);   /* ElibereazÄƒ subarborele stÃ¢ng */
        free_tree(root->right);  /* ElibereazÄƒ subarborele drept */
        free(root);              /* ElibereazÄƒ nodul curent */
    }
}

/* Utilizare Ã®n main() */
int main(void) {
    AVLNode *root = NULL;
    
    /* ... operaÈ›ii cu arborele ... */
    
    free_tree(root);  /* OBLIGATORIU Ã®nainte de exit */
    root = NULL;      /* BunÄƒ practicÄƒ: seteazÄƒ la NULL */
    
    return 0;
}</code></pre>
            </div>
            <div class="info-box danger">
                <div class="info-box-title">âš ï¸ Memory Leak</div>
                NeurmÄƒrirea regulii de eliberare duce la <strong>memory leaks</strong>. VerificaÈ›i cu <code>valgrind --leak-check=full ./program</code>
            </div>
        </div>

        <!-- Slide 23: Complexity Analysis -->
        <div class="slide">
            <h2>ğŸ“Š Analiza ComplexitÄƒÈ›ii</h2>
            <table>
                <thead>
                    <tr>
                        <th>OperaÈ›ie</th>
                        <th>AVL Tree</th>
                        <th>BST (mediu)</th>
                        <th>BST (worst)</th>
                        <th>Array sortat</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>CÄƒutare</td>
                        <td><span class="badge green">O(log n)</span></td>
                        <td>O(log n)</td>
                        <td><span class="badge red">O(n)</span></td>
                        <td>O(log n)</td>
                    </tr>
                    <tr>
                        <td>Inserare</td>
                        <td><span class="badge green">O(log n)</span></td>
                        <td>O(log n)</td>
                        <td><span class="badge red">O(n)</span></td>
                        <td><span class="badge red">O(n)</span></td>
                    </tr>
                    <tr>
                        <td>È˜tergere</td>
                        <td><span class="badge green">O(log n)</span></td>
                        <td>O(log n)</td>
                        <td><span class="badge red">O(n)</span></td>
                        <td><span class="badge red">O(n)</span></td>
                    </tr>
                    <tr>
                        <td>Min/Max</td>
                        <td><span class="badge green">O(log n)</span></td>
                        <td>O(log n)</td>
                        <td>O(n)</td>
                        <td><span class="badge green">O(1)</span></td>
                    </tr>
                    <tr>
                        <td>SpaÈ›iu</td>
                        <td>O(n)</td>
                        <td>O(n)</td>
                        <td>O(n)</td>
                        <td>O(n)</td>
                    </tr>
                </tbody>
            </table>
            <div class="info-box note" style="margin-top: 20px;">
                <div class="info-box-title">ğŸ“ˆ ÃnÄƒlÈ›imea maximÄƒ AVL</div>
                <code>h_max â‰ˆ 1.44 Ã— logâ‚‚(n + 2)</code><br>
                Pentru 1.000.000 noduri: AVL â‰ˆ 29 niveluri vs BST degenerat = 999.999 niveluri
            </div>
        </div>

        <!-- Slide 24: AVL vs Red-Black -->
        <div class="slide">
            <h2>âš”ï¸ AVL vs Red-Black Trees</h2>
            <div class="two-columns">
                <div class="column" style="border-left: 3px solid var(--accent-blue);">
                    <h3>ğŸ”µ AVL Trees</h3>
                    <ul>
                        <li><strong>Echilibru strict:</strong> |bf| â‰¤ 1</li>
                        <li><strong>CÄƒutÄƒri mai rapide</strong> (arbore mai scurt)</li>
                        <li>Mai multe rotaÈ›ii la inserare/È™tergere</li>
                        <li>Overhead memorie: cÃ¢mp height per nod</li>
                        <li><strong>Ideal pentru:</strong> Citiri frecvente, scrieri rare</li>
                    </ul>
                </div>
                <div class="column" style="border-left: 3px solid var(--accent-red);">
                    <h3>ğŸ”´ Red-Black Trees</h3>
                    <ul>
                        <li><strong>Echilibru relaxat:</strong> cel mai lung drum â‰¤ 2Ã— cel mai scurt</li>
                        <li>InserÄƒri/È™tergeri mai rapide</li>
                        <li>Mai puÈ›ine rotaÈ›ii (max 2-3)</li>
                        <li>Overhead memorie: 1 bit culoare per nod</li>
                        <li><strong>Ideal pentru:</strong> Scrieri frecvente (map, set STL)</li>
                    </ul>
                </div>
            </div>
            <div class="info-box tip" style="margin-top: 20px;">
                <div class="info-box-title">ğŸ’¡ Alegerea Ã®n practicÄƒ</div>
                <strong>std::map</strong> È™i <strong>std::set</strong> din C++ STL folosesc Red-Black trees.<br>
                Bazele de date cu multe citiri preferÄƒ variante de AVL sau B-trees.
            </div>
        </div>

        <!-- Slide 25: Common Mistakes -->
        <div class="slide">
            <h2>âš ï¸ GreÈ™eli Frecvente</h2>
            <div class="card-grid">
                <div class="card" style="border-top: 3px solid var(--accent-red);">
                    <h4>âŒ Uitarea actualizÄƒrii Ã®nÄƒlÈ›imii</h4>
                    <p>DupÄƒ rotaÈ›ie, Ã®nÄƒlÈ›imea nodurilor modificate trebuie recalculatÄƒ <strong>Ã®n ordinea corectÄƒ</strong>.</p>
                </div>
                <div class="card" style="border-top: 3px solid var(--accent-red);">
                    <h4>âŒ Ordinea greÈ™itÄƒ a rotaÈ›iilor</h4>
                    <p>Ãn cazurile LR/RL, prima rotaÈ›ie se face pe <strong>copil</strong>, a doua pe <strong>pÄƒrinte</strong>.</p>
                </div>
                <div class="card" style="border-top: 3px solid var(--accent-red);">
                    <h4>âŒ Memory leaks</h4>
                    <p>NeurmÄƒrirea eliberÄƒrii memoriei pentru noduri È™terse sau la finalul programului.</p>
                </div>
                <div class="card" style="border-top: 3px solid var(--accent-red);">
                    <h4>âŒ Neactualizarea rÄƒdÄƒcinii</h4>
                    <p><code>root = insert(root, key);</code> - trebuie capturat rezultatul!</p>
                </div>
            </div>
            <div class="code-block" style="margin-top: 20px;">
                <div class="code-header">
                    <span>âš ï¸ GreÈ™ealÄƒ comunÄƒ vs âœ“ Corect</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/* âŒ GREÈ˜IT - rÄƒdÄƒcina nu se actualizeazÄƒ */
insert(root, 10);

/* âœ“ CORECT - captÄƒm noua rÄƒdÄƒcinÄƒ */
root = insert(root, 10);</code></pre>
            </div>
        </div>

        <!-- Slide 26: Debugging with GDB -->
        <div class="slide">
            <h2>ğŸ› Debugging cu GDB</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Comenzi GDB utile pentru arbori</span>
                    <span class="lang-badge">Bash</span>
                </div>
                <pre><code class="language-bash"># Compilare cu simboluri debug
gcc -g -Wall -o avl_debug avl.c

# Pornire GDB
gdb ./avl_debug

# Comenzi Ã®n GDB:
(gdb) break insert          # Breakpoint la funcÈ›ia insert
(gdb) run                   # Rulare program
(gdb) print root->key       # AfiÈ™are valoare
(gdb) print *root           # AfiÈ™are structurÄƒ completÄƒ
(gdb) print root->left->key # Navigare Ã®n arbore
(gdb) watch root->height    # Oprire cÃ¢nd se modificÄƒ
(gdb) backtrace            # AfiÈ™are call stack
(gdb) step                 # Pas Ã®n funcÈ›ie
(gdb) next                 # Pas peste funcÈ›ie
(gdb) continue             # Continuare execuÈ›ie</code></pre>
            </div>
            <div class="info-box tip">
                <div class="info-box-title">ğŸ’¡ Sfat</div>
                AdÄƒugaÈ›i o funcÈ›ie <code>print_tree()</code> care sÄƒ afiÈ™eze arborele cu indentare pentru debugging vizual!
            </div>
        </div>

        <!-- Slide 27: Valgrind Memory Check -->
        <div class="slide">
            <h2>ğŸ”¬ Verificare Memorie cu Valgrind</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Utilizare Valgrind</span>
                    <span class="lang-badge">Bash</span>
                </div>
                <pre><code class="language-bash"># Verificare completÄƒ memory leaks
valgrind --leak-check=full --show-leak-kinds=all ./avl_program

# Output ideal (fÄƒrÄƒ erori):
==12345== HEAP SUMMARY:
==12345==     in use at exit: 0 bytes in 0 blocks
==12345==   total heap usage: 100 allocs, 100 frees, 4,000 bytes allocated
==12345==
==12345== All heap blocks were freed -- no leaks are possible

# Verificare cu tracking origini
valgrind --track-origins=yes ./avl_program</code></pre>
            </div>
            <div class="info-box danger">
                <div class="info-box-title">ğŸš¨ Erori frecvente detectate de Valgrind</div>
                <ul>
                    <li><strong>definitely lost:</strong> Memory leak cert - trebuie reparat!</li>
                    <li><strong>Invalid read/write:</strong> Acces Ã®n afara memoriei alocate</li>
                    <li><strong>Use of uninitialised value:</strong> VariabilÄƒ neiniÈ›ializatÄƒ</li>
                </ul>
            </div>
        </div>

        <!-- Slide 28: Pretty Print Tree -->
        <div class="slide">
            <h2>ğŸ¨ AfiÈ™are VizualÄƒ a Arborelui</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>FuncÈ›ie de afiÈ™are cu indentare</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void print_tree_helper(AVLNode *root, int space, int indent) {
    if (root == NULL) return;
    
    space += indent;
    
    /* AfiÈ™eazÄƒ mai Ã®ntÃ¢i subarborele drept */
    print_tree_helper(root->right, space, indent);
    
    /* AfiÈ™eazÄƒ nodul curent */
    printf("\n");
    for (int i = indent; i < space; i++) printf(" ");
    printf("%d(h=%d,bf=%d)\n", root->key, root->height, 
           balance_factor(root));
    
    /* AfiÈ™eazÄƒ subarborele stÃ¢ng */
    print_tree_helper(root->left, space, indent);
}

void print_tree(AVLNode *root) {
    printf("\n=== Structura Arborelui AVL ===\n");
    print_tree_helper(root, 0, 5);
    printf("\n");
}</code></pre>
            </div>
        </div>

        <!-- Slide 29: Best Practices -->
        <div class="slide">
            <h2>âœ… Bune Practici</h2>
            <div class="two-columns">
                <div class="column" style="background: rgba(63, 185, 80, 0.1); border: 1px solid var(--accent-green);">
                    <h3 style="color: var(--accent-green);">âœ“ DO</h3>
                    <ul>
                        <li>VerificÄƒ Ã®ntotdeauna pointerii pentru NULL</li>
                        <li>ActualizeazÄƒ Ã®nÄƒlÈ›imea ÃNAINTE de calcul bf</li>
                        <li>CapteazÄƒ rezultatul funcÈ›iilor care modificÄƒ arborele</li>
                        <li>FoloseÈ™te funcÈ›ii auxiliare pentru claritate</li>
                        <li>TesteazÄƒ cu secvenÈ›e care provoacÄƒ toate tipurile de rotaÈ›ii</li>
                        <li>ElibereazÄƒ memoria la finalul programului</li>
                        <li>ValideazÄƒ proprietatea AVL dupÄƒ operaÈ›ii</li>
                    </ul>
                </div>
                <div class="column" style="background: rgba(248, 81, 73, 0.1); border: 1px solid var(--accent-red);">
                    <h3 style="color: var(--accent-red);">âœ— DON'T</h3>
                    <ul>
                        <li>Nu ignora return value-ul funcÈ›iilor</li>
                        <li>Nu presupune cÄƒ arborele este echilibrat</li>
                        <li>Nu uita sÄƒ actualizezi Ã®nÄƒlÈ›imea dupÄƒ rotaÈ›ii</li>
                        <li>Nu amesteca ordinea parametrilor Ã®n rotaÈ›ii</li>
                        <li>Nu crea noduri fÄƒrÄƒ verificare malloc</li>
                        <li>Nu È™terge noduri fÄƒrÄƒ verificare existenÈ›Äƒ</li>
                        <li>Nu testa doar cu date sortate</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 30: Real-World Applications -->
        <div class="slide">
            <h2>ğŸ­ AplicaÈ›ii Ã®n Lumea RealÄƒ</h2>
            <div class="card-grid">
                <div class="card">
                    <h4>ğŸ“ Baze de Date</h4>
                    <p>Indexuri Ã®n memorie pentru cÄƒutÄƒri rapide Ã®n tabele SQL</p>
                </div>
                <div class="card">
                    <h4>ğŸ”§ Compilatoare</h4>
                    <p>Symbol tables pentru tracking variabile È™i funcÈ›ii</p>
                </div>
                <div class="card">
                    <h4>ğŸ–¥ï¸ Sisteme de Operare</h4>
                    <p>Linux CFS scheduler foloseÈ™te variante (Red-Black)</p>
                </div>
                <div class="card">
                    <h4>ğŸ® Game Engines</h4>
                    <p>Spatial indexing pentru collision detection</p>
                </div>
                <div class="card">
                    <h4>ğŸŒ Network Routing</h4>
                    <p>Tabele de rutare pentru lookup IP rapid</p>
                </div>
                <div class="card">
                    <h4>ğŸ’¾ File Systems</h4>
                    <p>Organizarea metadata-urilor fiÈ™ierelor</p>
                </div>
            </div>
        </div>

        <!-- Slide 31: Interview Questions -->
        <div class="slide">
            <h2>ğŸ’¼ ÃntrebÄƒri de Interviu</h2>
            <ol>
                <li style="margin-bottom: 15px;">
                    <strong>Ce este un arbore AVL È™i care este avantajul principal?</strong>
                    <p style="color: var(--text-secondary); margin-top: 5px;">BST auto-echilibrat care garanteazÄƒ O(log n) pentru toate operaÈ›iile.</p>
                </li>
                <li style="margin-bottom: 15px;">
                    <strong>Care este diferenÈ›a dintre AVL È™i Red-Black trees?</strong>
                    <p style="color: var(--text-secondary); margin-top: 5px;">AVL: mai strict echilibrat (cÄƒutÄƒri rapide). RB: echilibru relaxat (inserÄƒri rapide).</p>
                </li>
                <li style="margin-bottom: 15px;">
                    <strong>CÃ¢nd ai alege AVL Ã®n loc de hash table?</strong>
                    <p style="color: var(--text-secondary); margin-top: 5px;">CÃ¢nd ai nevoie de ordine (range queries, iterare sortatÄƒ, min/max).</p>
                </li>
                <li style="margin-bottom: 15px;">
                    <strong>CÃ¢te rotaÈ›ii sunt necesare pentru o inserare Ã®n AVL?</strong>
                    <p style="color: var(--text-secondary); margin-top: 5px;">Maximum 2 rotaÈ›ii (Ã®n cazurile LR sau RL).</p>
                </li>
                <li style="margin-bottom: 15px;">
                    <strong>Care este Ã®nÄƒlÈ›imea maximÄƒ a unui AVL cu n noduri?</strong>
                    <p style="color: var(--text-secondary); margin-top: 5px;">Aproximativ 1.44 Ã— logâ‚‚(n + 2).</p>
                </li>
            </ol>
        </div>

        <!-- Slide 32: Lab Exercise 1 Preview -->
        <div class="slide">
            <h2>ğŸ”¬ Laborator: ExerciÈ›iul 1</h2>
            <h3>Arbore AVL de BazÄƒ</h3>
            <div class="info-box note">
                <div class="info-box-title">ğŸ“‹ Obiectiv</div>
                Implementarea completÄƒ a unui arbore AVL cu operaÈ›ii de inserare È™i afiÈ™are.
            </div>
            <h4>CerinÈ›e:</h4>
            <ol>
                <li>Definirea structurii <code>AVLNode</code></li>
                <li>Implementarea funcÈ›iilor auxiliare: <code>height()</code>, <code>balance_factor()</code>, <code>max()</code></li>
                <li>Implementarea rotaÈ›iilor: <code>rotate_left()</code>, <code>rotate_right()</code></li>
                <li>Implementarea funcÈ›iei <code>insert()</code> cu auto-echilibrare</li>
                <li>Implementarea parcurgerilor: inorder, preorder, postorder</li>
                <li>AfiÈ™area arborelui cu factorul de echilibru</li>
            </ol>
            <div class="code-block">
                <div class="code-header">
                    <span>Rulare test</span>
                    <span class="lang-badge">Bash</span>
                </div>
                <pre><code class="language-bash">make exercise1
./exercise1 < tests/test1_input.txt</code></pre>
            </div>
        </div>

        <!-- Slide 33: Lab Exercise 2 Preview -->
        <div class="slide">
            <h2>ğŸ”¬ Laborator: ExerciÈ›iul 2</h2>
            <h3>Arbore AVL Complet cu È˜tergere</h3>
            <div class="info-box note">
                <div class="info-box-title">ğŸ“‹ Obiectiv</div>
                Extinderea implementÄƒrii cu operaÈ›ia de È™tergere È™i funcÈ›ionalitÄƒÈ›i avansate.
            </div>
            <h4>CerinÈ›e:</h4>
            <ol>
                <li>Implementarea funcÈ›iei <code>delete_node()</code> cu reechilibrare</li>
                <li>GÄƒsirea succesorului inorder pentru noduri cu doi copii</li>
                <li>Implementarea funcÈ›iei <code>search()</code></li>
                <li>Calcularea È™i afiÈ™area statisticilor arborelui</li>
                <li>Validarea proprietÄƒÈ›ii AVL dupÄƒ fiecare operaÈ›ie</li>
                <li>Meniu interactiv pentru operaÈ›ii CRUD</li>
            </ol>
            <div class="info-box tip">
                <div class="info-box-title">ğŸ’¡ Bonus</div>
                ImplementaÈ›i funcÈ›ia <code>range_query(min, max)</code> care returneazÄƒ toate elementele din interval!
            </div>
        </div>

        <!-- Slide 34: Key Takeaways -->
        <div class="slide">
            <h2>ğŸ¯ Recapitulare</h2>
            <div class="summary-grid">
                <div class="summary-box">
                    <div class="icon">âš–ï¸</div>
                    <h4>Balance Factor</h4>
                    <p>|bf| â‰¤ 1 pentru fiecare nod</p>
                </div>
                <div class="summary-box">
                    <div class="icon">ğŸ”„</div>
                    <h4>4 RotaÈ›ii</h4>
                    <p>LL, RR, LR, RL</p>
                </div>
                <div class="summary-box">
                    <div class="icon">ğŸ“Š</div>
                    <h4>Complexitate</h4>
                    <p>O(log n) garantat</p>
                </div>
                <div class="summary-box">
                    <div class="icon">ğŸ“</div>
                    <h4>ÃnÄƒlÈ›ime</h4>
                    <p>h â‰ˆ 1.44 logâ‚‚(n)</p>
                </div>
                <div class="summary-box">
                    <div class="icon">â•</div>
                    <h4>Inserare</h4>
                    <p>BST + reechilibrare</p>
                </div>
                <div class="summary-box">
                    <div class="icon">â–</div>
                    <h4>È˜tergere</h4>
                    <p>BST + reechilibrare</p>
                </div>
            </div>
            <div class="info-box tip" style="margin-top: 30px;">
                <div class="info-box-title">ğŸ”‘ Idee Cheie</div>
                Arborii AVL sacrificÄƒ puÈ›in din viteza de inserare pentru a <strong>garanta</strong> performanÈ›a cÄƒutÄƒrii Ã®n cel mai rÄƒu caz.
            </div>
        </div>

        <!-- Slide 35: Resources -->
        <div class="slide">
            <h2>ğŸ“š Resurse</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>ğŸ“– CÄƒrÈ›i</h3>
                    <ul>
                        <li><strong>CLRS</strong> - Introduction to Algorithms, Cap. 13</li>
                        <li><strong>Sedgewick</strong> - Algorithms, Sec. 3.3</li>
                        <li><strong>Knuth</strong> - TAOCP Vol. 3, Sec. 6.2.3</li>
                    </ul>
                    <h3 style="margin-top: 20px;">ğŸŒ Online</h3>
                    <ul>
                        <li><a href="https://visualgo.net/en/bst" style="color: var(--accent-blue);">Visualgo - AVL Visualization</a></li>
                        <li><a href="https://www.geeksforgeeks.org/avl-tree-set-1-insertion/" style="color: var(--accent-blue);">GeeksforGeeks Tutorials</a></li>
                        <li><a href="https://ocw.mit.edu/" style="color: var(--accent-blue);">MIT OpenCourseWare 6.006</a></li>
                    </ul>
                </div>
                <div class="column">
                    <h3>ğŸ¥ Video</h3>
                    <ul>
                        <li>MIT 6.006 - Lecture on Balanced BSTs</li>
                        <li>Abdul Bari - AVL Tree Rotations</li>
                        <li>mycodeschool - AVL Trees</li>
                    </ul>
                    <h3 style="margin-top: 20px;">ğŸ”§ Tools</h3>
                    <ul>
                        <li><code>gcc -Wall -Wextra -std=c11</code></li>
                        <li><code>valgrind --leak-check=full</code></li>
                        <li><code>gdb</code> pentru debugging</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 36: Next Week Preview -->
        <div class="slide">
            <h2>ğŸ”® SÄƒptÄƒmÃ¢na Viitoare</h2>
            <h3>SÄƒptÄƒmÃ¢na 10: Heap-uri È™i Priority Queues</h3>
            <div class="card-grid" style="margin-top: 30px;">
                <div class="card">
                    <h4>ğŸ“ Heap Property</h4>
                    <p>Max-heap È™i Min-heap</p>
                </div>
                <div class="card">
                    <h4>â¬†ï¸â¬‡ï¸ Heapify</h4>
                    <p>heapify-up, heapify-down</p>
                </div>
                <div class="card">
                    <h4>ğŸ—ï¸ Build Heap</h4>
                    <p>ConstrucÈ›ie eficientÄƒ O(n)</p>
                </div>
                <div class="card">
                    <h4>ğŸ”¢ Heap Sort</h4>
                    <p>Sortare Ã®n O(n log n)</p>
                </div>
            </div>
            <div class="info-box note" style="margin-top: 30px;">
                <div class="info-box-title">ğŸ”— Conexiune</div>
                Heap-urile oferÄƒ O(1) pentru gÄƒsirea min/max, dar nu suportÄƒ cÄƒutare eficientÄƒ ca AVL trees. Alegerea depinde de cazul de utilizare!
            </div>
        </div>

        <!-- Slide 37: Questions -->
        <div class="slide title-slide">
            <h1>â“ ÃntrebÄƒri?</h1>
            <p class="subtitle">MulÈ›umesc pentru atenÈ›ie!</p>
            <div style="margin-top: 40px;">
                <p class="course-info">
                    <span style="color: var(--accent-blue);">SÄƒptÄƒmÃ¢na 09: Arbori AVL</span><br>
                    Algoritmi È™i Tehnici de Programare<br>
                    ASE BucureÈ™ti - CSIE
                </p>
            </div>
            <div style="margin-top: 30px;">
                <span class="badge green">Laborator disponibil Ã®n directorul src/</span>
            </div>
        </div>

    </div>

    <!-- Navigation -->
    <div class="slide-counter" id="slideCounter">1 / 37</div>
    
    <div class="kbd-hint">
        <kbd>â†</kbd> <kbd>â†’</kbd> pentru navigare | <kbd>Home</kbd> <kbd>End</kbd> pentru Ã®nceput/final
    </div>
    
    <div class="nav-container">
        <button class="nav-btn" id="prevBtn" onclick="changeSlide(-1)">â† Anterior</button>
        <button class="nav-btn" id="nextBtn" onclick="changeSlide(1)">UrmÄƒtor â†’</button>
    </div>

    <script>
        // Initialize highlight.js
        hljs.highlightAll();

        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        const totalSlides = slides.length;
        const progressBar = document.getElementById('progressBar');
        const slideCounter = document.getElementById('slideCounter');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');

        function showSlide(index) {
            // Remove active class from all slides
            slides.forEach(slide => slide.classList.remove('active'));
            
            // Clamp index
            if (index < 0) index = 0;
            if (index >= totalSlides) index = totalSlides - 1;
            
            currentSlide = index;
            
            // Add active class to current slide
            slides[currentSlide].classList.add('active');
            
            // Update progress bar
            const progress = ((currentSlide + 1) / totalSlides) * 100;
            progressBar.style.width = progress + '%';
            
            // Update counter
            slideCounter.textContent = `${currentSlide + 1} / ${totalSlides}`;
            
            // Update button states
            prevBtn.disabled = currentSlide === 0;
            nextBtn.disabled = currentSlide === totalSlides - 1;
        }

        function changeSlide(direction) {
            showSlide(currentSlide + direction);
        }

        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            switch(e.key) {
                case 'ArrowRight':
                case ' ':
                    e.preventDefault();
                    changeSlide(1);
                    break;
                case 'ArrowLeft':
                    changeSlide(-1);
                    break;
                case 'Home':
                    showSlide(0);
                    break;
                case 'End':
                    showSlide(totalSlides - 1);
                    break;
            }
        });

        // Touch support for mobile
        let touchStartX = 0;
        let touchEndX = 0;

        document.addEventListener('touchstart', e => {
            touchStartX = e.changedTouches[0].screenX;
        });

        document.addEventListener('touchend', e => {
            touchEndX = e.changedTouches[0].screenX;
            handleSwipe();
        });

        function handleSwipe() {
            const threshold = 50;
            const diff = touchStartX - touchEndX;
            
            if (Math.abs(diff) > threshold) {
                if (diff > 0) {
                    changeSlide(1); // Swipe left = next
                } else {
                    changeSlide(-1); // Swipe right = prev
                }
            }
        }

        // Initialize
        showSlide(0);
    </script>
</body>
</html>
