<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SÄƒptÄƒmÃ¢na 8: Arbori Binari de CÄƒutare (BST) | ATP</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-yellow: #d29922;
            --accent-red: #f85149;
            --accent-purple: #a371f7;
            --border-color: #30363d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        /* Progress Bar */
        #progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            transition: width 0.3s ease;
            z-index: 1000;
        }

        /* Slide Container */
        #presentation {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        .slide {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 60px 80px;
            opacity: 0;
            transition: opacity 0.4s ease;
            overflow-y: auto;
        }

        .slide.active {
            display: flex;
            flex-direction: column;
            opacity: 1;
        }

        /* Typography */
        h1 {
            font-size: 2.8em;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 20px;
            line-height: 1.2;
        }

        h2 {
            font-size: 2.2em;
            font-weight: 600;
            color: var(--accent-blue);
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border-color);
        }

        h3 {
            font-size: 1.5em;
            color: var(--accent-green);
            margin: 20px 0 15px 0;
        }

        p {
            font-size: 1.3em;
            line-height: 1.7;
            color: var(--text-primary);
            margin-bottom: 20px;
        }

        ul, ol {
            font-size: 1.25em;
            line-height: 1.8;
            margin-left: 30px;
            margin-bottom: 20px;
        }

        li {
            margin-bottom: 12px;
        }

        li::marker {
            color: var(--accent-blue);
        }

        /* Code Blocks */
        .code-block {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin: 20px 0;
            overflow: hidden;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .lang-badge {
            background: var(--accent-blue);
            color: var(--bg-primary);
            padding: 3px 10px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.85em;
        }

        pre {
            margin: 0;
            padding: 20px;
            overflow-x: auto;
        }

        code {
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 0.95em;
            line-height: 1.5;
        }

        /* ASCII Art / Diagrams */
        .diagram {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 25px;
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 1.1em;
            line-height: 1.4;
            white-space: pre;
            overflow-x: auto;
            color: var(--accent-green);
            margin: 20px 0;
        }

        /* Info Boxes */
        .info-box {
            background: var(--bg-secondary);
            border-left: 4px solid var(--accent-blue);
            padding: 20px 25px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .warning-box {
            background: rgba(210, 153, 34, 0.1);
            border-left: 4px solid var(--accent-yellow);
            padding: 20px 25px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .error-box {
            background: rgba(248, 81, 73, 0.1);
            border-left: 4px solid var(--accent-red);
            padding: 20px 25px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .success-box {
            background: rgba(63, 185, 80, 0.1);
            border-left: 4px solid var(--accent-green);
            padding: 20px 25px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 1.1em;
        }

        th, td {
            padding: 15px 20px;
            text-align: left;
            border: 1px solid var(--border-color);
        }

        th {
            background: var(--bg-tertiary);
            color: var(--accent-blue);
            font-weight: 600;
        }

        tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Two Column Layout */
        .two-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            margin: 20px 0;
        }

        .column {
            background: var(--bg-secondary);
            padding: 25px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        /* Grid Cards */
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 25px;
            transition: transform 0.2s, border-color 0.2s;
        }

        .card:hover {
            transform: translateY(-3px);
            border-color: var(--accent-blue);
        }

        .card h4 {
            color: var(--accent-purple);
            font-size: 1.2em;
            margin-bottom: 12px;
        }

        .card p {
            font-size: 1em;
            color: var(--text-secondary);
            margin: 0;
        }

        /* Title Slide Specific */
        .title-slide {
            justify-content: center;
            align-items: center;
            text-align: center;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
        }

        .title-slide h1 {
            font-size: 3.5em;
            margin-bottom: 20px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .title-slide .subtitle {
            font-size: 1.8em;
            color: var(--text-secondary);
            margin-bottom: 40px;
        }

        .title-slide .meta {
            font-size: 1.2em;
            color: var(--text-secondary);
        }

        /* Navigation */
        #nav-controls {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .nav-btn {
            width: 50px;
            height: 50px;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.3em;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .nav-btn:hover {
            background: var(--accent-blue);
            color: var(--bg-primary);
            border-color: var(--accent-blue);
        }

        /* Slide Counter */
        #slide-counter {
            position: fixed;
            bottom: 30px;
            left: 30px;
            font-size: 1em;
            color: var(--text-secondary);
            background: var(--bg-secondary);
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            z-index: 100;
        }

        /* Quote */
        blockquote {
            border-left: 4px solid var(--accent-purple);
            padding-left: 25px;
            margin: 25px 0;
            font-style: italic;
            color: var(--text-secondary);
            font-size: 1.2em;
        }

        blockquote cite {
            display: block;
            margin-top: 10px;
            font-size: 0.9em;
            color: var(--accent-blue);
        }

        /* Highlight */
        .highlight {
            color: var(--accent-yellow);
            font-weight: 600;
        }

        .highlight-blue {
            color: var(--accent-blue);
        }

        .highlight-green {
            color: var(--accent-green);
        }

        .highlight-red {
            color: var(--accent-red);
        }

        /* Animation for diagrams */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .slide.active .diagram,
        .slide.active .code-block,
        .slide.active .card {
            animation: fadeIn 0.5s ease forwards;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-blue);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .slide {
                padding: 40px 50px;
            }
            h1 { font-size: 2.2em; }
            h2 { font-size: 1.8em; }
            .two-columns {
                grid-template-columns: 1fr;
            }
        }

        /* Complexity badge */
        .complexity {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
            margin-left: 10px;
        }
        
        .complexity.logn {
            background: rgba(63, 185, 80, 0.2);
            color: var(--accent-green);
        }
        
        .complexity.n {
            background: rgba(248, 81, 73, 0.2);
            color: var(--accent-red);
        }
    </style>
</head>
<body>
    <div id="progress-bar"></div>
    
    <div id="presentation">
        <!-- Slide 1: Title -->
        <div class="slide title-slide active">
            <h1>Arbori Binari de CÄƒutare</h1>
            <p class="subtitle">Binary Search Trees (BST)</p>
            <p class="meta">
                <strong>SÄƒptÄƒmÃ¢na 8</strong> | Algoritmi È™i Tehnici de Programare<br><br>
                Academia de Studii Economice din BucureÈ™ti<br>
                CiberneticÄƒ, StatisticÄƒ È™i InformaticÄƒ EconomicÄƒ
            </p>
        </div>

        <!-- Slide 2: Learning Objectives -->
        <div class="slide">
            <h2>ğŸ¯ Obiective de ÃnvÄƒÈ›are</h2>
            <p>La finalul acestei sesiuni, veÈ›i fi capabili sÄƒ:</p>
            <ol>
                <li><strong>DefiniÈ›i</strong> proprietatea fundamentalÄƒ a unui BST È™i structura nodului Ã®n C</li>
                <li><strong>ExplicaÈ›i</strong> de ce cÄƒutarea Ã®ntr-un BST echilibrat este O(log n)</li>
                <li><strong>ImplementaÈ›i</strong> operaÈ›iile search, insert È™i delete Ã®n C</li>
                <li><strong>AnalizaÈ›i</strong> cÃ¢nd BST degenereazÄƒ È™i impactul asupra performanÈ›ei</li>
                <li><strong>ComparaÈ›i</strong> BST cu alte structuri: array sortat, liste, hash tables</li>
                <li><strong>ProiectaÈ›i</strong> aplicaÈ›ii practice: dicÈ›ionare, indexuri, autocompletare</li>
            </ol>
        </div>

        <!-- Slide 3: Historical Context -->
        <div class="slide">
            <h2>ğŸ“œ Context Istoric</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Cronologie</h3>
                    <ul>
                        <li><strong>1946</strong> - John Mauchly: cÄƒutare binarÄƒ Ã®n array-uri</li>
                        <li><strong>1959</strong> - Booth & Booth: primele BST documentate</li>
                        <li><strong>1962</strong> - Hibbard: algoritm formal de È™tergere</li>
                        <li><strong>1962</strong> - Adelson-Velsky & Landis: arbori AVL</li>
                        <li><strong>1972</strong> - Rudolf Bayer: Red-Black Trees</li>
                    </ul>
                </div>
                <div class="column">
                    <h3>MotivaÈ›ia</h3>
                    <p>Problema fundamentalÄƒ: cum menÈ›inem date <span class="highlight">sortate</span> cu:</p>
                    <ul>
                        <li>InserÄƒri eficiente</li>
                        <li>È˜tergeri eficiente</li>
                        <li>CÄƒutÄƒri rapide</li>
                    </ul>
                    <p>Array-urile sortate oferÄƒ cÄƒutare O(log n), dar inserare O(n)!</p>
                </div>
            </div>
        </div>

        <!-- Slide 4: Key Figure -->
        <div class="slide">
            <h2>ğŸ‘¤ FigurÄƒ Cheie: Thomas N. Hibbard</h2>
            <div class="two-columns">
                <div class="column">
                    <div class="diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Thomas N. Hibbard (1932-2017) â”‚
â”‚  Matematician & Informatician   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â€¢ PhD Princeton, 1957          â”‚
â”‚  â€¢ Profesor UCLA, UC San Diego  â”‚
â”‚  â€¢ Pionier analiza algoritmilor â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    </div>
                    <p>ContribuÈ›ie fundamentalÄƒ: algoritmul de <span class="highlight">È™tergere Ã®n BST</span> care menÈ›ine proprietatea arborelui.</p>
                </div>
                <div class="column">
                    <h3>Citat Celebru</h3>
                    <blockquote>
                        "The deletion algorithm presented here has the property that it preserves the binary search tree property regardless of which node is deleted."
                        <cite>â€” T.N. Hibbard, Communications of the ACM, 1962</cite>
                    </blockquote>
                    <div class="info-box">
                        <strong>Fun fact:</strong> Algoritmul Hibbard este Ã®ncÄƒ folosit astÄƒzi Ã®n majoritatea implementÄƒrilor BST de bazÄƒ.
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 5: BST Property -->
        <div class="slide">
            <h2>ğŸ“ Proprietatea BST</h2>
            <div class="info-box">
                <p><strong>DefiniÈ›ie:</strong> Un Binary Search Tree este un arbore binar Ã®n care pentru <em>orice</em> nod N cu valoarea K:</p>
                <ul>
                    <li>Toate valorile din subarborele <span class="highlight-blue">STÃ‚NG</span> sunt <strong>&lt; K</strong></li>
                    <li>Toate valorile din subarborele <span class="highlight-green">DREPT</span> sunt <strong>&gt; K</strong></li>
                </ul>
            </div>
            <div class="diagram">
                    50              Proprietatea se aplicÄƒ RECURSIV:
                  /    \           
                30      70         30: stÃ¢ng(20) < 30 < drept(40) âœ“
               /  \    /  \        70: stÃ¢ng(60) < 70 < drept(80) âœ“
             20   40  60   80      50: stÃ¢ng(30,20,40) < 50 < drept(70,60,80) âœ“
            </div>
            <div class="success-box">
                <strong>ConsecinÈ›Äƒ magicÄƒ:</strong> Parcurgerea INORDER produce elementele Ã®n ordine SORTATÄ‚!<br>
                <code>20 â†’ 30 â†’ 40 â†’ 50 â†’ 60 â†’ 70 â†’ 80</code>
            </div>
        </div>

        <!-- Slide 6: Node Structure in C -->
        <div class="slide">
            <h2>ğŸ”§ Structura Nodului Ã®n C</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Definirea structurii BST</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/* Structura unui nod Ã®n BST */
typedef struct BSTNode {
    int key;                    /* Cheia de cÄƒutare/comparare */
    void *data;                 /* Pointer cÄƒtre date (generic) */
    struct BSTNode *left;       /* Subarbore stÃ¢ng (valori < key) */
    struct BSTNode *right;      /* Subarbore drept (valori > key) */
} BSTNode;

/* Structura arborelui complet */
typedef struct {
    BSTNode *root;              /* Pointer cÄƒtre rÄƒdÄƒcinÄƒ */
    size_t size;                /* NumÄƒrul total de noduri */
    int (*compare)(const void*, const void*);  /* FuncÈ›ie de comparare */
} BST;

/* Creare nod nou */
BSTNode* bst_create_node(int key, void *data) {
    BSTNode *node = malloc(sizeof(BSTNode));
    if (node) {
        node->key = key;
        node->data = data;
        node->left = NULL;
        node->right = NULL;
    }
    return node;
}</code></pre>
            </div>
        </div>

        <!-- Slide 7: Memory Layout -->
        <div class="slide">
            <h2>ğŸ§  Model de Memorie</h2>
            <div class="diagram">
    STACK                           HEAP
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ BST tree    â”‚                â”‚                                 â”‚
    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚                â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
    â”‚ â”‚root â”€â”€â”€â”€â”¼â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â–ºâ”‚ BSTNode      â”‚             â”‚
    â”‚ â”‚size: 5  â”‚ â”‚                â”‚    â”‚ key: 50      â”‚             â”‚
    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚                â”‚    â”‚ left â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚â”€â”€â”€â”€â”        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚    â”‚ right â”€â”€â”€â”€â”€â”€â–ºâ”‚â”€â”€â”€â”â”‚        â”‚
                                   â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚â”‚        â”‚
                                   â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚        â”‚
                                   â”‚         â–¼              â”‚        â”‚
                                   â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚        â”‚
                                   â”‚    â”‚ BSTNode      â”‚   â”‚        â”‚
                                   â”‚    â”‚ key: 30      â”‚   â”‚        â”‚
                                   â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚        â”‚
                                   â”‚                       â–¼        â”‚
                                   â”‚                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                   â”‚                  â”‚ BSTNode      â”‚
                                   â”‚                  â”‚ key: 70      â”‚
                                   â”‚                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
            <div class="warning-box">
                <strong>âš ï¸ AtenÈ›ie:</strong> Fiecare nod este alocat separat cu <code>malloc()</code>. 
                Nu uitaÈ›i sÄƒ eliberaÈ›i TOATE nodurile la final!
            </div>
        </div>

        <!-- Slide 8: Search Algorithm -->
        <div class="slide">
            <h2>ğŸ” OperaÈ›ia de CÄƒutare (Search)</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Algoritm</h3>
                    <div class="diagram" style="font-size: 0.95em;">
SEARCH(root, key):
  current = root
  
  WHILE current â‰  NULL:
    IF key == current.key:
      RETURN current  âœ“
    
    IF key < current.key:
      current = current.left
    ELSE:
      current = current.right
  
  RETURN NULL  âœ—
                    </div>
                </div>
                <div class="column">
                    <h3>Vizualizare: cÄƒutÄƒm 40</h3>
                    <div class="diagram">
      [50]  â† 40 < 50, mergem stÃ¢nga
      /
    [30]    â† 40 > 30, mergem dreapta
       \
       [40] â† GÄ‚SIT! âœ“
                    </div>
                    <p><strong>PaÈ™i:</strong> 3 comparaÈ›ii pentru arbore de 7 noduri</p>
                    <p>Complexitate: <span class="complexity logn">O(log n)</span></p>
                </div>
            </div>
        </div>

        <!-- Slide 9: Search Implementation -->
        <div class="slide">
            <h2>ğŸ’» Implementare CÄƒutare</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>VariantÄƒ IterativÄƒ (recomandatÄƒ)</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>CÄƒutare iterativÄƒ - O(1) spaÈ›iu extra</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">BSTNode* bst_search(BST *tree, int key) {
    BSTNode *current = tree->root;
    
    while (current != NULL) {
        if (key == current->key) {
            return current;  /* GÄƒsit! */
        }
        
        if (key < current->key) {
            current = current->left;
        } else {
            current = current->right;
        }
    }
    
    return NULL;  /* NegÄƒsit */
}</code></pre>
                    </div>
                </div>
                <div class="column">
                    <h3>VariantÄƒ RecursivÄƒ (elegantÄƒ)</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>CÄƒutare recursivÄƒ - O(h) spaÈ›iu stack</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">BSTNode* bst_search_rec(BSTNode *node, 
                        int key) {
    /* Caz de bazÄƒ */
    if (node == NULL) {
        return NULL;
    }
    
    if (key == node->key) {
        return node;
    }
    
    /* Recursie stÃ¢nga sau dreapta */
    if (key < node->key) {
        return bst_search_rec(node->left, key);
    }
    return bst_search_rec(node->right, key);
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 10: Insert Algorithm -->
        <div class="slide">
            <h2>â• OperaÈ›ia de Inserare (Insert)</h2>
            <div class="info-box">
                <p><strong>Principiu:</strong> Nodul nou este ÃNTOTDEAUNA inserat ca <span class="highlight">frunzÄƒ</span>. 
                NavigÄƒm arborele exact ca la cÄƒutare pÃ¢nÄƒ gÄƒsim poziÈ›ia corectÄƒ.</p>
            </div>
            <div class="diagram">
    Inserare 35 Ã®n arbore:
    
          50                          50
        /    \                      /    \
      30      70      â”€â”€â”€â–º        30      70
     /  \                        /  \
   20   40                     20   40
                                  /
                                35 â† NOU (frunzÄƒ)
    
    PaÈ™i: 50â†’30â†’40â†’stÃ¢nga lui 40 (pentru cÄƒ 35 < 40)
            </div>
        </div>

        <!-- Slide 11: Insert Implementation -->
        <div class="slide">
            <h2>ğŸ’» Implementare Inserare</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Inserare recursivÄƒ - returneazÄƒ rÄƒdÄƒcina (posibil modificatÄƒ)</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">BSTNode* bst_insert(BSTNode *node, int key, void *data) {
    /* Caz de bazÄƒ: am gÄƒsit locul - creÄƒm nod nou */
    if (node == NULL) {
        return bst_create_node(key, data);
    }
    
    /* Navigare: stÃ¢nga dacÄƒ key < current, dreapta altfel */
    if (key < node->key) {
        node->left = bst_insert(node->left, key, data);
    } else if (key > node->key) {
        node->right = bst_insert(node->right, key, data);
    }
    /* key == node->key: duplicat - ignorÄƒm sau actualizÄƒm data */
    
    return node;  /* ReturnÄƒm nodul curent (neschimbat) */
}

/* FuncÈ›ie wrapper pentru BST */
void bst_add(BST *tree, int key, void *data) {
    tree->root = bst_insert(tree->root, key, data);
    tree->size++;
}</code></pre>
            </div>
            <div class="success-box">
                <strong>ObservaÈ›ie:</strong> Recursivitatea returneazÄƒ nodul permite reconstruirea legÄƒturilor automat!
            </div>
        </div>

        <!-- Slide 12: Delete Cases -->
        <div class="slide">
            <h2>ğŸ—‘ï¸ È˜tergerea: Cele 3 Cazuri</h2>
            <div class="card-grid">
                <div class="card">
                    <h4>Cazul 1: Nod FRUNZÄ‚</h4>
                    <div class="diagram" style="font-size: 0.9em; color: var(--accent-green);">
    50          50
   /  \        /  \
 30    70 â†’  30    70
 /
[20]        (È™ters)
                    </div>
                    <p>Simplu: eliberÄƒm nodul, setÄƒm pointer-ul pÄƒrinte la NULL</p>
                </div>
                <div class="card">
                    <h4>Cazul 2: UN copil</h4>
                    <div class="diagram" style="font-size: 0.9em; color: var(--accent-yellow);">
    50          50
   /  \        /  \
[30]   70 â†’  20    70
 /
20
                    </div>
                    <p>Ãnlocuim nodul cu unicul sÄƒu copil (bypass)</p>
                </div>
                <div class="card">
                    <h4>Cazul 3: DOI copii</h4>
                    <div class="diagram" style="font-size: 0.9em; color: var(--accent-red);">
   [50]          60
   /  \         /  \
 30    70  â†’  30    70
      /              \
    60               80
                    </div>
                    <p>Ãnlocuim cu SUCCESORUL inorder (min din dreapta)</p>
                </div>
            </div>
        </div>

        <!-- Slide 13: Delete - Case 3 Detail -->
        <div class="slide">
            <h2>ğŸ”¬ È˜tergere Caz 3: Algoritmul Hibbard</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>PaÈ™i:</h3>
                    <ol>
                        <li>GÄƒsim <span class="highlight">succesorul inorder</span> = cel mai mic nod din subarborele DREPT</li>
                        <li><span class="highlight">Copiem</span> valoarea succesorului Ã®n nodul de È™ters</li>
                        <li><span class="highlight">È˜tergem</span> succesorul (care are max 1 copil!)</li>
                    </ol>
                    <div class="info-box">
                        <strong>De ce funcÈ›ioneazÄƒ?</strong> Succesorul inorder este urmÄƒtoarea valoare Ã®n ordine sortatÄƒ, deci menÈ›ine proprietatea BST.
                    </div>
                </div>
                <div class="column">
                    <div class="diagram">
È˜tergem nodul 50:

      [50]           Pas 1: gÄƒsim min(drept)
      /  \           = 60 (succesor)
    30    70    
   /  \   / \
 20  40 60  80

       60            Pas 2: copiem 60â†’50
      /  \           Pas 3: È™tergem vechiul 60
    30    70    
   /  \     \
 20  40     80
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 14: Delete Implementation -->
        <div class="slide">
            <h2>ğŸ’» Implementare È˜tergere</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>È˜tergere completÄƒ cu toate cele 3 cazuri</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/* GÄƒseÈ™te minimul din subarbore (succesor inorder) */
BSTNode* bst_find_min(BSTNode *node) {
    while (node->left != NULL) {
        node = node->left;
    }
    return node;
}

BSTNode* bst_delete(BSTNode *node, int key) {
    if (node == NULL) return NULL;
    
    /* Navigare pentru gÄƒsirea nodului */
    if (key < node->key) {
        node->left = bst_delete(node->left, key);
    } else if (key > node->key) {
        node->right = bst_delete(node->right, key);
    } else {
        /* Am gÄƒsit nodul de È™ters */
        
        /* Caz 1 & 2: 0 sau 1 copil */
        if (node->left == NULL) {
            BSTNode *temp = node->right;
            free(node);
            return temp;
        }
        if (node->right == NULL) {
            BSTNode *temp = node->left;
            free(node);
            return temp;
        }
        
        /* Caz 3: 2 copii - Ã®nlocuim cu succesorul */
        BSTNode *successor = bst_find_min(node->right);
        node->key = successor->key;
        node->right = bst_delete(node->right, successor->key);
    }
    return node;
}</code></pre>
            </div>
        </div>

        <!-- Slide 15: Traversals -->
        <div class="slide">
            <h2>ğŸš¶ Parcurgeri (Traversals)</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Cele 3 parcurgeri clasice</h3>
                    <table>
                        <tr>
                            <th>Parcurgere</th>
                            <th>Ordine</th>
                            <th>Rezultat</th>
                        </tr>
                        <tr>
                            <td><strong>Inorder</strong></td>
                            <td>L â†’ R â†’ D</td>
                            <td class="highlight-green">SORTAT!</td>
                        </tr>
                        <tr>
                            <td><strong>Preorder</strong></td>
                            <td>R â†’ L â†’ D</td>
                            <td>Copiere arbore</td>
                        </tr>
                        <tr>
                            <td><strong>Postorder</strong></td>
                            <td>L â†’ D â†’ R</td>
                            <td>È˜tergere arbore</td>
                        </tr>
                    </table>
                </div>
                <div class="column">
                    <div class="diagram">
         50
        /  \
      30    70
     /  \
   20   40

Inorder:   20, 30, 40, 50, 70
Preorder:  50, 30, 20, 40, 70
Postorder: 20, 40, 30, 70, 50
                    </div>
                </div>
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>Parcurgere inorder - produce elemente sortate</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void bst_inorder(BSTNode *node, void (*visit)(BSTNode*)) {
    if (node == NULL) return;
    bst_inorder(node->left, visit);   /* StÃ¢nga */
    visit(node);                       /* ViziteazÄƒ */
    bst_inorder(node->right, visit);  /* Dreapta */
}</code></pre>
            </div>
        </div>

        <!-- Slide 16: Min/Max/Successor/Predecessor -->
        <div class="slide">
            <h2>ğŸ“Š OperaÈ›ii Auxiliare</h2>
            <div class="card-grid">
                <div class="card">
                    <h4>Minim</h4>
                    <p>Mergem tot la stÃ¢nga pÃ¢nÄƒ la frunzÄƒ</p>
                    <div class="code-block" style="margin: 10px 0;">
                        <pre><code class="language-c">BSTNode* bst_min(BSTNode *node) {
    while (node && node->left)
        node = node->left;
    return node;
}</code></pre>
                    </div>
                </div>
                <div class="card">
                    <h4>Maxim</h4>
                    <p>Mergem tot la dreapta pÃ¢nÄƒ la frunzÄƒ</p>
                    <div class="code-block" style="margin: 10px 0;">
                        <pre><code class="language-c">BSTNode* bst_max(BSTNode *node) {
    while (node && node->right)
        node = node->right;
    return node;
}</code></pre>
                    </div>
                </div>
                <div class="card">
                    <h4>Succesor Inorder</h4>
                    <p>UrmÄƒtorul element Ã®n ordine sortatÄƒ</p>
                    <div class="code-block" style="margin: 10px 0;">
                        <pre><code class="language-c">/* DacÄƒ are subarbore drept */
BSTNode* succ = bst_min(node->right);
/* Altfel: urcÄƒm Ã®n sus */</code></pre>
                    </div>
                </div>
                <div class="card">
                    <h4>Predecesor Inorder</h4>
                    <p>Elementul anterior Ã®n ordine sortatÄƒ</p>
                    <div class="code-block" style="margin: 10px 0;">
                        <pre><code class="language-c">/* DacÄƒ are subarbore stÃ¢ng */
BSTNode* pred = bst_max(node->left);
/* Altfel: urcÄƒm Ã®n sus */</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 17: Complexity Analysis -->
        <div class="slide">
            <h2>ğŸ“ˆ Analiza ComplexitÄƒÈ›ii</h2>
            <table>
                <tr>
                    <th>OperaÈ›ie</th>
                    <th>Caz Mediu</th>
                    <th>Caz Defavorabil</th>
                    <th>SpaÈ›iu</th>
                </tr>
                <tr>
                    <td>Search</td>
                    <td><span class="complexity logn">O(log n)</span></td>
                    <td><span class="complexity n">O(n)</span></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Insert</td>
                    <td><span class="complexity logn">O(log n)</span></td>
                    <td><span class="complexity n">O(n)</span></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Delete</td>
                    <td><span class="complexity logn">O(log n)</span></td>
                    <td><span class="complexity n">O(n)</span></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Min/Max</td>
                    <td><span class="complexity logn">O(log n)</span></td>
                    <td><span class="complexity n">O(n)</span></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Traversal</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                    <td>O(h)*</td>
                </tr>
            </table>
            <p style="margin-top: 20px;"><em>* h = Ã®nÄƒlÈ›imea arborelui; Ã®n caz echilibrat h â‰ˆ log n</em></p>
            <div class="warning-box">
                <strong>Problema fundamentalÄƒ:</strong> Cazul defavorabil O(n) apare cÃ¢nd arborele degenereazÄƒ Ã®ntr-o listÄƒ!
            </div>
        </div>

        <!-- Slide 18: Degenerate BST -->
        <div class="slide">
            <h2>âš ï¸ Problema Dezechilibrului</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Arbore Echilibrat</h3>
                    <p>Inserare Ã®n ordine aleatorie: 50, 30, 70, 20, 40</p>
                    <div class="diagram">
         50
        /  \
      30    70
     /  \
   20   40

   h = 2
   OperaÈ›ii: O(log 5) â‰ˆ 2-3 paÈ™i
                    </div>
                    <div class="success-box">âœ“ Eficient</div>
                </div>
                <div class="column">
                    <h3>Arbore Degenerat</h3>
                    <p>Inserare Ã®n ordine sortatÄƒ: 20, 30, 40, 50, 70</p>
                    <div class="diagram">
   20
     \
     30
       \
       40
         \
         50
           \
           70
           
   h = 4
   OperaÈ›ii: O(5) = 5 paÈ™i
                    </div>
                    <div class="error-box">âœ— Lista Ã®nlÄƒnÈ›uitÄƒ!</div>
                </div>
            </div>
        </div>

        <!-- Slide 19: Balance Factor -->
        <div class="slide">
            <h2>âš–ï¸ Factorul de Echilibru</h2>
            <div class="info-box">
                <p><strong>DefiniÈ›ie:</strong> Factor de echilibru = Ã®nÄƒlÈ›ime(stÃ¢nga) - Ã®nÄƒlÈ›ime(dreapta)</p>
            </div>
            <div class="diagram">
         50 [BF=0]            50 [BF=+2]  â† Dezechilibrat!
        /  \                 /
      30    70             30 [BF=+1]
     /  \   / \           /
   20   40 60  80       20 [BF=0]

   BF âˆˆ {-1, 0, +1}     BF âˆ‰ {-1, 0, +1}
   = ECHILIBRAT          = DEZECHILIBRAT
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>Calculul Ã®nÄƒlÈ›imii È™i verificarea echilibrului</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">int bst_height(BSTNode *node) {
    if (node == NULL) return -1;  /* Arbore vid are Ã®nÄƒlÈ›ime -1 */
    int left_h = bst_height(node->left);
    int right_h = bst_height(node->right);
    return 1 + (left_h > right_h ? left_h : right_h);
}

int bst_is_balanced(BSTNode *node) {
    if (node == NULL) return 1;
    int bf = bst_height(node->left) - bst_height(node->right);
    return (bf >= -1 && bf <= 1) && 
           bst_is_balanced(node->left) && 
           bst_is_balanced(node->right);
}</code></pre>
            </div>
        </div>

        <!-- Slide 20: BST Validation -->
        <div class="slide">
            <h2>âœ… Validare BST</h2>
            <p>Cum verificÄƒm dacÄƒ un arbore binar este BST valid?</p>
            <div class="two-columns">
                <div class="column">
                    <h3>Metoda 1: Limite min/max</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Verificare cu intervale</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">int is_bst_util(BSTNode *node, 
                int min, int max) {
    if (node == NULL) return 1;
    
    if (node->key <= min || 
        node->key >= max)
        return 0;
    
    return is_bst_util(node->left, 
                       min, node->key) &&
           is_bst_util(node->right, 
                       node->key, max);
}

int is_valid_bst(BSTNode *root) {
    return is_bst_util(root, 
                       INT_MIN, INT_MAX);
}</code></pre>
                    </div>
                </div>
                <div class="column">
                    <h3>Metoda 2: Parcurgere inorder</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Verificare cÄƒ inorder e sortat</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">int prev_key = INT_MIN;

int is_bst_inorder(BSTNode *node) {
    if (node == NULL) return 1;
    
    /* VerificÄƒ subarborele stÃ¢ng */
    if (!is_bst_inorder(node->left))
        return 0;
    
    /* VerificÄƒ nodul curent */
    if (node->key <= prev_key)
        return 0;
    prev_key = node->key;
    
    /* VerificÄƒ subarborele drept */
    return is_bst_inorder(node->right);
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 21: Common Mistakes -->
        <div class="slide">
            <h2>ğŸš¨ GreÈ™eli Frecvente</h2>
            <div class="card-grid">
                <div class="card">
                    <h4>âŒ Memory Leak la È™tergere</h4>
                    <div class="code-block" style="margin: 10px 0;">
                        <pre><code class="language-c">/* GREÈ˜IT */
node = node->right;  /* Leak! */

/* CORECT */
BSTNode *temp = node->right;
free(node);
return temp;</code></pre>
                    </div>
                </div>
                <div class="card">
                    <h4>âŒ Uitarea de NULL check</h4>
                    <div class="code-block" style="margin: 10px 0;">
                        <pre><code class="language-c">/* GREÈ˜IT */
if (node->key == key) ...

/* CORECT */
if (node == NULL) return NULL;
if (node->key == key) ...</code></pre>
                    </div>
                </div>
                <div class="card">
                    <h4>âŒ ComparaÈ›ie incorectÄƒ</h4>
                    <div class="code-block" style="margin: 10px 0;">
                        <pre><code class="language-c">/* GREÈ˜IT - permite duplicate */
if (key <= node->key)
    node->left = insert(...);

/* CORECT */
if (key < node->key)
    node->left = insert(...);</code></pre>
                    </div>
                </div>
                <div class="card">
                    <h4>âŒ Nealocarea nodului</h4>
                    <div class="code-block" style="margin: 10px 0;">
                        <pre><code class="language-c">/* GREÈ˜IT */
BSTNode node;  /* Stack! */

/* CORECT */
BSTNode *node = malloc(sizeof(BSTNode));
if (!node) { /* handle error */ }</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 22: Memory Management -->
        <div class="slide">
            <h2>ğŸ§¹ Gestiunea Memoriei</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Eliberarea corectÄƒ a Ã®ntregului arbore (postorder!)</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/* ElibereazÄƒ un subarbore - TREBUIE sÄƒ fie postorder! */
void bst_free_tree(BSTNode *node) {
    if (node == NULL) return;
    
    /* Mai Ã®ntÃ¢i eliberÄƒm copiii (postorder) */
    bst_free_tree(node->left);
    bst_free_tree(node->right);
    
    /* Apoi eliberÄƒm nodul curent */
    free(node->data);  /* DacÄƒ data a fost alocatÄƒ dinamic */
    free(node);
}

/* ElibereazÄƒ Ã®ntreaga structurÄƒ BST */
void bst_destroy(BST *tree) {
    if (tree == NULL) return;
    
    bst_free_tree(tree->root);
    tree->root = NULL;
    tree->size = 0;
}</code></pre>
            </div>
            <div class="warning-box">
                <strong>De ce postorder?</strong> Trebuie sÄƒ eliberÄƒm copiii ÃNAINTE de pÄƒrinte, 
                altfel pierdem pointerii cÄƒtre copii!
            </div>
        </div>

        <!-- Slide 23: Debugging with GDB -->
        <div class="slide">
            <h2>ğŸ”§ Debugging cu GDB</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Comenzi utile GDB pentru arbori</span>
                    <span class="lang-badge">bash</span>
                </div>
                <pre><code class="language-bash"># Compilare cu simboluri debug
$ gcc -g -Wall -o bst_test bst.c

# Pornire GDB
$ gdb ./bst_test

# Setare breakpoint la inserare
(gdb) break bst_insert

# Rulare
(gdb) run

# Inspectare nod curent
(gdb) print *node
(gdb) print node->key
(gdb) print node->left
(gdb) print node->right

# Parcurgere pas cu pas
(gdb) next    # UrmÄƒtoarea linie (nu intrÄƒ Ã®n funcÈ›ii)
(gdb) step    # UrmÄƒtoarea linie (intrÄƒ Ã®n funcÈ›ii)

# AfiÈ™are stack de apeluri recursive
(gdb) backtrace

# Watching pentru modificÄƒri
(gdb) watch node->left</code></pre>
            </div>
        </div>

        <!-- Slide 24: Valgrind Memory Check -->
        <div class="slide">
            <h2>ğŸ” Verificare cu Valgrind</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Detectarea memory leaks</span>
                    <span class="lang-badge">bash</span>
                </div>
                <pre><code class="language-bash"># Verificare completÄƒ pentru memory leaks
$ valgrind --leak-check=full ./bst_test

# Output pentru cod CORECT:
==12345== HEAP SUMMARY:
==12345==   in use at exit: 0 bytes in 0 blocks
==12345==   total heap usage: 10 allocs, 10 frees, 400 bytes allocated
==12345== All heap blocks were freed -- no leaks are possible

# Output pentru cod cu LEAK:
==12345== LEAK SUMMARY:
==12345==    definitely lost: 40 bytes in 1 blocks
==12345==    indirectly lost: 160 bytes in 4 blocks
==12345==      possibly lost: 0 bytes in 0 blocks

# Verificare accesÄƒri invalide
$ valgrind --track-origins=yes ./bst_test</code></pre>
            </div>
            <div class="error-box">
                <strong>AtenÈ›ie:</strong> "definitely lost" Ã®nseamnÄƒ cÄƒ nu aÈ›i eliberat memoria!<br>
                "indirectly lost" - noduri copil ale unui nod neeliberat.
            </div>
        </div>

        <!-- Slide 25: BST vs Other Data Structures -->
        <div class="slide">
            <h2>âš–ï¸ BST vs. Alte Structuri</h2>
            <table>
                <tr>
                    <th>OperaÈ›ie</th>
                    <th>Array Sortat</th>
                    <th>Linked List</th>
                    <th>BST (echilibrat)</th>
                    <th>Hash Table</th>
                </tr>
                <tr>
                    <td>Search</td>
                    <td class="highlight-green">O(log n)</td>
                    <td class="highlight-red">O(n)</td>
                    <td class="highlight-green">O(log n)</td>
                    <td class="highlight-green">O(1)*</td>
                </tr>
                <tr>
                    <td>Insert</td>
                    <td class="highlight-red">O(n)</td>
                    <td class="highlight-green">O(1)**</td>
                    <td class="highlight-green">O(log n)</td>
                    <td class="highlight-green">O(1)*</td>
                </tr>
                <tr>
                    <td>Delete</td>
                    <td class="highlight-red">O(n)</td>
                    <td class="highlight-green">O(1)**</td>
                    <td class="highlight-green">O(log n)</td>
                    <td class="highlight-green">O(1)*</td>
                </tr>
                <tr>
                    <td>Min/Max</td>
                    <td class="highlight-green">O(1)</td>
                    <td class="highlight-red">O(n)</td>
                    <td class="highlight-green">O(log n)</td>
                    <td class="highlight-red">O(n)</td>
                </tr>
                <tr>
                    <td>Range Query</td>
                    <td class="highlight-green">O(k + log n)</td>
                    <td class="highlight-red">O(n)</td>
                    <td class="highlight-green">O(k + log n)</td>
                    <td class="highlight-red">O(n)</td>
                </tr>
                <tr>
                    <td>Ordine sortatÄƒ</td>
                    <td>âœ“ Natural</td>
                    <td>âœ—</td>
                    <td>âœ“ Inorder</td>
                    <td>âœ—</td>
                </tr>
            </table>
            <p><em>* Caz mediu, ** Cu pointer la nod</em></p>
        </div>

        <!-- Slide 26: When to Use BST -->
        <div class="slide">
            <h2>ğŸ¯ CÃ¢nd sÄƒ Folosim BST?</h2>
            <div class="two-columns">
                <div class="column">
                    <h3 style="color: var(--accent-green);">âœ“ FolosiÈ›i BST cÃ¢nd:</h3>
                    <ul>
                        <li>AveÈ›i nevoie de date <span class="highlight">ordonate</span></li>
                        <li>Trebuie sÄƒ gÄƒsiÈ›i <span class="highlight">min/max</span> rapid</li>
                        <li>FaceÈ›i <span class="highlight">range queries</span> (toate valorile Ã®ntre A È™i B)</li>
                        <li>Datele se modificÄƒ frecvent (inserÄƒri/È™tergeri)</li>
                        <li>Cheile nu au o funcÈ›ie de hash bunÄƒ</li>
                        <li>Memoria este limitatÄƒ (nu alocaÈ›i Ã®n avans)</li>
                    </ul>
                </div>
                <div class="column">
                    <h3 style="color: var(--accent-red);">âœ— NU folosiÈ›i BST cÃ¢nd:</h3>
                    <ul>
                        <li>Nu vÄƒ intereseazÄƒ ordinea datelor</li>
                        <li>AveÈ›i nevoie doar de <span class="highlight">lookup rapid</span> â†’ Hash Table</li>
                        <li>Datele sunt statice â†’ Array sortat</li>
                        <li>InsertaÈ›i date deja sortate fÄƒrÄƒ echilibrare</li>
                        <li>Overhead-ul de memorie (2 pointeri/nod) este prea mare</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 27: Real-World Applications -->
        <div class="slide">
            <h2>ğŸŒ AplicaÈ›ii Practice</h2>
            <div class="card-grid">
                <div class="card">
                    <h4>ğŸ“š DicÈ›ionare</h4>
                    <p>CÄƒutare cuvinte, autocompletare, spell-checking</p>
                </div>
                <div class="card">
                    <h4>ğŸ—„ï¸ Baze de Date</h4>
                    <p>Indexuri B-Tree pentru query-uri rapide</p>
                </div>
                <div class="card">
                    <h4>ğŸ“ Sisteme de FiÈ™iere</h4>
                    <p>Organizarea directoarelor È™i fiÈ™ierelor</p>
                </div>
                <div class="card">
                    <h4>ğŸ® Game Dev</h4>
                    <p>Spatial partitioning, leaderboards sortate</p>
                </div>
                <div class="card">
                    <h4>ğŸ’¹ Trading</h4>
                    <p>Order books (cumpÄƒrÄƒtori/vÃ¢nzÄƒtori sortaÈ›i)</p>
                </div>
                <div class="card">
                    <h4>ğŸ”§ Compilatoare</h4>
                    <p>Symbol tables, scope management</p>
                </div>
            </div>
        </div>

        <!-- Slide 28: STL Map Example -->
        <div class="slide">
            <h2>ğŸ’¼ Exemplu Industrial: std::map (C++)</h2>
            <div class="info-box">
                <p>Standard Template Library din C++ implementeazÄƒ <code>std::map</code> folosind 
                <span class="highlight">Red-Black Trees</span> (BST auto-echilibrat).</p>
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>Utilizare std::map - intern foloseÈ™te BST</span>
                    <span class="lang-badge">C++</span>
                </div>
                <pre><code class="language-cpp">#include &lt;map&gt;
#include &lt;string&gt;

int main() {
    std::map&lt;std::string, int&gt; dictionary;
    
    // Inserare - O(log n)
    dictionary["apple"] = 1;
    dictionary["banana"] = 2;
    dictionary["cherry"] = 3;
    
    // CÄƒutare - O(log n)
    auto it = dictionary.find("banana");
    
    // Iterare Ã®n ordine SORTATÄ‚ (inorder traversal)
    for (const auto& [key, value] : dictionary) {
        std::cout << key << ": " << value << "\n";
    }
    // Output: apple: 1, banana: 2, cherry: 3
    
    // Range query - toate cheile Ã®ntre "b" È™i "c"
    auto low = dictionary.lower_bound("b");
    auto high = dictionary.upper_bound("c");
}</code></pre>
            </div>
        </div>

        <!-- Slide 29: Best Practices -->
        <div class="slide">
            <h2>ğŸ“‹ Bune Practici</h2>
            <div class="two-columns">
                <div class="column">
                    <h3 style="color: var(--accent-green);">âœ“ DO (FaceÈ›i)</h3>
                    <ul>
                        <li>VerificaÈ›i <code>NULL</code> Ã®nainte de orice acces</li>
                        <li>FolosiÈ›i funcÈ›ii de comparare generice pentru flexibilitate</li>
                        <li>EliberaÈ›i memoria cu parcurgere <strong>postorder</strong></li>
                        <li>TestaÈ›i cu Valgrind regulat</li>
                        <li>ConsideraÈ›i arbori echilibraÈ›i (AVL, RB) pentru date sortate</li>
                        <li>DocumentaÈ›i invariantele BST Ã®n cod</li>
                    </ul>
                </div>
                <div class="column">
                    <h3 style="color: var(--accent-red);">âœ— DON'T (Nu faceÈ›i)</h3>
                    <ul>
                        <li>Nu inseraÈ›i date deja sortate Ã®n BST simplu</li>
                        <li>Nu uitaÈ›i sÄƒ eliberaÈ›i memoria nodurilor</li>
                        <li>Nu folosiÈ›i BST cÃ¢nd nu aveÈ›i nevoie de ordine</li>
                        <li>Nu ignoraÈ›i cazurile de eroare la <code>malloc()</code></li>
                        <li>Nu presupuneÈ›i cÄƒ arborele este echilibrat</li>
                        <li>Nu modificaÈ›i cheile dupÄƒ inserare!</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 30: Preview - AVL Trees -->
        <div class="slide">
            <h2>ğŸ‘€ Preview: SÄƒptÄƒmÃ¢na 9 - Arbori AVL</h2>
            <p>SoluÈ›ia la problema dezechilibrului: <span class="highlight">auto-echilibrare!</span></p>
            <div class="diagram">
Inserare 10 Ã®n BST simplu:      vs      Inserare 10 Ã®n AVL:

     30                                      20
    /                                       /  \
  20          DegenereazÄƒ!               10    30
 /
10                                      RotaÈ›ie automatÄƒ!
            </div>
            <div class="info-box">
                <h3>Ce veÈ›i Ã®nvÄƒÈ›a:</h3>
                <ul>
                    <li>Factorul de echilibru È™i proprietatea AVL</li>
                    <li>RotaÈ›ii simple: Left-Left (LL), Right-Right (RR)</li>
                    <li>RotaÈ›ii duble: Left-Right (LR), Right-Left (RL)</li>
                    <li>MenÈ›inerea echilibrului la inserare È™i È™tergere</li>
                    <li>ComparaÈ›ie cu Red-Black Trees</li>
                </ul>
            </div>
        </div>

        <!-- Slide 31: Lab Preview -->
        <div class="slide">
            <h2>ğŸ”¬ Preview Laborator</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>ExerciÈ›iul 1: DicÈ›ionar</h3>
                    <p>ImplementaÈ›i un dicÈ›ionar romÃ¢n-englez:</p>
                    <ul>
                        <li>StructurÄƒ pentru intrare (cuvÃ¢nt RO, traducere EN)</li>
                        <li>Inserare cu ordine alfabeticÄƒ</li>
                        <li>CÄƒutare cu feedback</li>
                        <li>È˜tergere intrÄƒri</li>
                        <li>Salvare/Ã®ncÄƒrcare din fiÈ™ier</li>
                        <li>Statistici arbore</li>
                    </ul>
                </div>
                <div class="column">
                    <h3>ExerciÈ›iul 2: Arbore de Expresii</h3>
                    <p>ConstruiÈ›i È™i evaluaÈ›i expresii aritmetice:</p>
                    <ul>
                        <li>Parsare expresii infix</li>
                        <li>Construire arbore de expresie</li>
                        <li>Evaluare prin postorder</li>
                        <li>AfiÈ™are Ã®n 3 notaÈ›ii</li>
                        <li>Simplificare expresii</li>
                        <li>Derivare (bonus)</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 32: Key Takeaways -->
        <div class="slide">
            <h2>ğŸ“ Recapitulare</h2>
            <div class="card-grid">
                <div class="card">
                    <h4>1. Proprietatea BST</h4>
                    <p>StÃ¢nga < RÄƒdÄƒcinÄƒ < Dreapta, aplicatÄƒ recursiv</p>
                </div>
                <div class="card">
                    <h4>2. Complexitate</h4>
                    <p>O(log n) mediu, O(n) defavorabil - depinde de echilibru</p>
                </div>
                <div class="card">
                    <h4>3. È˜tergere Hibbard</h4>
                    <p>3 cazuri: frunzÄƒ, 1 copil, 2 copii (succesor inorder)</p>
                </div>
                <div class="card">
                    <h4>4. Parcurgere Inorder</h4>
                    <p>Produce elementele Ã®n ordine SORTATÄ‚</p>
                </div>
                <div class="card">
                    <h4>5. CÃ¢nd sÄƒ folosim</h4>
                    <p>Date ordonate, range queries, min/max rapid</p>
                </div>
                <div class="card">
                    <h4>6. Memory Management</h4>
                    <p>Eliberare cu postorder, verificare cu Valgrind</p>
                </div>
            </div>
        </div>

        <!-- Slide 33: Resources -->
        <div class="slide">
            <h2>ğŸ“– Resurse Recomandate</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>CÄƒrÈ›i</h3>
                    <ul>
                        <li><strong>CLRS</strong> - Introduction to Algorithms, Cap. 12</li>
                        <li><strong>Sedgewick</strong> - Algorithms, 4th Ed., SecÈ›iunea 3.2</li>
                        <li><strong>Knuth</strong> - TAOCP Vol. 3, SecÈ›iunea 6.2.2</li>
                    </ul>
                    <h3>Papers</h3>
                    <ul>
                        <li>Hibbard (1962) - Algoritmul de È™tergere</li>
                        <li>Adelson-Velsky & Landis (1962) - AVL Trees</li>
                    </ul>
                </div>
                <div class="column">
                    <h3>Online</h3>
                    <ul>
                        <li><a href="https://visualgo.net/en/bst" style="color: var(--accent-blue);">Visualgo BST</a> - AnimaÈ›ii interactive</li>
                        <li><a href="https://www.cs.usfca.edu/~galles/visualization/BST.html" style="color: var(--accent-blue);">USFCA BST Visualization</a></li>
                        <li><a href="https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-spring-2020/" style="color: var(--accent-blue);">MIT 6.006</a> - LecÈ›ii video</li>
                    </ul>
                    <h3>Practice</h3>
                    <ul>
                        <li>LeetCode: #98, #235, #450, #700</li>
                        <li>HackerRank: Binary Search Trees section</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 34: Questions -->
        <div class="slide title-slide">
            <h1>ÃntrebÄƒri?</h1>
            <p class="subtitle">ğŸ¤” ClarificÄƒri È™i DiscuÈ›ii</p>
            <div style="margin-top: 60px;">
                <p class="meta">
                    <strong>SÄƒptÄƒmÃ¢na urmÄƒtoare:</strong> Arbori AVL È™i Auto-Echilibrare<br><br>
                    <em>PregÄƒtiÈ›i-vÄƒ revizuind inserarea È™i gÃ¢ndindu-vÄƒ<br>
                    cum s-ar putea "corecta" un arbore dezechilibrat.</em>
                </p>
            </div>
        </div>
    </div>

    <!-- Navigation Controls -->
    <div id="nav-controls">
        <button class="nav-btn" onclick="firstSlide()" title="Prima (Home)">â®</button>
        <button class="nav-btn" onclick="prevSlide()" title="Ãnapoi (â†)">â—€</button>
        <button class="nav-btn" onclick="nextSlide()" title="Ãnainte (â†’)">â–¶</button>
        <button class="nav-btn" onclick="lastSlide()" title="Ultima (End)">â­</button>
    </div>

    <!-- Slide Counter -->
    <div id="slide-counter">
        <span id="current-slide">1</span> / <span id="total-slides">34</span>
    </div>

    <script>
        // Initialize highlight.js
        hljs.highlightAll();

        // Slide management
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        const totalSlides = slides.length;

        document.getElementById('total-slides').textContent = totalSlides;

        function showSlide(n) {
            // Bounds checking
            if (n < 0) n = 0;
            if (n >= totalSlides) n = totalSlides - 1;
            
            // Hide all slides
            slides.forEach(slide => slide.classList.remove('active'));
            
            // Show current slide
            slides[n].classList.add('active');
            currentSlide = n;
            
            // Update counter
            document.getElementById('current-slide').textContent = n + 1;
            
            // Update progress bar
            const progress = ((n + 1) / totalSlides) * 100;
            document.getElementById('progress-bar').style.width = progress + '%';
        }

        function nextSlide() {
            showSlide(currentSlide + 1);
        }

        function prevSlide() {
            showSlide(currentSlide - 1);
        }

        function firstSlide() {
            showSlide(0);
        }

        function lastSlide() {
            showSlide(totalSlides - 1);
        }

        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            switch(e.key) {
                case 'ArrowRight':
                case ' ':
                case 'PageDown':
                    e.preventDefault();
                    nextSlide();
                    break;
                case 'ArrowLeft':
                case 'PageUp':
                    e.preventDefault();
                    prevSlide();
                    break;
                case 'Home':
                    e.preventDefault();
                    firstSlide();
                    break;
                case 'End':
                    e.preventDefault();
                    lastSlide();
                    break;
            }
        });

        // Touch support for mobile
        let touchStartX = 0;
        let touchEndX = 0;

        document.addEventListener('touchstart', e => {
            touchStartX = e.changedTouches[0].screenX;
        });

        document.addEventListener('touchend', e => {
            touchEndX = e.changedTouches[0].screenX;
            handleSwipe();
        });

        function handleSwipe() {
            const swipeThreshold = 50;
            const diff = touchStartX - touchEndX;
            
            if (Math.abs(diff) > swipeThreshold) {
                if (diff > 0) {
                    nextSlide();
                } else {
                    prevSlide();
                }
            }
        }

        // Initialize first slide
        showSlide(0);
    </script>
</body>
</html>
