<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SÄƒptÄƒmÃ¢na 14: Recapitulare AvansatÄƒ È™i Optimizare | ATP</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-yellow: #d29922;
            --accent-red: #f85149;
            --accent-purple: #a371f7;
            --border-color: #30363d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        /* Progress Bar */
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            transition: width 0.3s ease;
            z-index: 1000;
        }

        /* Slide Container */
        .slides-container {
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 60px 80px;
            display: none;
            opacity: 0;
            transition: opacity 0.5s ease;
            overflow-y: auto;
        }

        .slide.active {
            display: block;
            opacity: 1;
        }

        /* Typography */
        h1 {
            font-size: 2.8em;
            margin-bottom: 30px;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        h2 {
            font-size: 2.2em;
            margin-bottom: 25px;
            color: var(--accent-blue);
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 10px;
        }

        h3 {
            font-size: 1.6em;
            margin: 20px 0 15px;
            color: var(--accent-green);
        }

        h4 {
            font-size: 1.3em;
            margin: 15px 0 10px;
            color: var(--accent-yellow);
        }

        p {
            font-size: 1.2em;
            line-height: 1.8;
            margin-bottom: 15px;
            color: var(--text-secondary);
        }

        ul, ol {
            margin: 15px 0 15px 30px;
            font-size: 1.15em;
        }

        li {
            margin: 12px 0;
            line-height: 1.6;
        }

        /* Code Blocks */
        .code-block {
            background: var(--bg-secondary);
            border-radius: 8px;
            margin: 20px 0;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }

        .code-header {
            background: var(--bg-tertiary);
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
        }

        .code-header span {
            color: var(--text-secondary);
            font-size: 0.9em;
        }

        .lang-badge {
            background: var(--accent-blue);
            color: var(--bg-primary);
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 600;
        }

        pre {
            margin: 0;
            padding: 20px;
            overflow-x: auto;
        }

        code {
            font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 0.95em;
        }

        /* Special Boxes */
        .info-box {
            background: var(--bg-secondary);
            border-left: 4px solid var(--accent-blue);
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .warning-box {
            background: rgba(210, 153, 34, 0.1);
            border-left: 4px solid var(--accent-yellow);
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .error-box {
            background: rgba(248, 81, 73, 0.1);
            border-left: 4px solid var(--accent-red);
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .success-box {
            background: rgba(63, 185, 80, 0.1);
            border-left: 4px solid var(--accent-green);
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 1em;
        }

        th, td {
            border: 1px solid var(--border-color);
            padding: 12px 15px;
            text-align: left;
        }

        th {
            background: var(--bg-tertiary);
            color: var(--accent-blue);
            font-weight: 600;
        }

        tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        tr:hover {
            background: var(--bg-tertiary);
        }

        /* Two Column Layout */
        .two-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 20px 0;
        }

        .column {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        /* Three Column Layout */
        .three-columns {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        /* Cards */
        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin: 10px 0;
        }

        .card-title {
            color: var(--accent-blue);
            font-size: 1.2em;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Grid Layout */
        .grid-2x2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .grid-3x2 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        /* Navigation */
        .nav-controls {
            position: fixed;
            bottom: 20px;
            right: 30px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .nav-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.2s ease;
        }

        .nav-btn:hover {
            background: var(--accent-blue);
            color: var(--bg-primary);
        }

        /* Slide Counter */
        .slide-counter {
            position: fixed;
            bottom: 25px;
            left: 30px;
            color: var(--text-secondary);
            font-size: 1em;
            z-index: 100;
        }

        /* Title Slide */
        .title-slide {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            height: 100%;
        }

        .title-slide h1 {
            font-size: 3.5em;
            margin-bottom: 20px;
        }

        .title-slide .subtitle {
            font-size: 1.8em;
            color: var(--text-secondary);
            margin-bottom: 30px;
        }

        .title-slide .meta {
            font-size: 1.2em;
            color: var(--accent-purple);
        }

        /* Diagram Styles */
        .diagram {
            background: var(--bg-secondary);
            padding: 30px;
            border-radius: 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9em;
            white-space: pre;
            overflow-x: auto;
            line-height: 1.4;
            border: 1px solid var(--border-color);
        }

        /* Quote Box */
        .quote-box {
            background: linear-gradient(135deg, var(--bg-secondary), var(--bg-tertiary));
            border: 1px solid var(--accent-purple);
            border-radius: 8px;
            padding: 30px;
            margin: 20px 0;
            font-style: italic;
            font-size: 1.3em;
            text-align: center;
            color: var(--text-primary);
        }

        .quote-author {
            margin-top: 15px;
            font-style: normal;
            font-size: 0.8em;
            color: var(--accent-purple);
        }

        /* Highlight */
        .highlight {
            color: var(--accent-yellow);
            font-weight: 600;
        }

        .highlight-blue {
            color: var(--accent-blue);
            font-weight: 600;
        }

        .highlight-green {
            color: var(--accent-green);
            font-weight: 600;
        }

        .highlight-red {
            color: var(--accent-red);
            font-weight: 600;
        }

        /* Complexity Badge */
        .complexity {
            display: inline-block;
            background: var(--bg-tertiary);
            padding: 5px 12px;
            border-radius: 15px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9em;
            margin: 2px;
        }

        .complexity.good {
            background: rgba(63, 185, 80, 0.2);
            color: var(--accent-green);
        }

        .complexity.medium {
            background: rgba(210, 153, 34, 0.2);
            color: var(--accent-yellow);
        }

        .complexity.bad {
            background: rgba(248, 81, 73, 0.2);
            color: var(--accent-red);
        }

        /* Icon Styles */
        .icon {
            font-size: 1.5em;
            margin-right: 10px;
        }

        /* End Slide */
        .end-slide {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            height: 100%;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .slide {
                padding: 40px 50px;
            }
            h1 { font-size: 2.2em; }
            h2 { font-size: 1.8em; }
            .two-columns, .three-columns {
                grid-template-columns: 1fr;
            }
        }

        /* Timeline */
        .timeline {
            position: relative;
            padding-left: 30px;
            border-left: 3px solid var(--accent-blue);
            margin: 20px 0;
        }

        .timeline-item {
            position: relative;
            margin-bottom: 25px;
            padding-left: 20px;
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: -36px;
            top: 5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent-blue);
        }

        .timeline-date {
            color: var(--accent-purple);
            font-weight: 600;
            font-size: 1.1em;
        }

        /* Keyboard hint */
        .keyboard-hint {
            position: fixed;
            bottom: 70px;
            right: 30px;
            color: var(--text-secondary);
            font-size: 0.85em;
            z-index: 100;
        }

        kbd {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 3px 8px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="progress-bar" id="progress"></div>
    
    <div class="slides-container" id="slides">
        <!-- Slide 1: Title -->
        <div class="slide active">
            <div class="title-slide">
                <h1>ğŸ“ SÄƒptÄƒmÃ¢na 14</h1>
                <div class="subtitle">Recapitulare AvansatÄƒ È™i Optimizare</div>
                <div class="meta">Algoritmi È™i Tehnici de Programare</div>
                <div class="meta" style="margin-top: 20px; color: var(--text-secondary);">
                    Academia de Studii Economice BucureÈ™ti<br>
                    Facultatea CSIE
                </div>
            </div>
        </div>

        <!-- Slide 2: Learning Objectives -->
        <div class="slide">
            <h2>ğŸ¯ Obiective de ÃnvÄƒÈ›are</h2>
            <div class="grid-2x2">
                <div class="card">
                    <div class="card-title">ğŸ“– SÄƒ recunoascÄƒ (Remember)</div>
                    <p>Identificarea structurii de date potrivite È™i enumerarea complexitÄƒÈ›ilor temporale</p>
                </div>
                <div class="card">
                    <div class="card-title">ğŸ’¡ SÄƒ Ã®nÈ›eleagÄƒ (Understand)</div>
                    <p>Explicarea relaÈ›iilor È™i compromisurilor Ã®ntre diferite structuri de date</p>
                </div>
                <div class="card">
                    <div class="card-title">âš™ï¸ SÄƒ aplice (Apply)</div>
                    <p>Implementarea soluÈ›iilor hibride cu multiple structuri de date</p>
                </div>
                <div class="card">
                    <div class="card-title">ğŸ” SÄƒ analizeze (Analyse)</div>
                    <p>Evaluarea performanÈ›ei prin profiling È™i identificarea bottleneck-urilor</p>
                </div>
                <div class="card">
                    <div class="card-title">âš–ï¸ SÄƒ evalueze (Evaluate)</div>
                    <p>Compararea abordÄƒrilor È™i justificarea alegerii optime</p>
                </div>
                <div class="card">
                    <div class="card-title">ğŸš€ SÄƒ creeze (Create)</div>
                    <p>Proiectarea sistemelor software complete care integreazÄƒ toate conceptele</p>
                </div>
            </div>
        </div>

        <!-- Slide 3: Historical Context -->
        <div class="slide">
            <h2>ğŸ“œ Context Istoric</h2>
            <div class="timeline">
                <div class="timeline-item">
                    <div class="timeline-date">1957-1958</div>
                    <p><span class="highlight-blue">FORTRAN</span> introduce array-urile; <span class="highlight-green">LISP</span> popularizeazÄƒ listele Ã®nlÄƒnÈ›uite</p>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">1959-1962</div>
                    <p><span class="highlight">Dijkstra</span> publicÄƒ algoritmul drumurilor minime; <span class="highlight">AVL trees</span> sunt inventate</p>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">1960</div>
                    <p><span class="highlight-blue">C.A.R. Hoare</span> inventeazÄƒ Quicksort - unul dintre cei mai folosiÈ›i algoritmi</p>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">1968</div>
                    <p><span class="highlight-green">Donald Knuth</span> publicÄƒ primul volum din "The Art of Computer Programming"</p>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">1972</div>
                    <p><span class="highlight">Rudolf Bayer</span> creeazÄƒ B-trees - fundamentul bazelor de date moderne</p>
                </div>
            </div>
        </div>

        <!-- Slide 4: Key Figure - Donald Knuth -->
        <div class="slide">
            <h2>ğŸ‘¤ Figura Cheie: Donald Ervin Knuth</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Biografie</h3>
                    <ul>
                        <li><strong>NÄƒscut:</strong> 10 ianuarie 1938, Milwaukee, USA</li>
                        <li><strong>EducaÈ›ie:</strong> PhD Stanford University, 1963</li>
                        <li><strong>PoziÈ›ie:</strong> Profesor Emerit, Stanford</li>
                        <li><strong>Premiu Turing:</strong> 1974</li>
                    </ul>
                    <h3>ContribuÈ›ii Majore</h3>
                    <ul>
                        <li>"The Art of Computer Programming" (1968-prezent)</li>
                        <li>Sistemul TeX pentru tehnoredactare</li>
                        <li>Analiza riguoasÄƒ a algoritmilor</li>
                        <li>Literate programming</li>
                    </ul>
                </div>
                <div class="column">
                    <div class="quote-box">
                        "Premature optimization is the root of all evil."
                        <div class="quote-author">â€” Donald Knuth, 1974</div>
                    </div>
                    <div class="info-box" style="margin-top: 20px;">
                        <strong>Fun fact:</strong> Knuth oferÄƒ cecuri de $2.56 (un â€dolar hexadecimal") pentru fiecare eroare gÄƒsitÄƒ Ã®n cÄƒrÈ›ile sale.
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 5: Data Structures Taxonomy -->
        <div class="slide">
            <h2>ğŸ“Š Taxonomia Structurilor de Date</h2>
            <div class="diagram">
                              STRUCTURI DE DATE
                                    â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                       â”‚                       â”‚
        LINIARE                IERARHICE              NON-LINIARE
            â”‚                       â”‚                       â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”
    â”‚       â”‚       â”‚       â”‚       â”‚       â”‚       â”‚       â”‚       â”‚
  Array   List   Stack    Tree    Heap    Trie    Hash   Graph    Set
              Queue                              Table
            </div>
            <div class="three-columns" style="margin-top: 20px;">
                <div class="card">
                    <div class="card-title" style="color: var(--accent-blue);">Liniare</div>
                    <p>Elemente Ã®ntr-o secvenÈ›Äƒ. Fiecare element are cel mult un succesor.</p>
                </div>
                <div class="card">
                    <div class="card-title" style="color: var(--accent-green);">Ierarhice</div>
                    <p>RelaÈ›ii pÄƒrinte-copil. Un element poate avea mai mulÈ›i succesori.</p>
                </div>
                <div class="card">
                    <div class="card-title" style="color: var(--accent-purple);">Non-liniare</div>
                    <p>RelaÈ›ii complexe. Orice element poate fi conectat cu oricÃ¢te altele.</p>
                </div>
            </div>
        </div>

        <!-- Slide 6: Complexity Overview -->
        <div class="slide">
            <h2>â±ï¸ ComplexitÄƒÈ›i Temporale - Sumar</h2>
            <table>
                <thead>
                    <tr>
                        <th>StructurÄƒ</th>
                        <th>Acces</th>
                        <th>CÄƒutare</th>
                        <th>Inserare</th>
                        <th>È˜tergere</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Array</strong></td>
                        <td><span class="complexity good">O(1)</span></td>
                        <td><span class="complexity bad">O(n)</span></td>
                        <td><span class="complexity bad">O(n)</span></td>
                        <td><span class="complexity bad">O(n)</span></td>
                    </tr>
                    <tr>
                        <td><strong>Linked List</strong></td>
                        <td><span class="complexity bad">O(n)</span></td>
                        <td><span class="complexity bad">O(n)</span></td>
                        <td><span class="complexity good">O(1)</span></td>
                        <td><span class="complexity good">O(1)</span></td>
                    </tr>
                    <tr>
                        <td><strong>BST (mediu)</strong></td>
                        <td><span class="complexity medium">O(log n)</span></td>
                        <td><span class="complexity medium">O(log n)</span></td>
                        <td><span class="complexity medium">O(log n)</span></td>
                        <td><span class="complexity medium">O(log n)</span></td>
                    </tr>
                    <tr>
                        <td><strong>Hash Table</strong></td>
                        <td>N/A</td>
                        <td><span class="complexity good">O(1)*</span></td>
                        <td><span class="complexity good">O(1)*</span></td>
                        <td><span class="complexity good">O(1)*</span></td>
                    </tr>
                    <tr>
                        <td><strong>Heap</strong></td>
                        <td><span class="complexity good">O(1)**</span></td>
                        <td><span class="complexity bad">O(n)</span></td>
                        <td><span class="complexity medium">O(log n)</span></td>
                        <td><span class="complexity medium">O(log n)</span></td>
                    </tr>
                </tbody>
            </table>
            <p style="font-size: 0.9em; margin-top: 10px;">
                <em>* Caz mediu; worst case O(n)</em> &nbsp;&nbsp;
                <em>** Doar pentru min/max</em>
            </p>
        </div>

        <!-- Slide 7: Arrays Review -->
        <div class="slide">
            <h2>ğŸ“¦ Recapitulare: Arrays</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Caracteristici</h3>
                    <ul>
                        <li>Memorie contiguÄƒ</li>
                        <li>Acces direct prin index <span class="complexity good">O(1)</span></li>
                        <li>Cache-friendly</li>
                        <li>Dimensiune fixÄƒ (static) sau dinamicÄƒ</li>
                    </ul>
                    <h3>CÃ¢nd sÄƒ foloseÈ™ti</h3>
                    <ul>
                        <li>âœ… Acces aleator frecvent</li>
                        <li>âœ… Dimensiune cunoscutÄƒ</li>
                        <li>âŒ InserÄƒri/È™tergeri frecvente</li>
                    </ul>
                </div>
                <div class="column">
                    <div class="code-block">
                        <div class="code-header">
                            <span>Declarare È™i acces</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">// Array static
int arr[100];
arr[0] = 42;  // O(1)

// Array dinamic
int *darr = malloc(n * sizeof(int));
darr[i] = value;  // O(1)

// CÄƒutare liniarÄƒ
for (int i = 0; i < n; i++)  // O(n)
    if (arr[i] == target) return i;

free(darr);</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 8: Linked Lists Review -->
        <div class="slide">
            <h2>ğŸ”— Recapitulare: Linked Lists</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Tipuri</h3>
                    <div class="diagram" style="font-size: 0.85em;">
Singly:  [A]â”€â–º[B]â”€â–º[C]â”€â–ºNULL

Doubly:  NULLâ—„â”€[A]â—„â”€â–º[B]â—„â”€â–º[C]â”€â–ºNULL

Circular:    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â–¼          â”‚
           [A]â”€â–º[B]â”€â–º[C]â”˜
                    </div>
                    <h3>Avantaje</h3>
                    <ul>
                        <li>Inserare/È™tergere <span class="complexity good">O(1)</span> cu pointer</li>
                        <li>Dimensiune dinamicÄƒ</li>
                        <li>Nu necesitÄƒ realocare</li>
                    </ul>
                </div>
                <div class="column">
                    <div class="code-block">
                        <div class="code-header">
                            <span>Structura nodului</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">typedef struct Node {
    int data;
    struct Node *next;
} Node;

// Inserare la Ã®nceput O(1)
Node *insert_front(Node *head, int val) {
    Node *new = malloc(sizeof(Node));
    new->data = val;
    new->next = head;
    return new;
}

// CÄƒutare O(n)
Node *find(Node *head, int val) {
    while (head && head->data != val)
        head = head->next;
    return head;
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 9: Stacks Review -->
        <div class="slide">
            <h2>ğŸ“š Recapitulare: Stacks (LIFO)</h2>
            <div class="two-columns">
                <div class="column">
                    <div class="diagram">
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚    TOP      â”‚ â—„â”€â”€ push/pop
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚   element   â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚   element   â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚   BOTTOM    â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    </div>
                    <h3>OperaÈ›ii</h3>
                    <ul>
                        <li><code>push()</code> - adaugÄƒ element <span class="complexity good">O(1)</span></li>
                        <li><code>pop()</code> - eliminÄƒ È™i returneazÄƒ <span class="complexity good">O(1)</span></li>
                        <li><code>peek()</code> - vizualizeazÄƒ vÃ¢rful <span class="complexity good">O(1)</span></li>
                    </ul>
                </div>
                <div class="column">
                    <h3>AplicaÈ›ii</h3>
                    <ul>
                        <li>Evaluarea expresiilor (postfix/prefix)</li>
                        <li>Verificarea parantezelor</li>
                        <li>Undo/Redo Ã®n editoare</li>
                        <li>Call stack Ã®n execuÈ›ia programelor</li>
                        <li>DFS pe grafuri</li>
                    </ul>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Implementare cu array</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">typedef struct {
    int data[MAX];
    int top;
} Stack;

void push(Stack *s, int val) {
    s->data[++s->top] = val;
}

int pop(Stack *s) {
    return s->data[s->top--];
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 10: Queues Review -->
        <div class="slide">
            <h2>ğŸš¶ Recapitulare: Queues (FIFO)</h2>
            <div class="two-columns">
                <div class="column">
                    <div class="diagram">
  enqueue â”€â”€â–ºâ”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”â”€â”€â–º dequeue
             â”‚ D  â”‚ C  â”‚ B  â”‚ A  â”‚
             â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
             REAR              FRONT
                    </div>
                    <h3>Variante</h3>
                    <ul>
                        <li><strong>Circular Queue</strong> - foloseÈ™te array circular</li>
                        <li><strong>Deque</strong> - double-ended queue</li>
                        <li><strong>Priority Queue</strong> - bazat pe heap</li>
                    </ul>
                </div>
                <div class="column">
                    <h3>AplicaÈ›ii</h3>
                    <ul>
                        <li>BFS pe grafuri</li>
                        <li>Scheduling procese (OS)</li>
                        <li>Buffer pentru I/O</li>
                        <li>Message queues</li>
                    </ul>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Circular Queue</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">typedef struct {
    int data[MAX];
    int front, rear, size;
} Queue;

void enqueue(Queue *q, int val) {
    q->rear = (q->rear + 1) % MAX;
    q->data[q->rear] = val;
    q->size++;
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 11: Binary Trees Review -->
        <div class="slide">
            <h2>ğŸŒ³ Recapitulare: Binary Trees</h2>
            <div class="two-columns">
                <div class="column">
                    <div class="diagram">
            â”Œâ”€â”€â”€â”€â”€â”
            â”‚  8  â”‚ â—„â”€â”€ rÄƒdÄƒcinÄƒ
            â””â”€â”€â”¬â”€â”€â”˜
         â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
      â”Œâ”€â”€â”´â”€â”€â”     â”Œâ”€â”€â”´â”€â”€â”
      â”‚  3  â”‚     â”‚ 10  â”‚
      â””â”€â”€â”¬â”€â”€â”˜     â””â”€â”€â”¬â”€â”€â”˜
      â”Œâ”€â”€â”´â”€â”€â”        â””â”€â”€â”
   â”Œâ”€â”€â”´â”€â” â”Œâ”€â”´â”€â”€â”    â”Œâ”€â”€â”´â”€â”€â”
   â”‚ 1  â”‚ â”‚ 6  â”‚    â”‚ 14  â”‚
   â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜
                    </div>
                    <h3>Terminologie</h3>
                    <ul>
                        <li><strong>RÄƒdÄƒcinÄƒ</strong> - nodul fÄƒrÄƒ pÄƒrinte</li>
                        <li><strong>FrunzÄƒ</strong> - nod fÄƒrÄƒ copii</li>
                        <li><strong>ÃnÄƒlÈ›ime</strong> - distanÈ›a max la frunzÄƒ</li>
                    </ul>
                </div>
                <div class="column">
                    <h3>TraversÄƒri</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Preorder, Inorder, Postorder</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">// Preorder: RÄƒdÄƒcinÄƒ - StÃ¢nga - Dreapta
void preorder(Node *n) {
    if (!n) return;
    printf("%d ", n->data);
    preorder(n->left);
    preorder(n->right);
}

// Inorder: StÃ¢nga - RÄƒdÄƒcinÄƒ - Dreapta
// (dÄƒ elementele sortate Ã®n BST)

// Postorder: StÃ¢nga - Dreapta - RÄƒdÄƒcinÄƒ
// (util pentru È™tergere arbore)</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 12: BST Review -->
        <div class="slide">
            <h2>ğŸ” Recapitulare: Binary Search Trees</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Proprietatea BST</h3>
                    <div class="info-box">
                        Pentru orice nod N:<br>
                        â€¢ Toate valorile din subarborele stÃ¢ng &lt; N<br>
                        â€¢ Toate valorile din subarborele drept &gt; N
                    </div>
                    <h3>ComplexitÄƒÈ›i</h3>
                    <table style="font-size: 0.9em;">
                        <tr>
                            <th>OperaÈ›ie</th>
                            <th>Mediu</th>
                            <th>Worst</th>
                        </tr>
                        <tr>
                            <td>Search</td>
                            <td><span class="complexity good">O(log n)</span></td>
                            <td><span class="complexity bad">O(n)</span></td>
                        </tr>
                        <tr>
                            <td>Insert</td>
                            <td><span class="complexity good">O(log n)</span></td>
                            <td><span class="complexity bad">O(n)</span></td>
                        </tr>
                        <tr>
                            <td>Delete</td>
                            <td><span class="complexity good">O(log n)</span></td>
                            <td><span class="complexity bad">O(n)</span></td>
                        </tr>
                    </table>
                </div>
                <div class="column">
                    <div class="code-block">
                        <div class="code-header">
                            <span>CÄƒutare Ã®n BST</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">Node *search(Node *root, int key) {
    // Caz de bazÄƒ
    if (!root || root->data == key)
        return root;
    
    // Cheia e mai micÄƒ - cautÄƒ stÃ¢nga
    if (key < root->data)
        return search(root->left, key);
    
    // Cheia e mai mare - cautÄƒ dreapta
    return search(root->right, key);
}</code></pre>
                    </div>
                    <div class="warning-box">
                        <strong>âš ï¸ Dezechilibru:</strong> Inserarea elementelor sortate degenereazÄƒ BST Ã®ntr-o listÄƒ (h = n-1)
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 13: AVL Trees Review -->
        <div class="slide">
            <h2>âš–ï¸ Recapitulare: AVL Trees</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Factor de Echilibru</h3>
                    <div class="info-box">
                        <code>BF(node) = height(left) - height(right)</code><br><br>
                        Arbore AVL valid: <strong>BF âˆˆ {-1, 0, 1}</strong> pentru toate nodurile
                    </div>
                    <h3>RotaÈ›ii</h3>
                    <div class="diagram" style="font-size: 0.8em;">
  RotaÈ›ie DreaptÄƒ (LL):     RotaÈ›ie StÃ¢nga (RR):
       y                         x
      / \                       / \
     x   C   â”€â”€â–º   A           A   y
    / \           / \             / \
   A   B         x   B           B   C
                / \
               A   B
                    </div>
                </div>
                <div class="column">
                    <div class="code-block">
                        <div class="code-header">
                            <span>RotaÈ›ie dreapta</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">Node *rotate_right(Node *y) {
    Node *x = y->left;
    Node *T2 = x->right;
    
    // RotaÈ›ie
    x->right = y;
    y->left = T2;
    
    // Actualizare Ã®nÄƒlÈ›imi
    y->height = max(height(y->left), 
                    height(y->right)) + 1;
    x->height = max(height(x->left), 
                    height(x->right)) + 1;
    
    return x;  // Noua rÄƒdÄƒcinÄƒ
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 14: Heaps Review -->
        <div class="slide">
            <h2>ğŸ”ï¸ Recapitulare: Heaps</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>ProprietÄƒÈ›i</h3>
                    <div class="info-box">
                        <strong>Max-Heap:</strong> PÄƒrintele â‰¥ Copiii<br>
                        <strong>Min-Heap:</strong> PÄƒrintele â‰¤ Copiii<br><br>
                        Arbore binar complet (toate nivelurile pline, ultimul umplut de la stÃ¢nga)
                    </div>
                    <h3>Reprezentare Ã®n Array</h3>
                    <div class="diagram" style="font-size: 0.85em;">
Index:    0    1    2    3    4    5    6
Array: [ 90 | 80 | 70 | 40 | 30 | 50 | 20 ]

PÄƒrinte(i) = (i-1)/2
StÃ¢nga(i)  = 2*i + 1
Dreapta(i) = 2*i + 2
                    </div>
                </div>
                <div class="column">
                    <div class="code-block">
                        <div class="code-header">
                            <span>Heapify (restaurare heap)</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">void heapify(int arr[], int n, int i) {
    int largest = i;
    int left = 2*i + 1;
    int right = 2*i + 2;
    
    if (left < n && arr[left] > arr[largest])
        largest = left;
    if (right < n && arr[right] > arr[largest])
        largest = right;
    
    if (largest != i) {
        swap(&arr[i], &arr[largest]);
        heapify(arr, n, largest);
    }
}</code></pre>
                    </div>
                    <h3>AplicaÈ›ii</h3>
                    <ul>
                        <li>Priority Queue</li>
                        <li>Heap Sort <span class="complexity medium">O(n log n)</span></li>
                        <li>K-th largest element</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 15: Hash Tables Review -->
        <div class="slide">
            <h2>#ï¸âƒ£ Recapitulare: Hash Tables</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Principiu</h3>
                    <div class="diagram" style="font-size: 0.85em;">
Key â”€â”€â–º hash(key) â”€â”€â–º index â”€â”€â–º bucket

Exemplu: hash("apple") % 10 = 7

  Index    Bucket
  â”Œâ”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 0 â”‚â”€â”€â”€â–ºâ”‚   NULL   â”‚
  â”œâ”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ 1 â”‚â”€â”€â”€â–ºâ”‚ "banana" â”‚
  â”œâ”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚...â”‚    â”‚   ...    â”‚
  â”œâ”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ 7 â”‚â”€â”€â”€â–ºâ”‚ "apple"  â”‚â”€â”€â”€â–ºâ”‚"apricot"â”‚
  â””â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             (chaining)
                    </div>
                </div>
                <div class="column">
                    <h3>Rezolvarea Coliziunilor</h3>
                    <div class="card">
                        <div class="card-title" style="color: var(--accent-green);">1. Chaining</div>
                        <p>Liste Ã®nlÄƒnÈ›uite la fiecare bucket</p>
                    </div>
                    <div class="card">
                        <div class="card-title" style="color: var(--accent-blue);">2. Open Addressing</div>
                        <p>Linear probing, Quadratic probing, Double hashing</p>
                    </div>
                    <h3>Load Factor</h3>
                    <div class="info-box">
                        <code>Î» = n / m</code><br>
                        n = elemente, m = buckets<br>
                        Recomandare: Î» â‰¤ 0.7 pentru performanÈ›Äƒ optimÄƒ
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 16: Graphs Review -->
        <div class="slide">
            <h2>ğŸ•¸ï¸ Recapitulare: Grafuri</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>ReprezentÄƒri</h3>
                    <div class="diagram" style="font-size: 0.8em;">
Graf:      0â”€â”€â”€1          Matrice AdiacenÈ›Äƒ:
           â”‚ â•² â”‚            0  1  2  3
           â”‚  â•²â”‚          0 [0, 1, 1, 0]
           2â”€â”€â”€3          1 [1, 0, 1, 1]
                          2 [1, 1, 0, 1]
                          3 [0, 1, 1, 0]

                          Liste AdiacenÈ›Äƒ:
                          0: [1, 2]
                          1: [0, 2, 3]
                          2: [0, 1, 3]
                          3: [1, 2]
                    </div>
                    <table style="font-size: 0.85em; margin-top: 15px;">
                        <tr>
                            <th></th>
                            <th>Matrice</th>
                            <th>Liste</th>
                        </tr>
                        <tr>
                            <td>SpaÈ›iu</td>
                            <td>O(VÂ²)</td>
                            <td>O(V+E)</td>
                        </tr>
                        <tr>
                            <td>Edge check</td>
                            <td>O(1)</td>
                            <td>O(V)</td>
                        </tr>
                    </table>
                </div>
                <div class="column">
                    <h3>Tipuri de Grafuri</h3>
                    <ul>
                        <li><strong>Directed / Undirected</strong></li>
                        <li><strong>Weighted / Unweighted</strong></li>
                        <li><strong>Cyclic / Acyclic</strong></li>
                        <li><strong>Connected / Disconnected</strong></li>
                    </ul>
                    <div class="code-block">
                        <div class="code-header">
                            <span>ListÄƒ de adiacenÈ›Äƒ</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">typedef struct AdjNode {
    int vertex;
    int weight;
    struct AdjNode *next;
} AdjNode;

typedef struct Graph {
    int V;
    AdjNode **adj;  // Array de liste
} Graph;</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 17: BFS Review -->
        <div class="slide">
            <h2>ğŸŒŠ Recapitulare: BFS (Breadth-First Search)</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Principiu</h3>
                    <p>ExploreazÄƒ <strong>nivel cu nivel</strong>, folosind o <strong>coadÄƒ</strong>.</p>
                    <div class="diagram">
Ordinea vizitÄƒrii:

        1 â—„â”€â”€ Start
       /|\
      2 3 4     Nivel 1
     /| |
    5 6 7       Nivel 2

Vizitat: 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6 â†’ 7
                    </div>
                    <h3>AplicaÈ›ii</h3>
                    <ul>
                        <li>Shortest path (grafuri neponderate)</li>
                        <li>Level order traversal</li>
                        <li>Finding connected components</li>
                    </ul>
                </div>
                <div class="column">
                    <div class="code-block">
                        <div class="code-header">
                            <span>Algoritm BFS</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">void BFS(Graph *g, int start) {
    bool *visited = calloc(g->V, sizeof(bool));
    Queue *q = create_queue();
    
    visited[start] = true;
    enqueue(q, start);
    
    while (!is_empty(q)) {
        int v = dequeue(q);
        printf("%d ", v);
        
        // ViziteazÄƒ toÈ›i vecinii nevizitaÈ›i
        AdjNode *node = g->adj[v];
        while (node) {
            if (!visited[node->vertex]) {
                visited[node->vertex] = true;
                enqueue(q, node->vertex);
            }
            node = node->next;
        }
    }
}</code></pre>
                    </div>
                    <p><strong>Complexitate:</strong> <span class="complexity medium">O(V + E)</span></p>
                </div>
            </div>
        </div>

        <!-- Slide 18: DFS Review -->
        <div class="slide">
            <h2>ğŸŠ Recapitulare: DFS (Depth-First Search)</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Principiu</h3>
                    <p>ExploreazÄƒ <strong>cÃ¢t mai adÃ¢nc</strong>, folosind <strong>stivÄƒ</strong> (sau recursivitate).</p>
                    <div class="diagram">
Ordinea vizitÄƒrii:

        1 â—„â”€â”€ Start
       /|\
      2 3 4
     /|
    5 6

Vizitat: 1 â†’ 2 â†’ 5 â†’ 6 â†’ 3 â†’ 4
(merge Ã®n adÃ¢ncime pe ramura stÃ¢ngÄƒ)
                    </div>
                    <h3>AplicaÈ›ii</h3>
                    <ul>
                        <li>Detectare cicluri</li>
                        <li>Sortare topologicÄƒ</li>
                        <li>Componente tare conexe</li>
                        <li>Maze solving</li>
                    </ul>
                </div>
                <div class="column">
                    <div class="code-block">
                        <div class="code-header">
                            <span>Algoritm DFS (recursiv)</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">void DFS_util(Graph *g, int v, bool *visited) {
    visited[v] = true;
    printf("%d ", v);
    
    AdjNode *node = g->adj[v];
    while (node) {
        if (!visited[node->vertex])
            DFS_util(g, node->vertex, visited);
        node = node->next;
    }
}

void DFS(Graph *g, int start) {
    bool *visited = calloc(g->V, sizeof(bool));
    DFS_util(g, start, visited);
    free(visited);
}</code></pre>
                    </div>
                    <p><strong>Complexitate:</strong> <span class="complexity medium">O(V + E)</span></p>
                </div>
            </div>
        </div>

        <!-- Slide 19: Dijkstra Review -->
        <div class="slide">
            <h2>ğŸ›¤ï¸ Recapitulare: Algoritmul lui Dijkstra</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Problema</h3>
                    <div class="info-box">
                        GÄƒseÈ™te <strong>drumul minim</strong> de la un nod sursÄƒ la toate celelalte noduri Ã®ntr-un graf <strong>ponderat</strong> cu muchii <strong>non-negative</strong>.
                    </div>
                    <h3>Algoritm</h3>
                    <ol>
                        <li>IniÈ›ializeazÄƒ dist[source] = 0, dist[others] = âˆ</li>
                        <li>FoloseÈ™te min-heap pentru a extrage nodul cu distanÈ›a minimÄƒ</li>
                        <li>Pentru fiecare vecin, relaxeazÄƒ muchia</li>
                        <li>RepetÄƒ pÃ¢nÄƒ cÃ¢nd toate nodurile sunt procesate</li>
                    </ol>
                    <p><strong>Complexitate:</strong> <span class="complexity medium">O((V+E) log V)</span> cu heap</p>
                </div>
                <div class="column">
                    <div class="code-block">
                        <div class="code-header">
                            <span>Relaxare muchie</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">// Relaxare: actualizeazÄƒ distanÈ›a dacÄƒ
// am gÄƒsit un drum mai scurt
void relax(int u, int v, int weight, 
           int *dist, int *parent) {
    if (dist[u] != INT_MAX && 
        dist[u] + weight < dist[v]) {
        dist[v] = dist[u] + weight;
        parent[v] = u;
    }
}

// Ãn bucla principalÄƒ:
while (!heap_empty(pq)) {
    int u = extract_min(pq);
    for (each neighbor v of u) {
        relax(u, v, weight(u,v), dist, parent);
        decrease_key(pq, v, dist[v]);
    }
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 20: Function Pointers Review -->
        <div class="slide">
            <h2>ğŸ¯ Recapitulare: Function Pointers</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>DeclaraÈ›ie</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Sintaxa function pointers</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">// Pointer la funcÈ›ie care primeÈ™te
// doi int È™i returneazÄƒ int
int (*operation)(int, int);

// Typedef pentru claritate
typedef int (*BinaryOp)(int, int);

// Utilizare
int add(int a, int b) { return a + b; }
int mul(int a, int b) { return a * b; }

BinaryOp op = add;
printf("%d\n", op(5, 3));  // 8

op = mul;
printf("%d\n", op(5, 3));  // 15</code></pre>
                    </div>
                </div>
                <div class="column">
                    <h3>qsort - Exemplu Clasic</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Callback pentru qsort</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">int compare_int(const void *a, 
                const void *b) {
    return (*(int*)a - *(int*)b);
}

int compare_desc(const void *a, 
                 const void *b) {
    return (*(int*)b - *(int*)a);
}

int main() {
    int arr[] = {64, 34, 25, 12, 22};
    int n = sizeof(arr)/sizeof(arr[0]);
    
    qsort(arr, n, sizeof(int), compare_int);
    // arr = {12, 22, 25, 34, 64}
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 21: File I/O Review -->
        <div class="slide">
            <h2>ğŸ“ Recapitulare: OperaÈ›ii cu FiÈ™iere</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>FiÈ™iere Text</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Citire/scriere text</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">FILE *f = fopen("data.txt", "r");
if (!f) {
    perror("Eroare la deschidere");
    return 1;
}

char line[256];
while (fgets(line, sizeof(line), f)) {
    printf("%s", line);
}

fclose(f);

// Scriere
FILE *out = fopen("out.txt", "w");
fprintf(out, "Valoare: %d\n", 42);
fclose(out);</code></pre>
                    </div>
                </div>
                <div class="column">
                    <h3>FiÈ™iere Binare</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Citire/scriere binarÄƒ</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">typedef struct {
    char name[50];
    int age;
    float salary;
} Employee;

// Scriere
FILE *f = fopen("emp.dat", "wb");
Employee e = {"Ion", 30, 5000.0};
fwrite(&e, sizeof(Employee), 1, f);
fclose(f);

// Citire
f = fopen("emp.dat", "rb");
Employee e2;
fread(&e2, sizeof(Employee), 1, f);
fclose(f);</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 22: Memory Management -->
        <div class="slide">
            <h2>ğŸ§  Recapitulare: Managementul Memoriei</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Zone de Memorie</h3>
                    <div class="diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” Adrese mari
â”‚           STACK             â”‚ â†“ creÈ™te
â”‚   (variabile locale,        â”‚
â”‚    parametri funcÈ›ii)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚             â†“               â”‚
â”‚          (liber)            â”‚
â”‚             â†‘               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           HEAP              â”‚ â†‘ creÈ™te
â”‚   (alocare dinamicÄƒ:        â”‚
â”‚    malloc, calloc, realloc) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           BSS               â”‚
â”‚   (variabile globale        â”‚
â”‚    neiniÈ›ializate)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           DATA              â”‚
â”‚   (variabile globale        â”‚
â”‚    iniÈ›ializate)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           TEXT              â”‚
â”‚   (codul programului)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Adrese mici
                    </div>
                </div>
                <div class="column">
                    <h3>FuncÈ›ii de Alocare</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>malloc, calloc, realloc, free</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">// malloc - memorie neiniÈ›ializatÄƒ
int *p = malloc(n * sizeof(int));

// calloc - memorie zero-iniÈ›ializatÄƒ
int *p = calloc(n, sizeof(int));

// realloc - redimensionare
p = realloc(p, new_n * sizeof(int));

// ÃNTOTDEAUNA elibereazÄƒ memoria!
free(p);
p = NULL;  // EvitÄƒ dangling pointers</code></pre>
                    </div>
                    <div class="error-box">
                        <strong>ğŸš¨ Memory Leaks:</strong><br>
                        Fiecare <code>malloc/calloc</code> trebuie sÄƒ aibÄƒ un <code>free</code> corespunzÄƒtor!
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 23: Common Mistakes -->
        <div class="slide">
            <h2>âš ï¸ GreÈ™eli Comune È™i Cum sÄƒ le EviÈ›i</h2>
            <div class="grid-2x2">
                <div class="error-box">
                    <h4>1. Buffer Overflow</h4>
                    <pre style="background: transparent; padding: 10px 0;"><code class="language-c">// GREÈ˜IT
char buf[10];
strcpy(buf, "String foarte lung");

// CORECT
strncpy(buf, str, sizeof(buf) - 1);
buf[sizeof(buf) - 1] = '\0';</code></pre>
                </div>
                <div class="error-box">
                    <h4>2. Memory Leak</h4>
                    <pre style="background: transparent; padding: 10px 0;"><code class="language-c">// GREÈ˜IT
void func() {
    int *p = malloc(100);
    return;  // p se pierde!
}

// CORECT - elibereazÄƒ Ã®nainte de return
free(p);</code></pre>
                </div>
                <div class="error-box">
                    <h4>3. Use After Free</h4>
                    <pre style="background: transparent; padding: 10px 0;"><code class="language-c">// GREÈ˜IT
free(p);
printf("%d", *p);  // Comportament nedefinit!

// CORECT
free(p);
p = NULL;</code></pre>
                </div>
                <div class="error-box">
                    <h4>4. NULL Pointer Dereference</h4>
                    <pre style="background: transparent; padding: 10px 0;"><code class="language-c">// GREÈ˜IT
Node *n = find(list, key);
printf("%d", n->data);  // Ce dacÄƒ n e NULL?

// CORECT
if (n != NULL)
    printf("%d", n->data);</code></pre>
                </div>
            </div>
        </div>

        <!-- Slide 24: Valgrind Usage -->
        <div class="slide">
            <h2>ğŸ”¬ Debugging: Valgrind</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Ce detecteazÄƒ Valgrind?</h3>
                    <ul>
                        <li>Memory leaks</li>
                        <li>Acces la memorie nealocatÄƒ</li>
                        <li>Use after free</li>
                        <li>Double free</li>
                        <li>Buffer overflows</li>
                        <li>Variabile neiniÈ›ializate</li>
                    </ul>
                    <h3>Comenzi EsenÈ›iale</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Utilizare Valgrind</span>
                            <span class="lang-badge">Bash</span>
                        </div>
                        <pre><code class="language-bash"># Verificare memory leaks
valgrind --leak-check=full ./program

# Cu track-origins pentru neiniÈ›ializate
valgrind --track-origins=yes ./program

# Salvare output
valgrind --log-file=valgrind.log ./program</code></pre>
                    </div>
                </div>
                <div class="column">
                    <h3>Interpretarea Output-ului</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Exemplu output Valgrind</span>
                            <span class="lang-badge">Output</span>
                        </div>
                        <pre><code>==12345== HEAP SUMMARY:
==12345==   in use at exit: 100 bytes in 1 blocks
==12345==   total heap usage: 5 allocs, 4 frees
==12345== 
==12345== 100 bytes in 1 blocks are definitely lost
==12345==    at 0x4C2BBEF: malloc (vg_replace_malloc.c)
==12345==    by 0x40054E: create_node (program.c:15)
==12345==    by 0x400589: main (program.c:25)
==12345== 
==12345== LEAK SUMMARY:
==12345==    definitely lost: 100 bytes
==12345==    possibly lost: 0 bytes</code></pre>
                    </div>
                    <div class="success-box">
                        <strong>âœ… Obiectiv:</strong><br>
                        "All heap blocks were freed -- no leaks are possible"
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 25: GDB Debugging -->
        <div class="slide">
            <h2>ğŸ› Debugging: GDB</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Comenzi EsenÈ›iale</h3>
                    <table style="font-size: 0.9em;">
                        <tr><th>ComandÄƒ</th><th>Descriere</th></tr>
                        <tr><td><code>break main</code></td><td>Breakpoint la funcÈ›ia main</td></tr>
                        <tr><td><code>break file.c:25</code></td><td>Breakpoint la linia 25</td></tr>
                        <tr><td><code>run</code></td><td>PorneÈ™te execuÈ›ia</td></tr>
                        <tr><td><code>next</code></td><td>ExecutÄƒ linia curentÄƒ</td></tr>
                        <tr><td><code>step</code></td><td>IntrÄƒ Ã®n funcÈ›ie</td></tr>
                        <tr><td><code>continue</code></td><td>ContinuÄƒ pÃ¢nÄƒ la breakpoint</td></tr>
                        <tr><td><code>print var</code></td><td>AfiÈ™eazÄƒ valoarea variabilei</td></tr>
                        <tr><td><code>backtrace</code></td><td>AfiÈ™eazÄƒ call stack</td></tr>
                        <tr><td><code>quit</code></td><td>IeÈ™ire din GDB</td></tr>
                    </table>
                </div>
                <div class="column">
                    <h3>Sesiune TipicÄƒ</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Exemplu debugging</span>
                            <span class="lang-badge">GDB</span>
                        </div>
                        <pre><code class="language-bash"># Compilare cu simboluri debug
gcc -g -o program program.c

# Pornire GDB
gdb ./program

(gdb) break main
(gdb) run
(gdb) next
(gdb) print array[0]
$1 = 42
(gdb) print *node
$2 = {data = 10, next = 0x55555576a2a0}
(gdb) backtrace
#0  insert (list=0x7fff..., val=42) at list.c:45
#1  main () at program.c:78
(gdb) continue</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 26: Optimization Techniques -->
        <div class="slide">
            <h2>ğŸš€ Tehnici de Optimizare</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>1. Cache Locality</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Acces cache-friendly</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">// LENT - acces pe coloane (cache misses)
for (int j = 0; j < N; j++)
    for (int i = 0; i < N; i++)
        sum += matrix[i][j];

// RAPID - acces pe linii (cache hits)
for (int i = 0; i < N; i++)
    for (int j = 0; j < N; j++)
        sum += matrix[i][j];</code></pre>
                    </div>
                    <h3>2. Loop Unrolling</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Derularea buclelor</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">// Reduc overhead-ul buclei
for (int i = 0; i < n; i += 4) {
    sum += arr[i] + arr[i+1] + 
           arr[i+2] + arr[i+3];
}</code></pre>
                    </div>
                </div>
                <div class="column">
                    <h3>3. Evitarea RecalculÄƒrilor</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Memoization</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">// LENT - recalculare strlen Ã®n buclÄƒ
for (int i = 0; i < strlen(s); i++)
    process(s[i]);

// RAPID - calculare o singurÄƒ datÄƒ
int len = strlen(s);
for (int i = 0; i < len; i++)
    process(s[i]);</code></pre>
                    </div>
                    <h3>4. Branch Prediction</h3>
                    <div class="info-box">
                        <strong>SorteazÄƒ datele</strong> Ã®nainte de procesare condiÈ›ionalÄƒ cÃ¢nd e posibil. CPU-ul prezice mai bine branch-urile predictibile.
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 27: Choosing Data Structures -->
        <div class="slide">
            <h2>ğŸ¯ Ghid de SelecÈ›ie a Structurilor</h2>
            <div class="diagram" style="font-size: 0.9em; line-height: 1.6;">
                                    START
                                      â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   Acces aleator rapid necesar?    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           DA         â”‚         NU
                            â”‚         â”‚          â”‚
                     â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
                     â”‚ Hash Table â”‚  â”‚   â”‚ Datele      â”‚
                     â”‚ sau Array  â”‚  â”‚   â”‚ trebuie     â”‚
                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚ sortate?    â”‚
                                     â”‚   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                                     â”‚      DA  â”‚  NU
                                     â”‚       â”‚  â”‚   â”‚
                              â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”â”‚  â”‚â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
                              â”‚ BST / AVL   â”‚â”‚  â”‚â”‚ InserÄƒri    â”‚
                              â”‚ Tree        â”‚â”‚  â”‚â”‚ frecvente?  â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                                             â”‚  â”‚   DA  â”‚  NU
                                             â”‚  â”‚    â”‚  â”‚   â”‚
                                      â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
                                      â”‚    Linked List    Array    â”‚
                                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
            <div class="success-box" style="margin-top: 20px;">
                <strong>Principiu cheie:</strong> Nu existÄƒ structura de date â€perfectÄƒ". Alegerea depinde de operaÈ›iile predominante È™i de cerinÈ›ele specifice ale aplicaÈ›iei.
            </div>
        </div>

        <!-- Slide 28: Space-Time Tradeoffs -->
        <div class="slide">
            <h2>âš–ï¸ Compromisuri SpaÈ›iu-Timp</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Exemplu 1: Fibonacci</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Recursiv vs Dynamic Programming</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">// Recursiv: O(2^n) timp, O(n) spaÈ›iu
int fib_rec(int n) {
    if (n <= 1) return n;
    return fib_rec(n-1) + fib_rec(n-2);
}

// DP: O(n) timp, O(n) spaÈ›iu
int fib_dp(int n) {
    int *dp = malloc((n+1) * sizeof(int));
    dp[0] = 0; dp[1] = 1;
    for (int i = 2; i <= n; i++)
        dp[i] = dp[i-1] + dp[i-2];
    return dp[n];
}

// Optimizat: O(n) timp, O(1) spaÈ›iu
int fib_opt(int n) {
    int a = 0, b = 1, c;
    for (int i = 2; i <= n; i++) {
        c = a + b; a = b; b = c;
    }
    return b;
}</code></pre>
                    </div>
                </div>
                <div class="column">
                    <h3>Exemplu 2: Lookup Table</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Precomputare vs Calcul</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">// Calcul la fiecare apel
int square(int x) { return x * x; }

// Lookup table (precomputed)
int squares[1001];  // FoloseÈ™te memorie
void init_squares() {
    for (int i = 0; i <= 1000; i++)
        squares[i] = i * i;
}
// Acces: O(1) - squares[x]</code></pre>
                    </div>
                    <h3>Principii Generale</h3>
                    <table style="font-size: 0.9em;">
                        <tr>
                            <th>TehnicÄƒ</th>
                            <th>Timp</th>
                            <th>SpaÈ›iu</th>
                        </tr>
                        <tr>
                            <td>Memoization</td>
                            <td>â†“ Reduce</td>
                            <td>â†‘ CreÈ™te</td>
                        </tr>
                        <tr>
                            <td>Compression</td>
                            <td>â†‘ CreÈ™te</td>
                            <td>â†“ Reduce</td>
                        </tr>
                        <tr>
                            <td>Caching</td>
                            <td>â†“ Reduce</td>
                            <td>â†‘ CreÈ™te</td>
                        </tr>
                    </table>
                </div>
            </div>
        </div>

        <!-- Slide 29: Interview Patterns -->
        <div class="slide">
            <h2>ğŸ’¼ Pattern-uri pentru Interviuri</h2>
            <div class="grid-2x2">
                <div class="card">
                    <div class="card-title">ğŸ”„ Two Pointers</div>
                    <p>Array sortat, gÄƒsirea perechilor, palindroame</p>
                    <pre style="font-size: 0.85em;"><code class="language-c">int left = 0, right = n-1;
while (left < right) {
    // procesare
}</code></pre>
                </div>
                <div class="card">
                    <div class="card-title">ğŸªŸ Sliding Window</div>
                    <p>Subarray-uri contigue, substring-uri</p>
                    <pre style="font-size: 0.85em;"><code class="language-c">for (int i = 0; i < n; i++) {
    // adaugÄƒ element
    while (conditie_invalida)
        // eliminÄƒ de la Ã®nceput
}</code></pre>
                </div>
                <div class="card">
                    <div class="card-title">ğŸ” Binary Search</div>
                    <p>Date sortate, gÄƒsirea valorilor</p>
                    <pre style="font-size: 0.85em;"><code class="language-c">while (left <= right) {
    int mid = left + (right - left) / 2;
    if (arr[mid] == target) return mid;
    // ajustare left/right
}</code></pre>
                </div>
                <div class="card">
                    <div class="card-title">ğŸ”€ Divide & Conquer</div>
                    <p>Merge sort, Quick sort, arbori</p>
                    <pre style="font-size: 0.85em;"><code class="language-c">int solve(int l, int r) {
    if (l >= r) return base_case;
    int mid = (l + r) / 2;
    return combine(solve(l,mid), solve(mid+1,r));
}</code></pre>
                </div>
            </div>
        </div>

        <!-- Slide 30: System Design Basics -->
        <div class="slide">
            <h2>ğŸ—ï¸ Design de Sisteme - Elemente de BazÄƒ</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>LRU Cache (Least Recently Used)</h3>
                    <div class="diagram" style="font-size: 0.85em;">
Hash Table + Doubly Linked List

Hash Table (O(1) lookup):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ key1 â†’ node1               â”‚
â”‚ key2 â†’ node2               â”‚
â”‚ key3 â†’ node3               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
Doubly Linked List (ordine acces):
HEAD â—„â”€â”€â–º node1 â—„â”€â”€â–º node2 â—„â”€â”€â–º node3 â—„â”€â”€â–º TAIL
(recent)                         (least recent)
                    </div>
                    <p style="font-size: 0.95em;">
                        <strong>get(key):</strong> O(1) - mutÄƒ nodul la HEAD<br>
                        <strong>put(key, val):</strong> O(1) - adaugÄƒ la HEAD, eliminÄƒ TAIL dacÄƒ plin
                    </p>
                </div>
                <div class="column">
                    <h3>Trie (Prefix Tree)</h3>
                    <div class="diagram" style="font-size: 0.85em;">
Autocomplete: "ca", "cat", "car", "card"

           (root)
             â”‚
            [c]
             â”‚
            [a]â”€â”€â”€â”€â”€â”€â”
           / \       â”‚
         [t] [r]   isEnd=true ("ca")
          â”‚   â”‚
     isEnd [d]
     ("cat")â”‚
         isEnd ("card")
                    </div>
                    <p style="font-size: 0.95em;">
                        <strong>Insert/Search:</strong> O(L) - L = lungime cuvÃ¢nt<br>
                        <strong>Prefix search:</strong> O(P + N) - P = prefix, N = rezultate
                    </p>
                </div>
            </div>
        </div>

        <!-- Slide 31: Integrated Project Example -->
        <div class="slide">
            <h2>ğŸ”§ Exemplu: Proiect Integrat</h2>
            <h3>Sistem de Management al StudenÈ›ilor</h3>
            <div class="diagram" style="font-size: 0.85em;">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        STUDENT MANAGEMENT SYSTEM                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Hash Table     â”‚     â”‚      BST         â”‚     â”‚   Priority Queue â”‚ â”‚
â”‚  â”‚  (ID â†’ Student)  â”‚     â”‚ (Sorted by Name) â”‚     â”‚  (by GPA desc)   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚           â”‚                        â”‚                         â”‚          â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                    â”‚                                     â”‚
â”‚                              â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”                               â”‚
â”‚                              â”‚  Student  â”‚                               â”‚
â”‚                              â”‚  struct   â”‚                               â”‚
â”‚                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚                                                                          â”‚
â”‚  OperaÈ›ii:                                                               â”‚
â”‚  â€¢ cÄƒutare_id(id)     â†’ Hash Table O(1)                                 â”‚
â”‚  â€¢ lista_sortata()    â†’ BST Inorder O(n)                                â”‚
â”‚  â€¢ top_k_studenti(k)  â†’ Heap Extract K Ã— O(log n)                       â”‚
â”‚  â€¢ export_fisier()    â†’ Serializare binarÄƒ                              â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
        </div>

        <!-- Slide 32: Best Practices Summary -->
        <div class="slide">
            <h2>âœ… Best Practices - Sumar</h2>
            <div class="three-columns">
                <div class="success-box">
                    <h4>âœ… DO (FÄƒ)</h4>
                    <ul style="font-size: 0.95em;">
                        <li>VerificÄƒ NULL Ã®nainte de dereferenÈ›iere</li>
                        <li>ElibereazÄƒ memoria alocatÄƒ</li>
                        <li>FoloseÈ™te <code>const</code> pentru parametri nemodificaÈ›i</li>
                        <li>CompileazÄƒ cu <code>-Wall -Wextra</code></li>
                        <li>TesteazÄƒ cu Valgrind</li>
                        <li>DocumenteazÄƒ funcÈ›iile</li>
                        <li>Alege structura potrivitÄƒ problemei</li>
                    </ul>
                </div>
                <div class="error-box">
                    <h4>âŒ DON'T (Nu fÄƒ)</h4>
                    <ul style="font-size: 0.95em;">
                        <li>Nu ignora valorile returnate</li>
                        <li>Nu folosi magic numbers</li>
                        <li>Nu presupune dimensiuni fixe</li>
                        <li>Nu amesteca tipuri (size_t vs int)</li>
                        <li>Nu optimiza prematur</li>
                        <li>Nu copia cod fÄƒrÄƒ Ã®nÈ›elegere</li>
                        <li>Nu ignora warnings</li>
                    </ul>
                </div>
                <div class="info-box">
                    <h4>ğŸ’¡ REMEMBER</h4>
                    <ul style="font-size: 0.95em;">
                        <li>Claritatea > cleverness</li>
                        <li>TesteazÄƒ edge cases</li>
                        <li>ProfileazÄƒ Ã®nainte de optimizare</li>
                        <li>DocumenteazÄƒ compromisurile</li>
                        <li>Code review ajutÄƒ</li>
                        <li>ÃnvaÈ›Äƒ din greÈ™eli</li>
                        <li>PracticÄƒ constant</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 33: Complexity Cheat Sheet -->
        <div class="slide">
            <h2>ğŸ“‹ Cheat Sheet - ComplexitÄƒÈ›i</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Structuri de Date</h3>
                    <table style="font-size: 0.85em;">
                        <tr><th>StructurÄƒ</th><th>Acces</th><th>Search</th><th>Insert</th><th>Delete</th></tr>
                        <tr><td>Array</td><td class="complexity good">O(1)</td><td class="complexity bad">O(n)</td><td class="complexity bad">O(n)</td><td class="complexity bad">O(n)</td></tr>
                        <tr><td>Linked List</td><td class="complexity bad">O(n)</td><td class="complexity bad">O(n)</td><td class="complexity good">O(1)</td><td class="complexity good">O(1)</td></tr>
                        <tr><td>Stack/Queue</td><td class="complexity bad">O(n)</td><td class="complexity bad">O(n)</td><td class="complexity good">O(1)</td><td class="complexity good">O(1)</td></tr>
                        <tr><td>BST</td><td class="complexity medium">O(log n)</td><td class="complexity medium">O(log n)</td><td class="complexity medium">O(log n)</td><td class="complexity medium">O(log n)</td></tr>
                        <tr><td>Hash Table</td><td>-</td><td class="complexity good">O(1)</td><td class="complexity good">O(1)</td><td class="complexity good">O(1)</td></tr>
                    </table>
                </div>
                <div class="column">
                    <h3>Algoritmi de Sortare</h3>
                    <table style="font-size: 0.85em;">
                        <tr><th>Algoritm</th><th>Best</th><th>Avg</th><th>Worst</th><th>Space</th></tr>
                        <tr><td>Bubble</td><td class="complexity bad">O(nÂ²)</td><td class="complexity bad">O(nÂ²)</td><td class="complexity bad">O(nÂ²)</td><td class="complexity good">O(1)</td></tr>
                        <tr><td>Merge</td><td class="complexity medium">O(n log n)</td><td class="complexity medium">O(n log n)</td><td class="complexity medium">O(n log n)</td><td class="complexity bad">O(n)</td></tr>
                        <tr><td>Quick</td><td class="complexity medium">O(n log n)</td><td class="complexity medium">O(n log n)</td><td class="complexity bad">O(nÂ²)</td><td class="complexity medium">O(log n)</td></tr>
                        <tr><td>Heap</td><td class="complexity medium">O(n log n)</td><td class="complexity medium">O(n log n)</td><td class="complexity medium">O(n log n)</td><td class="complexity good">O(1)</td></tr>
                    </table>
                    <h3>Grafuri</h3>
                    <table style="font-size: 0.85em;">
                        <tr><th>Algoritm</th><th>Complexitate</th></tr>
                        <tr><td>BFS/DFS</td><td class="complexity medium">O(V + E)</td></tr>
                        <tr><td>Dijkstra (heap)</td><td class="complexity medium">O((V+E) log V)</td></tr>
                    </table>
                </div>
            </div>
        </div>

        <!-- Slide 34: Laboratory Preview -->
        <div class="slide">
            <h2>ğŸ”¬ Previzualizare Laborator</h2>
            <div class="two-columns">
                <div class="card">
                    <div class="card-title">ğŸ“¦ ExerciÈ›iu 1: Sistem de Comenzi</div>
                    <p><strong>Obiectiv:</strong> Integrarea multiplelor structuri de date</p>
                    <ul>
                        <li>Hash table pentru cÄƒutare dupÄƒ ID</li>
                        <li>BST pentru ordonare cronologicÄƒ</li>
                        <li>Priority queue pentru urgenÈ›e</li>
                        <li>Serializare Ã®n fiÈ™iere binare</li>
                    </ul>
                    <p><strong>TODO-uri:</strong> 12</p>
                    <p><strong>Dificultate:</strong> <span class="complexity medium">Medie-AvansatÄƒ</span></p>
                </div>
                <div class="card">
                    <div class="card-title">ğŸŒ ExerciÈ›iu 2: ReÈ›ea SocialÄƒ</div>
                    <p><strong>Obiectiv:</strong> Algoritmi pe grafuri</p>
                    <ul>
                        <li>Reprezentare cu liste de adiacenÈ›Äƒ</li>
                        <li>BFS pentru grad de separare</li>
                        <li>DFS pentru detectare comunitÄƒÈ›i</li>
                        <li>Dijkstra pentru â€influenÈ›Äƒ"</li>
                    </ul>
                    <p><strong>TODO-uri:</strong> 15</p>
                    <p><strong>Dificultate:</strong> <span class="complexity bad">AvansatÄƒ</span></p>
                </div>
            </div>
            <div class="info-box" style="margin-top: 20px;">
                <strong>ğŸ’¡ Sfat:</strong> ÃncepeÈ›i cu structurile de date de bazÄƒ È™i adÄƒugaÈ›i funcÈ›ionalitÄƒÈ›i incrementat. TestaÈ›i fiecare componentÄƒ separat Ã®nainte de integrare.
            </div>
        </div>

        <!-- Slide 35: Key Takeaways -->
        <div class="slide">
            <h2>ğŸ“ Concluzii Cheie</h2>
            <div class="grid-3x2">
                <div class="card" style="text-align: center;">
                    <div style="font-size: 2em; margin-bottom: 10px;">ğŸ“Š</div>
                    <h4>Alegerea CorectÄƒ</h4>
                    <p>Nu existÄƒ structurÄƒ â€perfectÄƒ" - alegerea depinde de operaÈ›iile predominante</p>
                </div>
                <div class="card" style="text-align: center;">
                    <div style="font-size: 2em; margin-bottom: 10px;">âš–ï¸</div>
                    <h4>Compromisuri</h4>
                    <p>ÃnÈ›elege trade-off-urile timp-spaÈ›iu pentru fiecare decizie</p>
                </div>
                <div class="card" style="text-align: center;">
                    <div style="font-size: 2em; margin-bottom: 10px;">ğŸ”</div>
                    <h4>Analiza ComplexitÄƒÈ›ii</h4>
                    <p>EvalueazÄƒ Big-O pentru cazul mediu È™i worst-case</p>
                </div>
                <div class="card" style="text-align: center;">
                    <div style="font-size: 2em; margin-bottom: 10px;">ğŸ§ </div>
                    <h4>Memory Management</h4>
                    <p>Fiecare malloc necesitÄƒ free - foloseÈ™te Valgrind!</p>
                </div>
                <div class="card" style="text-align: center;">
                    <div style="font-size: 2em; margin-bottom: 10px;">ğŸ› ï¸</div>
                    <h4>Debugging</h4>
                    <p>GDB È™i Valgrind sunt prietenii tÄƒi - Ã®nvaÈ›Äƒ sÄƒ le foloseÈ™ti</p>
                </div>
                <div class="card" style="text-align: center;">
                    <div style="font-size: 2em; margin-bottom: 10px;">ğŸ”—</div>
                    <h4>Integrare</h4>
                    <p>Sistemele reale combinÄƒ multiple structuri - practicÄƒ integrarea</p>
                </div>
            </div>
        </div>

        <!-- Slide 36: Resources -->
        <div class="slide">
            <h2>ğŸ“š Resurse pentru Studiu</h2>
            <div class="three-columns">
                <div class="column">
                    <h3>ğŸ“– CÄƒrÈ›i</h3>
                    <ul style="font-size: 0.95em;">
                        <li><strong>Knuth</strong> - "TAOCP"</li>
                        <li><strong>CLRS</strong> - "Introduction to Algorithms"</li>
                        <li><strong>Sedgewick</strong> - "Algorithms in C"</li>
                        <li><strong>Skiena</strong> - "Algorithm Design Manual"</li>
                        <li><strong>Bentley</strong> - "Programming Pearls"</li>
                    </ul>
                </div>
                <div class="column">
                    <h3>ğŸŒ Online</h3>
                    <ul style="font-size: 0.95em;">
                        <li><a href="https://visualgo.net" style="color: var(--accent-blue);">Visualgo.net</a></li>
                        <li><a href="https://www.bigocheatsheet.com" style="color: var(--accent-blue);">Big-O Cheat Sheet</a></li>
                        <li><a href="https://www.geeksforgeeks.org" style="color: var(--accent-blue);">GeeksforGeeks</a></li>
                        <li>MIT OCW 6.006</li>
                        <li>Stanford CS106B</li>
                    </ul>
                </div>
                <div class="column">
                    <h3>ğŸ’» PracticÄƒ</h3>
                    <ul style="font-size: 0.95em;">
                        <li><a href="https://leetcode.com" style="color: var(--accent-blue);">LeetCode</a></li>
                        <li><a href="https://hackerrank.com" style="color: var(--accent-blue);">HackerRank</a></li>
                        <li><a href="https://codeforces.com" style="color: var(--accent-blue);">Codeforces</a></li>
                        <li>Project Euler</li>
                        <li>Codewars</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 37: Exam Preparation -->
        <div class="slide">
            <h2>ğŸ“ PregÄƒtire pentru Examenul Final</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Structura Examenului</h3>
                    <div class="card">
                        <div class="card-title" style="color: var(--accent-blue);">Partea I: Teorie (40%)</div>
                        <ul>
                            <li>ComplexitÄƒÈ›i temporale/spaÈ›iale</li>
                            <li>ComparaÈ›ii Ã®ntre structuri</li>
                            <li>Trade-offs È™i justificÄƒri</li>
                            <li>ÃntrebÄƒri cu rÄƒspuns scurt</li>
                        </ul>
                    </div>
                    <div class="card">
                        <div class="card-title" style="color: var(--accent-green);">Partea II: Implementare (30%)</div>
                        <ul>
                            <li>Implementare structurÄƒ de la zero</li>
                            <li>Completare cod cu TODO</li>
                            <li>Corectare buguri</li>
                        </ul>
                    </div>
                    <div class="card">
                        <div class="card-title" style="color: var(--accent-purple);">Partea III: ProblemÄƒ (30%)</div>
                        <ul>
                            <li>ProblemÄƒ complexÄƒ</li>
                            <li>Alegerea structurilor potrivite</li>
                            <li>Analiza soluÈ›iei</li>
                        </ul>
                    </div>
                </div>
                <div class="column">
                    <h3>Sfaturi pentru Succes</h3>
                    <div class="success-box">
                        <ol>
                            <li><strong>RepetÄƒ toate laboratoarele</strong> - refÄƒ exerciÈ›iile fÄƒrÄƒ sÄƒ te uiÈ›i la soluÈ›ii</li>
                            <li><strong>PracticÄƒ pe hÃ¢rtie</strong> - deseneazÄƒ structuri, urmÄƒreÈ™te algoritmi pas cu pas</li>
                            <li><strong>ÃnvaÈ›Äƒ complexitÄƒÈ›ile</strong> - trebuie sÄƒ le È™tii instant</li>
                            <li><strong>RezolvÄƒ probleme bonus</strong> - pregÄƒtire excelentÄƒ pentru partea III</li>
                            <li><strong>FormeazÄƒ grupuri de studiu</strong> - explicÄƒ conceptele altora</li>
                        </ol>
                    </div>
                    <div class="warning-box">
                        <strong>âš ï¸ Nu memora codul!</strong><br>
                        ÃnÈ›elege logica È™i vei putea implementa orice variantÄƒ.
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 38: Self-Assessment -->
        <div class="slide">
            <h2>âœ… Auto-Evaluare FinalÄƒ</h2>
            <p>VerificÄƒ cÄƒ poÈ›i rÄƒspunde â€DA" la toate Ã®ntrebÄƒrile:</p>
            <div class="two-columns">
                <div class="column">
                    <h4>Structuri de Date</h4>
                    <ul>
                        <li>â˜ Pot implementa linked list de la zero?</li>
                        <li>â˜ ÃnÈ›eleg diferenÈ›a stack vs queue?</li>
                        <li>â˜ Pot implementa BST cu insert/delete/search?</li>
                        <li>â˜ È˜tiu ce sunt rotaÈ›iile Ã®n AVL?</li>
                        <li>â˜ ÃnÈ›eleg heap È™i heapify?</li>
                        <li>â˜ Pot implementa hash table cu chaining?</li>
                        <li>â˜ È˜tiu ambele reprezentÄƒri de grafuri?</li>
                    </ul>
                </div>
                <div class="column">
                    <h4>Algoritmi È™i Concepte</h4>
                    <ul>
                        <li>â˜ Pot analiza complexitatea unui algoritm?</li>
                        <li>â˜ ÃnÈ›eleg BFS È™i DFS?</li>
                        <li>â˜ Pot explica Dijkstra?</li>
                        <li>â˜ È˜tiu sÄƒ folosesc function pointers?</li>
                        <li>â˜ Pot lucra cu fiÈ™iere text È™i binare?</li>
                        <li>â˜ È˜tiu sÄƒ folosesc Valgrind È™i GDB?</li>
                        <li>â˜ Pot alege structura optimÄƒ pentru o problemÄƒ?</li>
                    </ul>
                </div>
            </div>
            <div class="info-box" style="margin-top: 20px;">
                <strong>Obiectiv:</strong> Toate cÄƒsuÈ›ele bifate = pregÄƒtit pentru examen! ğŸ¯
            </div>
        </div>

        <!-- Slide 39: Thank You -->
        <div class="slide">
            <div class="end-slide">
                <h1 style="font-size: 3em;">ğŸ‰ FelicitÄƒri!</h1>
                <p style="font-size: 1.5em; color: var(--text-secondary); margin: 30px 0;">
                    AÈ›i parcurs cu succes toate cele 14 sÄƒptÄƒmÃ¢ni ale cursului<br>
                    <span class="highlight-blue">Algoritmi È™i Tehnici de Programare</span>
                </p>
                <div class="quote-box" style="max-width: 700px; margin: 30px auto;">
                    "The only way to learn a new programming language is by writing programs in it."
                    <div class="quote-author">â€” Dennis Ritchie, creatorul limbajului C</div>
                </div>
                <p style="font-size: 1.2em; color: var(--accent-green); margin-top: 30px;">
                    Succes la examen! ğŸ€
                </p>
            </div>
        </div>

        <!-- Slide 40: Questions -->
        <div class="slide">
            <div class="end-slide">
                <h1 style="font-size: 3.5em;">â“</h1>
                <h2 style="color: var(--text-primary); margin: 20px 0;">ÃntrebÄƒri?</h2>
                <p style="font-size: 1.3em; color: var(--text-secondary);">
                    SÄƒptÄƒmÃ¢na viitoare: <span class="highlight">Examenul Final</span>
                </p>
                <div style="margin-top: 50px; padding: 30px; background: var(--bg-secondary); border-radius: 12px; display: inline-block;">
                    <p style="font-size: 1.1em; margin: 0;">
                        ğŸ“§ Contact: <span style="color: var(--accent-blue);">atp@csie.ase.ro</span><br>
                        ğŸŒ Materiale: <span style="color: var(--accent-blue);">moodle.csie.ase.ro</span>
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Navigation -->
    <div class="slide-counter">
        <span id="current">1</span> / <span id="total">40</span>
    </div>

    <div class="keyboard-hint">
        <kbd>â†</kbd> <kbd>â†’</kbd> pentru navigare
    </div>

    <div class="nav-controls">
        <button class="nav-btn" onclick="prevSlide()">â—€ Ãnapoi</button>
        <button class="nav-btn" onclick="nextSlide()">Ãnainte â–¶</button>
    </div>

    <script>
        // Initialize highlight.js
        hljs.highlightAll();

        // Slide navigation
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        const totalSlides = slides.length;
        const progressBar = document.getElementById('progress');
        const currentCounter = document.getElementById('current');
        const totalCounter = document.getElementById('total');

        totalCounter.textContent = totalSlides;

        function showSlide(n) {
            slides[currentSlide].classList.remove('active');
            currentSlide = (n + totalSlides) % totalSlides;
            slides[currentSlide].classList.add('active');
            
            // Update progress bar
            const progress = ((currentSlide + 1) / totalSlides) * 100;
            progressBar.style.width = progress + '%';
            
            // Update counter
            currentCounter.textContent = currentSlide + 1;
        }

        function nextSlide() {
            showSlide(currentSlide + 1);
        }

        function prevSlide() {
            showSlide(currentSlide - 1);
        }

        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            switch(e.key) {
                case 'ArrowRight':
                case ' ':
                    e.preventDefault();
                    nextSlide();
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    prevSlide();
                    break;
                case 'Home':
                    e.preventDefault();
                    showSlide(0);
                    break;
                case 'End':
                    e.preventDefault();
                    showSlide(totalSlides - 1);
                    break;
            }
        });

        // Touch support for mobile
        let touchStartX = 0;
        let touchEndX = 0;

        document.addEventListener('touchstart', function(e) {
            touchStartX = e.changedTouches[0].screenX;
        });

        document.addEventListener('touchend', function(e) {
            touchEndX = e.changedTouches[0].screenX;
            handleSwipe();
        });

        function handleSwipe() {
            const threshold = 50;
            if (touchEndX < touchStartX - threshold) {
                nextSlide();
            }
            if (touchEndX > touchStartX + threshold) {
                prevSlide();
            }
        }
    </script>
</body>
</html>
