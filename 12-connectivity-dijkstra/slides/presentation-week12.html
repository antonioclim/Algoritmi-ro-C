<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SÄƒptÄƒmÃ¢na 12: Grafuri â€” NoÈ›iuni Fundamentale | ATP</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-yellow: #d29922;
            --accent-red: #f85149;
            --accent-purple: #a371f7;
            --border-color: #30363d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow: hidden;
        }

        /* Progress Bar */
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            z-index: 1000;
            transition: width 0.3s ease;
        }

        /* Slide Container */
        .slides-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 60px 80px;
            display: none;
            opacity: 0;
            transition: opacity 0.4s ease;
            overflow-y: auto;
        }

        .slide.active {
            display: block;
            opacity: 1;
        }

        /* Typography */
        h1 {
            font-size: 2.8rem;
            color: var(--accent-blue);
            margin-bottom: 1.5rem;
            border-bottom: 3px solid var(--accent-purple);
            padding-bottom: 0.5rem;
        }

        h2 {
            font-size: 2.2rem;
            color: var(--accent-green);
            margin-bottom: 1.2rem;
        }

        h3 {
            font-size: 1.6rem;
            color: var(--accent-yellow);
            margin-bottom: 1rem;
        }

        p, li {
            font-size: 1.25rem;
            margin-bottom: 0.8rem;
            color: var(--text-primary);
        }

        ul, ol {
            margin-left: 2rem;
            margin-bottom: 1.5rem;
        }

        /* Title Slide */
        .title-slide {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-primary) 100%);
        }

        .title-slide h1 {
            font-size: 3.5rem;
            border: none;
            margin-bottom: 0.5rem;
        }

        .title-slide .subtitle {
            font-size: 2rem;
            color: var(--accent-purple);
            margin-bottom: 2rem;
        }

        .title-slide .course-info {
            font-size: 1.3rem;
            color: var(--text-secondary);
        }

        .title-slide .week-badge {
            background: var(--accent-blue);
            color: var(--bg-primary);
            padding: 0.5rem 2rem;
            border-radius: 25px;
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
        }

        /* Code Blocks */
        .code-block {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin: 1rem 0;
            overflow: hidden;
        }

        .code-header {
            background: var(--bg-tertiary);
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
        }

        .code-header span {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .lang-badge {
            background: var(--accent-blue);
            color: var(--bg-primary);
            padding: 0.2rem 0.6rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .code-block pre {
            margin: 0;
            padding: 1rem;
        }

        .code-block code {
            font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 0.95rem;
            line-height: 1.5;
        }

        /* Diagram Box */
        .diagram-box {
            background: var(--bg-secondary);
            border: 2px solid var(--accent-purple);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1rem 0;
            font-family: 'Consolas', monospace;
            white-space: pre;
            font-size: 1rem;
            line-height: 1.4;
            overflow-x: auto;
        }

        /* Info Boxes */
        .info-box {
            padding: 1rem 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
            border-left: 4px solid;
        }

        .info-box.tip {
            background: rgba(63, 185, 80, 0.1);
            border-color: var(--accent-green);
        }

        .info-box.warning {
            background: rgba(210, 153, 34, 0.1);
            border-color: var(--accent-yellow);
        }

        .info-box.danger {
            background: rgba(248, 81, 73, 0.1);
            border-color: var(--accent-red);
        }

        .info-box.note {
            background: rgba(88, 166, 255, 0.1);
            border-color: var(--accent-blue);
        }

        .info-box-title {
            font-weight: bold;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Two Column Layout */
        .two-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 1rem 0;
        }

        .column {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }

        .column h3 {
            margin-top: 0;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            font-size: 1.1rem;
        }

        th, td {
            padding: 0.8rem 1rem;
            text-align: left;
            border: 1px solid var(--border-color);
        }

        th {
            background: var(--bg-tertiary);
            color: var(--accent-blue);
            font-weight: 600;
        }

        tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Complexity Badge */
        .complexity {
            display: inline-block;
            background: var(--accent-purple);
            color: white;
            padding: 0.2rem 0.6rem;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9rem;
        }

        /* Quote Box */
        .quote-box {
            background: var(--bg-secondary);
            border-left: 4px solid var(--accent-purple);
            padding: 1.5rem;
            margin: 1.5rem 0;
            font-style: italic;
            font-size: 1.3rem;
        }

        .quote-author {
            text-align: right;
            color: var(--text-secondary);
            font-style: normal;
            margin-top: 1rem;
        }

        /* Key Takeaway Cards */
        .takeaway-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin: 1rem 0;
        }

        .takeaway-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            transition: transform 0.2s, border-color 0.2s;
        }

        .takeaway-card:hover {
            transform: translateY(-3px);
            border-color: var(--accent-blue);
        }

        .takeaway-card .icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        /* Navigation */
        .nav-controls {
            position: fixed;
            bottom: 20px;
            right: 30px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .nav-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.6rem 1.2rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
        }

        .nav-btn:hover {
            background: var(--accent-blue);
            color: var(--bg-primary);
        }

        /* Slide Counter */
        .slide-counter {
            position: fixed;
            bottom: 25px;
            left: 30px;
            color: var(--text-secondary);
            font-size: 1rem;
            z-index: 100;
        }

        /* Highlight effects */
        .highlight {
            background: linear-gradient(120deg, var(--accent-yellow) 0%, var(--accent-yellow) 100%);
            background-repeat: no-repeat;
            background-size: 100% 0.3em;
            background-position: 0 88%;
        }

        .keyword {
            color: var(--accent-blue);
            font-weight: bold;
        }

        /* Animation */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .slide.active > * {
            animation: fadeInUp 0.5s ease forwards;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-blue);
        }

        /* Checklist */
        .checklist {
            list-style: none;
            margin-left: 0;
        }

        .checklist li {
            padding-left: 2rem;
            position: relative;
            margin-bottom: 0.6rem;
        }

        .checklist li::before {
            content: "â˜";
            position: absolute;
            left: 0;
            color: var(--accent-blue);
        }

        /* Algorithm Box */
        .algorithm-box {
            background: var(--bg-secondary);
            border: 2px solid var(--accent-green);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1rem 0;
        }

        .algorithm-box h4 {
            color: var(--accent-green);
            margin-bottom: 1rem;
            font-size: 1.3rem;
        }

        .step {
            display: flex;
            align-items: flex-start;
            margin-bottom: 0.8rem;
        }

        .step-number {
            background: var(--accent-blue);
            color: var(--bg-primary);
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 1rem;
            flex-shrink: 0;
        }

        /* Resource list */
        .resource-list {
            list-style: none;
            margin-left: 0;
        }

        .resource-list li {
            padding: 0.8rem 1rem;
            background: var(--bg-secondary);
            border-radius: 6px;
            margin-bottom: 0.5rem;
            border-left: 3px solid var(--accent-blue);
        }

        .resource-list li a {
            color: var(--accent-blue);
            text-decoration: none;
        }

        .resource-list li a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="progress-bar" id="progressBar"></div>
    
    <div class="slides-container" id="slidesContainer">
        
        <!-- Slide 1: Title -->
        <div class="slide title-slide active">
            <div class="week-badge">SÄ‚PTÄ‚MÃ‚NA 12</div>
            <h1>Grafuri â€” NoÈ›iuni Fundamentale</h1>
            <p class="subtitle">Graph Data Structures, BFS & DFS</p>
            <p class="course-info">Algoritmi È™i Tehnici de Programare</p>
            <p class="course-info">Academia de Studii Economice BucureÈ™ti â€” CSIE</p>
        </div>

        <!-- Slide 2: Learning Objectives -->
        <div class="slide">
            <h1>ğŸ¯ Obiective de ÃnvÄƒÈ›are</h1>
            <ul>
                <li><strong>ReÈ›ine:</strong> DefiniÈ›iile de graf orientat/neorientat, nod, muchie, arc, grad</li>
                <li><strong>ÃnÈ›elege:</strong> DiferenÈ›ele Ã®ntre matricea de adiacenÈ›Äƒ È™i listele de adiacenÈ›Äƒ</li>
                <li><strong>AplicÄƒ:</strong> ImplementeazÄƒ algoritmii BFS È™i DFS pentru parcurgerea grafurilor</li>
                <li><strong>AnalizeazÄƒ:</strong> ComparÄƒ complexitÄƒÈ›ile O(V+E) vs O(VÂ²) pentru diferite operaÈ›ii</li>
                <li><strong>EvalueazÄƒ:</strong> SelecteazÄƒ reprezentarea optimÄƒ Ã®n funcÈ›ie de caracteristicile grafului</li>
                <li><strong>CreeazÄƒ:</strong> ProiecteazÄƒ soluÈ›ii pentru probleme reale folosind grafuri</li>
            </ul>
            <div class="info-box note">
                <div class="info-box-title">ğŸ“‹ NotÄƒ</div>
                AceastÄƒ sÄƒptÄƒmÃ¢nÄƒ pune bazele pentru algoritmii avansaÈ›i pe grafuri (Dijkstra, Bellman-Ford, Floyd-Warshall) din sÄƒptÄƒmÃ¢na urmÄƒtoare.
            </div>
        </div>

        <!-- Slide 3: Historical Context -->
        <div class="slide">
            <h1>ğŸ“œ Context Istoric</h1>
            <h2>Cele È˜apte Poduri din KÃ¶nigsberg (1736)</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Problema</h3>
                    <p>Este posibil sÄƒ traversezi toate cele 7 poduri ale oraÈ™ului KÃ¶nigsberg exact o singurÄƒ datÄƒ È™i sÄƒ te Ã®ntorci la punctul de plecare?</p>
                    <div class="diagram-box">
     A â•â•â•â•â•â•â•â•â•â•â•â• B
      â•²  bridge  â•±
       â•²   1   â•±
        â•²    â•± 
    â•â•â•â•â•â•â•â•³â•â•â•â•â•â•â•
   2,3   â•±    â•²  4,5
      â•±        â•²
     C â•â•â•â•â•â•â•â•â•â• D
          6,7
                    </div>
                </div>
                <div class="column">
                    <h3>SoluÈ›ia lui Euler</h3>
                    <p><strong>Leonhard Euler</strong> a demonstrat cÄƒ este <span class="keyword">imposibil</span>.</p>
                    <p>Motivul: Un nod trebuie sÄƒ aibÄƒ grad par pentru a putea fi traversat (intrare + ieÈ™ire). Toate cele 4 zone aveau grad impar.</p>
                    <p>AceastÄƒ demonstraÈ›ie a fondat <span class="highlight">teoria grafurilor</span>.</p>
                </div>
            </div>
        </div>

        <!-- Slide 4: Key Figure - Euler -->
        <div class="slide">
            <h1>ğŸ‘¤ FigurÄƒ Cheie: Leonhard Euler</h1>
            <div class="two-columns">
                <div class="column">
                    <h3>Biografie (1707â€“1783)</h3>
                    <ul>
                        <li>Matematician È™i fizician elveÈ›ian</li>
                        <li>Unul dintre cei mai prolifici din istorie</li>
                        <li>ContribuÈ›ii Ã®n: calcul, teoria numerelor, mecanicÄƒ, opticÄƒ, astronomie</li>
                        <li>A lucrat la Academia din Sankt Petersburg È™i Berlin</li>
                        <li>A rÄƒmas productiv chiar È™i dupÄƒ ce a orbit</li>
                    </ul>
                </div>
                <div class="column">
                    <h3>ContribuÈ›ii la InformaticÄƒ</h3>
                    <ul>
                        <li>Fondator al teoriei grafurilor (1736)</li>
                        <li>Formula lui Euler pentru poliedre: V - E + F = 2</li>
                        <li>Ciclul/drumul eulerian</li>
                        <li>Baza pentru topologie</li>
                    </ul>
                    <div class="quote-box">
                        â€Pentru a ajunge la cunoaÈ™tere, trebuie sÄƒ studiezi; pentru a ajunge la Ã®nÈ›elepciune, trebuie sÄƒ observi."
                        <div class="quote-author">â€” Leonhard Euler</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 5: Graph Definition -->
        <div class="slide">
            <h1>ğŸ“ Ce Este un Graf?</h1>
            <h2>DefiniÈ›ie FormalÄƒ</h2>
            <p>Un <span class="keyword">graf</span> G = (V, E) este o structurÄƒ algebricÄƒ formatÄƒ din:</p>
            <ul>
                <li><strong>V</strong> (Vertices): MulÈ›imea nodurilor (vÃ¢rfurilor)</li>
                <li><strong>E</strong> (Edges): MulÈ›imea muchiilor care conecteazÄƒ perechi de noduri</li>
            </ul>
            <div class="two-columns">
                <div class="column">
                    <h3>Graf Neorientat</h3>
                    <div class="diagram-box">
       (A)â”€â”€â”€â”€â”€â”€â”€(B)
        â”‚â•²       â•±â”‚
        â”‚ â•²     â•± â”‚
        â”‚  â•²   â•±  â”‚
        â”‚   â•² â•±   â”‚
       (C)â”€â”€â”€(D)â”€â”€(E)
       
  Muchie {A,B}: fÄƒrÄƒ direcÈ›ie
  E = {{A,B}, {A,C}, {A,D}, ...}
                    </div>
                </div>
                <div class="column">
                    <h3>Graf Orientat (Digraf)</h3>
                    <div class="diagram-box">
       (A)â”€â”€â”€â”€â”€â”€â”€â†’(B)
        â”‚â•²       â†— â”‚
        â†“ â•²     â•±  â†“
        â”‚  â†˜   â•±   â”‚
        â”‚   â•² â•±    â”‚
       (C)â†â”€â”€(D)â”€â”€â†’(E)
       
  Arc (A,B): de la A spre B
  E = {(A,B), (A,C), (A,D), ...}
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 6: Terminology -->
        <div class="slide">
            <h1>ğŸ“– Terminologie EsenÈ›ialÄƒ</h1>
            <table>
                <tr>
                    <th>Termen</th>
                    <th>DefiniÈ›ie</th>
                    <th>Exemplu</th>
                </tr>
                <tr>
                    <td><strong>Grad (degree)</strong></td>
                    <td>NumÄƒrul de muchii incidente unui nod</td>
                    <td>grad(A) = 3</td>
                </tr>
                <tr>
                    <td><strong>Grad intrare (in-degree)</strong></td>
                    <td>Arce care intrÄƒ Ã®n nod (digraf)</td>
                    <td>gradâº(B) = 2</td>
                </tr>
                <tr>
                    <td><strong>Grad ieÈ™ire (out-degree)</strong></td>
                    <td>Arce care ies din nod (digraf)</td>
                    <td>gradâ»(A) = 3</td>
                </tr>
                <tr>
                    <td><strong>Drum (path)</strong></td>
                    <td>SecvenÈ›Äƒ de noduri conectate prin muchii</td>
                    <td>A â†’ B â†’ D â†’ E</td>
                </tr>
                <tr>
                    <td><strong>Ciclu (cycle)</strong></td>
                    <td>Drum care se Ã®ntoarce la nodul de start</td>
                    <td>A â†’ B â†’ D â†’ A</td>
                </tr>
                <tr>
                    <td><strong>Graf conex</strong></td>
                    <td>ExistÄƒ drum Ã®ntre oricare douÄƒ noduri</td>
                    <td>ComponentÄƒ unicÄƒ</td>
                </tr>
            </table>
        </div>

        <!-- Slide 7: Graph Types -->
        <div class="slide">
            <h1>ğŸ”· Tipuri de Grafuri</h1>
            <div class="two-columns">
                <div class="column">
                    <h3>DupÄƒ structurÄƒ</h3>
                    <ul>
                        <li><strong>Graf simplu:</strong> FÄƒrÄƒ bucle (self-loops) È™i fÄƒrÄƒ muchii multiple</li>
                        <li><strong>Multigraf:</strong> Permite muchii multiple Ã®ntre aceleaÈ™i noduri</li>
                        <li><strong>Graf complet Kâ‚™:</strong> Toate perechile conectate</li>
                        <li><strong>Graf bipartit:</strong> Nodurile Ã®n douÄƒ mulÈ›imi disjuncte</li>
                        <li><strong>Arbore:</strong> Graf conex aciclic</li>
                    </ul>
                </div>
                <div class="column">
                    <h3>DupÄƒ densitate</h3>
                    <ul>
                        <li><strong>Graf dens:</strong> |E| â‰ˆ |V|Â² (multe muchii)</li>
                        <li><strong>Graf rar (sparse):</strong> |E| << |V|Â² (puÈ›ine muchii)</li>
                    </ul>
                    <div class="info-box tip">
                        <div class="info-box-title">ğŸ’¡ RegulÄƒ practicÄƒ</div>
                        Graf complet: |E| = |V|(|V|-1)/2<br>
                        Graf rar: |E| = O(|V|)
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 8: Adjacency Matrix -->
        <div class="slide">
            <h1>ğŸ“Š Matricea de AdiacenÈ›Äƒ</h1>
            <div class="two-columns">
                <div class="column">
                    <h3>Reprezentare</h3>
                    <div class="diagram-box">
Graf:           Matrice:
  (0)â”€â”€(1)         0  1  2  3
   â”‚â•²  â”‚        0 [0, 1, 1, 0]
   â”‚ â•² â”‚        1 [1, 0, 1, 1]
  (2)â”€â”€(3)      2 [1, 1, 0, 1]
                3 [0, 1, 1, 0]
                
adj[i][j] = 1 dacÄƒ existÄƒ muchie
adj[i][j] = 0 altfel
                    </div>
                </div>
                <div class="column">
                    <h3>Caracteristici</h3>
                    <table>
                        <tr><th>OperaÈ›ie</th><th>Complexitate</th></tr>
                        <tr><td>SpaÈ›iu</td><td><span class="complexity">O(VÂ²)</span></td></tr>
                        <tr><td>VerificÄƒ muchie</td><td><span class="complexity">O(1)</span></td></tr>
                        <tr><td>AdaugÄƒ muchie</td><td><span class="complexity">O(1)</span></td></tr>
                        <tr><td>EnumerÄƒ vecini</td><td><span class="complexity">O(V)</span></td></tr>
                    </table>
                </div>
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>DeclaraÈ›ie Ã®n C</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">#define MAX_V 1000
int adj[MAX_V][MAX_V];  // Matricea de adiacenÈ›Äƒ
int n;                   // NumÄƒrul de noduri</code></pre>
            </div>
        </div>

        <!-- Slide 9: Adjacency Matrix Implementation -->
        <div class="slide">
            <h1>ğŸ’» Implementare Matrice de AdiacenÈ›Äƒ</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>OperaÈ›ii de bazÄƒ</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">// IniÈ›ializare graf cu n noduri
void init_graph(int n) {
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            adj[i][j] = 0;
}

// AdaugÄƒ muchie (graf neorientat)
void add_edge(int u, int v) {
    adj[u][v] = 1;
    adj[v][u] = 1;  // Simetric pentru graf neorientat
}

// VerificÄƒ existenÈ›a muchiei
int has_edge(int u, int v) {
    return adj[u][v];
}

// AfiÈ™eazÄƒ vecinii unui nod
void print_neighbors(int u, int n) {
    printf("Vecinii lui %d: ", u);
    for (int v = 0; v < n; v++)
        if (adj[u][v])
            printf("%d ", v);
    printf("\n");
}</code></pre>
            </div>
        </div>

        <!-- Slide 10: Adjacency List -->
        <div class="slide">
            <h1>ğŸ“‹ Liste de AdiacenÈ›Äƒ</h1>
            <div class="two-columns">
                <div class="column">
                    <h3>Reprezentare</h3>
                    <div class="diagram-box">
Graf:           Liste:
  (0)â”€â”€(1)      0 â†’ [1] â†’ [2]
   â”‚â•²  â”‚        1 â†’ [0] â†’ [2] â†’ [3]
   â”‚ â•² â”‚        2 â†’ [0] â†’ [1] â†’ [3]
  (2)â”€â”€(3)      3 â†’ [1] â†’ [2]

Fiecare nod are o listÄƒ
a vecinilor sÄƒi
                    </div>
                </div>
                <div class="column">
                    <h3>Caracteristici</h3>
                    <table>
                        <tr><th>OperaÈ›ie</th><th>Complexitate</th></tr>
                        <tr><td>SpaÈ›iu</td><td><span class="complexity">O(V + E)</span></td></tr>
                        <tr><td>VerificÄƒ muchie</td><td><span class="complexity">O(grad(v))</span></td></tr>
                        <tr><td>AdaugÄƒ muchie</td><td><span class="complexity">O(1)</span></td></tr>
                        <tr><td>EnumerÄƒ vecini</td><td><span class="complexity">O(grad(v))</span></td></tr>
                    </table>
                </div>
            </div>
            <div class="info-box tip">
                <div class="info-box-title">ğŸ’¡ Avantaj major</div>
                Pentru grafuri rare (sparse), listele economisesc memorie semnificativ: O(V + E) vs O(VÂ²)
            </div>
        </div>

        <!-- Slide 11: Adjacency List Implementation -->
        <div class="slide">
            <h1>ğŸ’» Implementare Liste de AdiacenÈ›Äƒ</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>Structuri de date</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">// Nod Ã®n lista de adiacenÈ›Äƒ
typedef struct Node {
    int vertex;           // Indicele nodului vecin
    struct Node* next;    // Pointer cÄƒtre urmÄƒtorul vecin
} Node;

// Structura grafului
typedef struct Graph {
    int numVertices;      // NumÄƒrul de noduri
    Node** adjLists;      // Array de liste de adiacenÈ›Äƒ
    int* visited;         // Array pentru marcarea vizitÄƒrii
} Graph;

// Creare nod nou
Node* create_node(int v) {
    Node* newNode = malloc(sizeof(Node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}

// Creare graf
Graph* create_graph(int vertices) {
    Graph* graph = malloc(sizeof(Graph));
    graph->numVertices = vertices;
    graph->adjLists = malloc(vertices * sizeof(Node*));
    graph->visited = malloc(vertices * sizeof(int));
    
    for (int i = 0; i < vertices; i++) {
        graph->adjLists[i] = NULL;
        graph->visited[i] = 0;
    }
    return graph;
}</code></pre>
            </div>
        </div>

        <!-- Slide 12: Add Edge to List -->
        <div class="slide">
            <h1>ğŸ’» AdÄƒugare Muchie Ã®n Liste</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>FuncÈ›ia add_edge pentru liste de adiacenÈ›Äƒ</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">// AdaugÄƒ muchie la graf neorientat
void add_edge(Graph* graph, int src, int dest) {
    // AdaugÄƒ muchie de la src la dest
    Node* newNode = create_node(dest);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;
    
    // AdaugÄƒ muchie de la dest la src (graf neorientat)
    newNode = create_node(src);
    newNode->next = graph->adjLists[dest];
    graph->adjLists[dest] = newNode;
}

// AfiÈ™are graf
void print_graph(Graph* graph) {
    for (int v = 0; v < graph->numVertices; v++) {
        Node* temp = graph->adjLists[v];
        printf("Nod %d: ", v);
        while (temp) {
            printf("%d -> ", temp->vertex);
            temp = temp->next;
        }
        printf("NULL\n");
    }
}</code></pre>
            </div>
            <div class="info-box warning">
                <div class="info-box-title">âš ï¸ AtenÈ›ie</div>
                Inserarea la Ã®nceput (O(1)) inverseazÄƒ ordinea. Pentru ordine specificÄƒ, inseraÈ›i la final sau sortaÈ›i.
            </div>
        </div>

        <!-- Slide 13: Comparison Table -->
        <div class="slide">
            <h1>âš–ï¸ ComparaÈ›ie: Matrice vs Liste</h1>
            <table>
                <tr>
                    <th>Criteriu</th>
                    <th>Matrice de AdiacenÈ›Äƒ</th>
                    <th>Liste de AdiacenÈ›Äƒ</th>
                </tr>
                <tr>
                    <td>SpaÈ›iu</td>
                    <td><span class="complexity">O(VÂ²)</span></td>
                    <td><span class="complexity">O(V + E)</span></td>
                </tr>
                <tr>
                    <td>Verificare muchie (u,v)</td>
                    <td><span class="complexity">O(1)</span> âœ…</td>
                    <td><span class="complexity">O(grad(u))</span></td>
                </tr>
                <tr>
                    <td>AdÄƒugare muchie</td>
                    <td><span class="complexity">O(1)</span></td>
                    <td><span class="complexity">O(1)</span></td>
                </tr>
                <tr>
                    <td>È˜tergere muchie</td>
                    <td><span class="complexity">O(1)</span></td>
                    <td><span class="complexity">O(grad(v))</span></td>
                </tr>
                <tr>
                    <td>Enumerare vecini</td>
                    <td><span class="complexity">O(V)</span></td>
                    <td><span class="complexity">O(grad(v))</span> âœ…</td>
                </tr>
                <tr>
                    <td>BFS/DFS complet</td>
                    <td><span class="complexity">O(VÂ²)</span></td>
                    <td><span class="complexity">O(V + E)</span> âœ…</td>
                </tr>
            </table>
            <div class="info-box note">
                <div class="info-box-title">ğŸ“Š Concluzie</div>
                <strong>Matrice:</strong> Grafuri dense, verificÄƒri frecvente de muchii<br>
                <strong>Liste:</strong> Grafuri rare, parcurgeri frecvente (majoritatea aplicaÈ›iilor reale)
            </div>
        </div>

        <!-- Slide 14: BFS Introduction -->
        <div class="slide">
            <h1>ğŸŒŠ BFS â€” Breadth-First Search</h1>
            <h2>Parcurgerea Ã®n LÄƒÈ›ime</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Principiu</h3>
                    <p>ExploreazÄƒ graful <span class="keyword">nivel cu nivel</span>, pornind de la nodul sursÄƒ:</p>
                    <ol>
                        <li>ViziteazÄƒ toate nodurile la distanÈ›Äƒ 1</li>
                        <li>Apoi toate nodurile la distanÈ›Äƒ 2</li>
                        <li>È˜i aÈ™a mai departe...</li>
                    </ol>
                    <p>FoloseÈ™te o <span class="keyword">coadÄƒ (queue)</span> FIFO.</p>
                </div>
                <div class="column">
                    <h3>Vizualizare</h3>
                    <div class="diagram-box">
Nivel 0:    [A]        Start
             â†“
Nivel 1:  [B] [C]      DistanÈ›Äƒ 1
           â†“   â†“
Nivel 2: [D] [E] [F]   DistanÈ›Äƒ 2
           â†“
Nivel 3:  [G]          DistanÈ›Äƒ 3

Ordinea vizitÄƒrii:
A â†’ B â†’ C â†’ D â†’ E â†’ F â†’ G
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 15: BFS Algorithm -->
        <div class="slide">
            <h1>ğŸ“ Algoritmul BFS</h1>
            <div class="algorithm-box">
                <h4>BFS(Graf G, Nod sursÄƒ s)</h4>
                <div class="step">
                    <div class="step-number">1</div>
                    <div>CreeazÄƒ o coadÄƒ Q goalÄƒ</div>
                </div>
                <div class="step">
                    <div class="step-number">2</div>
                    <div>MarcheazÄƒ nodul sursÄƒ s ca vizitat</div>
                </div>
                <div class="step">
                    <div class="step-number">3</div>
                    <div>AdaugÄƒ s Ã®n coada Q (enqueue)</div>
                </div>
                <div class="step">
                    <div class="step-number">4</div>
                    <div>CÃ‚T TIMP Q nu este goalÄƒ:
                        <ul>
                            <li>u = scoate primul element din Q (dequeue)</li>
                            <li>ProceseazÄƒ nodul u</li>
                            <li>PENTRU fiecare vecin v al lui u:
                                <ul>
                                    <li>DACÄ‚ v nu este vizitat:
                                        <ul>
                                            <li>MarcheazÄƒ v ca vizitat</li>
                                            <li>AdaugÄƒ v Ã®n Q</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
            <p><strong>Complexitate:</strong> <span class="complexity">O(V + E)</span> cu liste de adiacenÈ›Äƒ</p>
        </div>

        <!-- Slide 16: BFS Implementation -->
        <div class="slide">
            <h1>ğŸ’» Implementare BFS</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>BFS cu coadÄƒ Ã®n C</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void bfs(Graph* graph, int startVertex) {
    // CoadÄƒ simplÄƒ cu array
    int queue[MAX_V];
    int front = 0, rear = 0;
    
    // MarcheazÄƒ start È™i adaugÄƒ Ã®n coadÄƒ
    graph->visited[startVertex] = 1;
    queue[rear++] = startVertex;
    
    while (front < rear) {
        // Scoate din coadÄƒ (dequeue)
        int currentVertex = queue[front++];
        printf("Vizitat: %d\n", currentVertex);
        
        // Parcurge toÈ›i vecinii
        Node* temp = graph->adjLists[currentVertex];
        while (temp) {
            int adjVertex = temp->vertex;
            
            if (graph->visited[adjVertex] == 0) {
                graph->visited[adjVertex] = 1;
                queue[rear++] = adjVertex;  // Enqueue
            }
            temp = temp->next;
        }
    }
}</code></pre>
            </div>
        </div>

        <!-- Slide 17: BFS with Distance -->
        <div class="slide">
            <h1>ğŸ“ BFS cu Calculul DistanÈ›elor</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>BFS care calculeazÄƒ distanÈ›a de la sursÄƒ</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void bfs_distance(Graph* graph, int start, int* dist, int* parent) {
    int queue[MAX_V];
    int front = 0, rear = 0;
    
    // IniÈ›ializare
    for (int i = 0; i < graph->numVertices; i++) {
        dist[i] = -1;      // -1 = neatins
        parent[i] = -1;    // -1 = fÄƒrÄƒ pÄƒrinte
    }
    
    dist[start] = 0;
    queue[rear++] = start;
    
    while (front < rear) {
        int u = queue[front++];
        
        Node* temp = graph->adjLists[u];
        while (temp) {
            int v = temp->vertex;
            if (dist[v] == -1) {        // Nevizitat
                dist[v] = dist[u] + 1;  // DistanÈ›a = pÄƒrintele + 1
                parent[v] = u;          // PÄƒrintele pe drumul minim
                queue[rear++] = v;
            }
            temp = temp->next;
        }
    }
}</code></pre>
            </div>
            <div class="info-box tip">
                <div class="info-box-title">ğŸ’¡ AplicaÈ›ie</div>
                Array-ul <code>parent[]</code> permite reconstrucÈ›ia drumului minim de la sursÄƒ la orice nod.
            </div>
        </div>

        <!-- Slide 18: DFS Introduction -->
        <div class="slide">
            <h1>ğŸŒ² DFS â€” Depth-First Search</h1>
            <h2>Parcurgerea Ã®n AdÃ¢ncime</h2>
            <div class="two-columns">
                <div class="column">
                    <h3>Principiu</h3>
                    <p>ExploreazÄƒ <span class="keyword">cÃ¢t mai adÃ¢nc</span> posibil Ã®nainte de backtracking:</p>
                    <ol>
                        <li>ViziteazÄƒ un nod</li>
                        <li>Merge la primul vecin nevizitat</li>
                        <li>RepetÄƒ pÃ¢nÄƒ nu mai sunt vecini</li>
                        <li>Backtrack È™i Ã®ncearcÄƒ alt vecin</li>
                    </ol>
                    <p>FoloseÈ™te <span class="keyword">recursivitate</span> sau <span class="keyword">stivÄƒ (stack)</span> LIFO.</p>
                </div>
                <div class="column">
                    <h3>Vizualizare</h3>
                    <div class="diagram-box">
        [A]
       â•±   â•²
     [B]   [C]
     â•±       â•²
   [D]       [E]
   â•±
 [F]

Ordinea DFS (pre-order):
A â†’ B â†’ D â†’ F â†’ (back) â†’ (back)
â†’ C â†’ E

Stack: A â†’ AB â†’ ABD â†’ ABDF
       â†’ ABD â†’ AB â†’ A â†’ AC â†’ ACE
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 19: DFS Recursive -->
        <div class="slide">
            <h1>ğŸ’» DFS Recursiv</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>Implementare recursivÄƒ elegantÄƒ</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">// FuncÈ›ia recursivÄƒ DFS
void dfs_recursive(Graph* graph, int vertex) {
    // MarcheazÄƒ nodul curent ca vizitat
    graph->visited[vertex] = 1;
    printf("Vizitat: %d\n", vertex);
    
    // Parcurge toÈ›i vecinii
    Node* temp = graph->adjLists[vertex];
    while (temp) {
        int adjVertex = temp->vertex;
        
        // DacÄƒ vecinul nu a fost vizitat, apeleazÄƒ recursiv
        if (graph->visited[adjVertex] == 0) {
            dfs_recursive(graph, adjVertex);
        }
        temp = temp->next;
    }
}

// FuncÈ›ia wrapper pentru a iniÈ›ia DFS
void dfs(Graph* graph, int startVertex) {
    // ReseteazÄƒ array-ul visited
    for (int i = 0; i < graph->numVertices; i++) {
        graph->visited[i] = 0;
    }
    
    dfs_recursive(graph, startVertex);
}</code></pre>
            </div>
        </div>

        <!-- Slide 20: DFS Iterative -->
        <div class="slide">
            <h1>ğŸ’» DFS Iterativ cu StivÄƒ</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>DFS fÄƒrÄƒ recursivitate (evitÄƒ stack overflow)</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void dfs_iterative(Graph* graph, int startVertex) {
    // StivÄƒ implementatÄƒ cu array
    int stack[MAX_V];
    int top = -1;
    
    // Push start pe stivÄƒ
    stack[++top] = startVertex;
    
    while (top >= 0) {
        // Pop din stivÄƒ
        int currentVertex = stack[top--];
        
        // Skip dacÄƒ deja vizitat
        if (graph->visited[currentVertex])
            continue;
            
        // MarcheazÄƒ È™i proceseazÄƒ
        graph->visited[currentVertex] = 1;
        printf("Vizitat: %d\n", currentVertex);
        
        // AdaugÄƒ vecinii nevizitaÈ›i pe stivÄƒ
        Node* temp = graph->adjLists[currentVertex];
        while (temp) {
            if (!graph->visited[temp->vertex]) {
                stack[++top] = temp->vertex;
            }
            temp = temp->next;
        }
    }
}</code></pre>
            </div>
            <div class="info-box warning">
                <div class="info-box-title">âš ï¸ NotÄƒ</div>
                Versiunea iterativÄƒ poate produce o ordine diferitÄƒ de vizitare decÃ¢t cea recursivÄƒ.
            </div>
        </div>

        <!-- Slide 21: BFS vs DFS -->
        <div class="slide">
            <h1>âš”ï¸ BFS vs DFS â€” CÃ¢nd sÄƒ foloseÈ™ti fiecare?</h1>
            <table>
                <tr>
                    <th>Criteriu</th>
                    <th>BFS</th>
                    <th>DFS</th>
                </tr>
                <tr>
                    <td>StructurÄƒ de date</td>
                    <td>CoadÄƒ (FIFO)</td>
                    <td>StivÄƒ/Recursie (LIFO)</td>
                </tr>
                <tr>
                    <td>Explorare</td>
                    <td>Pe nivele (lÄƒÈ›ime)</td>
                    <td>Pe ramuri (adÃ¢ncime)</td>
                </tr>
                <tr>
                    <td>Drum minim</td>
                    <td>âœ… Garantat (neponderat)</td>
                    <td>âŒ Nu garanteazÄƒ</td>
                </tr>
                <tr>
                    <td>Memorie</td>
                    <td>O(V) â€” poate fi mare</td>
                    <td>O(h) â€” Ã®nÄƒlÈ›imea</td>
                </tr>
                <tr>
                    <td>Complexitate</td>
                    <td>O(V + E)</td>
                    <td>O(V + E)</td>
                </tr>
            </table>
            <div class="two-columns">
                <div class="column">
                    <h3>FoloseÈ™te BFS pentru:</h3>
                    <ul>
                        <li>Drumuri minime (neponderate)</li>
                        <li>Explorare pe niveluri</li>
                        <li>GÄƒsirea vecinilor apropiaÈ›i</li>
                        <li>Verificarea bipartitismului</li>
                    </ul>
                </div>
                <div class="column">
                    <h3>FoloseÈ™te DFS pentru:</h3>
                    <ul>
                        <li>Detectarea ciclurilor</li>
                        <li>Sortare topologicÄƒ</li>
                        <li>Componente conexe</li>
                        <li>Backtracking, labirinturi</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 22: Connected Components -->
        <div class="slide">
            <h1>ğŸ”— Componente Conexe</h1>
            <div class="two-columns">
                <div class="column">
                    <h3>DefiniÈ›ie</h3>
                    <p>O <span class="keyword">componentÄƒ conexÄƒ</span> este o submulÈ›ime maximalÄƒ de noduri Ã®n care existÄƒ drum Ã®ntre oricare douÄƒ noduri.</p>
                    <div class="diagram-box">
Componenta 1:    Componenta 2:
   (0)-(1)          (4)-(5)
    |   |            |
   (2)-(3)          (6)

Graf cu 2 componente conexe
                    </div>
                </div>
                <div class="column">
                    <h3>Algoritm</h3>
                    <div class="algorithm-box">
                        <h4>GÄƒsire Componente</h4>
                        <div class="step">
                            <div class="step-number">1</div>
                            <div>componentÄƒ = 0</div>
                        </div>
                        <div class="step">
                            <div class="step-number">2</div>
                            <div>PENTRU fiecare nod v:
                                <ul>
                                    <li>DACÄ‚ v nevizitat:
                                        <ul>
                                            <li>componentÄƒ++</li>
                                            <li>BFS/DFS(v) â€” marcheazÄƒ toÈ›i nodurile accesibile</li>
                                        </ul>
                                    </li>
                                </ul>
                            </div>
                        </div>
                        <div class="step">
                            <div class="step-number">3</div>
                            <div>ReturneazÄƒ componentÄƒ</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 23: Connected Components Implementation -->
        <div class="slide">
            <h1>ğŸ’» Implementare Componente Conexe</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>NumÄƒrÄƒ È™i afiÈ™eazÄƒ componentele conexe</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">int count_components(Graph* graph) {
    int count = 0;
    
    // ReseteazÄƒ visited
    for (int i = 0; i < graph->numVertices; i++) {
        graph->visited[i] = 0;
    }
    
    // Pentru fiecare nod nevizitat, porneÈ™te un BFS/DFS
    for (int v = 0; v < graph->numVertices; v++) {
        if (!graph->visited[v]) {
            count++;
            printf("Componenta %d: ", count);
            bfs_component(graph, v);  // sau dfs_component
            printf("\n");
        }
    }
    
    return count;
}

// BFS care afiÈ™eazÄƒ nodurile din componentÄƒ
void bfs_component(Graph* graph, int start) {
    int queue[MAX_V];
    int front = 0, rear = 0;
    
    graph->visited[start] = 1;
    queue[rear++] = start;
    
    while (front < rear) {
        int u = queue[front++];
        printf("%d ", u);
        
        Node* temp = graph->adjLists[u];
        while (temp) {
            if (!graph->visited[temp->vertex]) {
                graph->visited[temp->vertex] = 1;
                queue[rear++] = temp->vertex;
            }
            temp = temp->next;
        }
    }
}</code></pre>
            </div>
        </div>

        <!-- Slide 24: Cycle Detection -->
        <div class="slide">
            <h1>ğŸ”„ Detectarea Ciclurilor</h1>
            <div class="two-columns">
                <div class="column">
                    <h3>Graf Neorientat</h3>
                    <p>Ãn DFS, dacÄƒ gÄƒsim un vecin vizitat care <strong>nu este pÄƒrintele</strong> nodului curent â†’ <span class="keyword">ciclu</span>.</p>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Detectare ciclu</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">int has_cycle_undirected(Graph* g, 
                         int v, int parent) {
    g->visited[v] = 1;
    
    Node* temp = g->adjLists[v];
    while (temp) {
        int adj = temp->vertex;
        if (!g->visited[adj]) {
            if (has_cycle_undirected(g, adj, v))
                return 1;
        } else if (adj != parent) {
            return 1; // Ciclu gÄƒsit!
        }
        temp = temp->next;
    }
    return 0;
}</code></pre>
                    </div>
                </div>
                <div class="column">
                    <h3>Graf Orientat</h3>
                    <p>Folosim colorare cu 3 culori:</p>
                    <ul>
                        <li><strong>ALB (0):</strong> Nevizitat</li>
                        <li><strong>GRI (1):</strong> Ãn procesare</li>
                        <li><strong>NEGRU (2):</strong> Finalizat</li>
                    </ul>
                    <p>DacÄƒ gÄƒsim un nod GRI â†’ <span class="keyword">back edge</span> â†’ ciclu!</p>
                    <div class="info-box note">
                        <div class="info-box-title">ğŸ“Œ Important</div>
                        Ciclurile Ã®n grafuri orientate sunt esenÈ›iale pentru sortarea topologicÄƒ â€” un graf cu cicluri nu poate fi sortat topologic.
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 25: Common Mistakes -->
        <div class="slide">
            <h1>âš ï¸ GreÈ™eli Comune</h1>
            <div class="info-box danger">
                <div class="info-box-title">âŒ Eroare 1: Uitarea marcÄƒrii ca vizitat ÃNAINTE de enqueue</div>
                <p>DacÄƒ marcÄƒm <em>dupÄƒ</em> ce scoatem din coadÄƒ, acelaÈ™i nod poate fi adÄƒugat de mai multe ori.</p>
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>GreÈ™it vs Corect</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">// âŒ GREÈ˜IT - poate adÄƒuga duplicat
if (!visited[v]) {
    queue[rear++] = v;
}
// ... mai tÃ¢rziu
visited[current] = 1;  // Prea tÃ¢rziu!

// âœ… CORECT - marcÄƒm imediat
if (!visited[v]) {
    visited[v] = 1;     // MarcÄƒm ACUM
    queue[rear++] = v;
}</code></pre>
            </div>
            <div class="info-box danger">
                <div class="info-box-title">âŒ Eroare 2: Memory leak la eliberarea grafului</div>
                <p>Trebuie eliberate toate nodurile din fiecare listÄƒ, apoi array-urile, apoi structura.</p>
            </div>
            <div class="info-box danger">
                <div class="info-box-title">âŒ Eroare 3: Stack overflow la DFS recursiv pe grafuri mari</div>
                <p>SoluÈ›ie: FolosiÈ›i DFS iterativ cu stivÄƒ explicitÄƒ pentru grafuri cu mii de noduri.</p>
            </div>
        </div>

        <!-- Slide 26: Memory Diagram -->
        <div class="slide">
            <h1>ğŸ§  Model de Memorie</h1>
            <div class="diagram-box">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          HEAP                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Graph struct:                     Liste de adiacenÈ›Äƒ:          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                               â”‚
â”‚  â”‚ numVertices  â”‚â”€â”€â”€â†’ 5            adjLists[0] â†’ [1]â†’[2]â†’NULL   â”‚
â”‚  â”‚ *adjLists    â”‚â”€â”€â”€â”              adjLists[1] â†’ [0]â†’[2]â†’NULL   â”‚
â”‚  â”‚ *visited     â”‚â”€â”€â”€â”¼â”€â”€â”           adjLists[2] â†’ [0]â†’[1]â†’[3]    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚           adjLists[3] â†’ [2]â†’[4]â†’NULL   â”‚
â”‚                     â”‚  â”‚           adjLists[4] â†’ [3]â†’NULL       â”‚
â”‚                     â–¼  â”‚                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚                                         â”‚
â”‚  â”‚ [0][1][2][3][4] â”‚  â”‚           Node struct:                  â”‚
â”‚  â”‚  â†“  â†“  â†“  â†“  â†“  â”‚  â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚           â”‚ vertex  â”‚                   â”‚
â”‚         adjLists      â”‚           â”‚ *next   â”‚â”€â”€â”€â†’ (next Node)   â”‚
â”‚                       â–¼           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                        â”‚
â”‚  â”‚ [0][0][1][0][0]     â”‚  visited array                         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                        â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          STACK                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  main()                                                         â”‚
â”‚    â””â”€ Graph* graph = create_graph(5);                           â”‚
â”‚         â””â”€ bfs(graph, 0);                                       â”‚
â”‚              â””â”€ queue[MAX_V], front, rear                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
        </div>

        <!-- Slide 27: Memory Deallocation -->
        <div class="slide">
            <h1>ğŸ—‘ï¸ Eliberarea CorectÄƒ a Memoriei</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>FuncÈ›ia free_graph - evitaÈ›i memory leaks!</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void free_graph(Graph* graph) {
    if (graph == NULL) return;
    
    // Pasul 1: ElibereazÄƒ fiecare listÄƒ de adiacenÈ›Äƒ
    for (int v = 0; v < graph->numVertices; v++) {
        Node* current = graph->adjLists[v];
        while (current != NULL) {
            Node* temp = current;
            current = current->next;
            free(temp);  // ElibereazÄƒ fiecare nod
        }
    }
    
    // Pasul 2: ElibereazÄƒ array-ul de liste
    free(graph->adjLists);
    
    // Pasul 3: ElibereazÄƒ array-ul visited
    free(graph->visited);
    
    // Pasul 4: ElibereazÄƒ structura Graph
    free(graph);
}

// Utilizare cu Valgrind pentru verificare:
// valgrind --leak-check=full ./program</code></pre>
            </div>
            <div class="info-box tip">
                <div class="info-box-title">ğŸ’¡ Best Practice</div>
                Ãntotdeauna verificaÈ›i cu <code>valgrind</code> cÄƒ nu aveÈ›i memory leaks. Output-ul ideal: <code>All heap blocks were freed -- no leaks are possible</code>
            </div>
        </div>

        <!-- Slide 28: Debugging with GDB -->
        <div class="slide">
            <h1>ğŸ” Debugging cu GDB</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>Comenzi utile GDB pentru debugging grafuri</span>
                    <span class="lang-badge">bash</span>
                </div>
                <pre><code class="language-bash"># Compilare cu simboluri de debug
gcc -g -Wall -o program program.c

# Pornire GDB
gdb ./program

# Comenzi de bazÄƒ
(gdb) break bfs           # Breakpoint la funcÈ›ia bfs
(gdb) break program.c:42  # Breakpoint la linia 42
(gdb) run                 # RuleazÄƒ programul
(gdb) next                # Pasul urmÄƒtor (n)
(gdb) step                # IntrÄƒ Ã®n funcÈ›ie (s)
(gdb) print graph->numVertices  # AfiÈ™eazÄƒ valoare
(gdb) print *graph        # DereferenÈ›iazÄƒ pointer

# Pentru liste Ã®nlÄƒnÈ›uite
(gdb) print graph->adjLists[0]->vertex
(gdb) print graph->adjLists[0]->next->vertex

# AfiÈ™are array
(gdb) print *queue@10     # Primele 10 elemente din queue
(gdb) print visited[0]@5  # Primele 5 elemente din visited

# Continuare È™i oprire
(gdb) continue            # ContinuÄƒ execuÈ›ia (c)
(gdb) quit                # IeÈ™ire (q)</code></pre>
            </div>
        </div>

        <!-- Slide 29: Valgrind -->
        <div class="slide">
            <h1>ğŸ”¬ Verificare Memorie cu Valgrind</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>Utilizare Valgrind</span>
                    <span class="lang-badge">bash</span>
                </div>
                <pre><code class="language-bash"># Verificare memory leaks
valgrind --leak-check=full ./program

# Output ideal:
# ==12345== HEAP SUMMARY:
# ==12345==     in use at exit: 0 bytes in 0 blocks
# ==12345==   total heap usage: 42 allocs, 42 frees, 1,024 bytes allocated
# ==12345== 
# ==12345== All heap blocks were freed -- no leaks are possible

# Probleme comune detectate:
# - "definitely lost" - memorie niciodatÄƒ eliberatÄƒ
# - "Invalid read/write" - acces Ã®n afara buffer-ului
# - "Use of uninitialised value" - variabilÄƒ neiniÈ›ializatÄƒ</code></pre>
            </div>
            <div class="info-box warning">
                <div class="info-box-title">âš ï¸ Erori frecvente</div>
                <ul>
                    <li><strong>Invalid read of size 4:</strong> AccesaÈ›i memorie eliberatÄƒ sau nealocatÄƒ</li>
                    <li><strong>Conditional jump depends on uninitialised:</strong> FolosiÈ›i o variabilÄƒ neiniÈ›ializatÄƒ</li>
                    <li><strong>Definitely lost:</strong> Nu aÈ›i apelat free() pentru memoria alocatÄƒ</li>
                </ul>
            </div>
        </div>

        <!-- Slide 30: Best Practices -->
        <div class="slide">
            <h1>âœ… Best Practices</h1>
            <div class="two-columns">
                <div class="column" style="background: rgba(63, 185, 80, 0.1); border-color: var(--accent-green);">
                    <h3 style="color: var(--accent-green);">âœ“ DO's</h3>
                    <ul>
                        <li>MarcaÈ›i nodurile ca vizitate <strong>Ã®nainte</strong> de a le adÄƒuga Ã®n coadÄƒ/stivÄƒ</li>
                        <li>VerificaÈ›i dacÄƒ malloc() returneazÄƒ NULL</li>
                        <li>EliberaÈ›i memoria Ã®n ordine inversÄƒ alocÄƒrii</li>
                        <li>FolosiÈ›i constante pentru dimensiuni (MAX_V)</li>
                        <li>IniÈ›ializaÈ›i toate variabilele</li>
                        <li>TestaÈ›i cu Valgrind Ã®nainte de predare</li>
                        <li>ComentaÈ›i codul complex</li>
                    </ul>
                </div>
                <div class="column" style="background: rgba(248, 81, 73, 0.1); border-color: var(--accent-red);">
                    <h3 style="color: var(--accent-red);">âœ— DON'Ts</h3>
                    <ul>
                        <li>Nu folosiÈ›i DFS recursiv pentru grafuri foarte mari</li>
                        <li>Nu uitaÈ›i sÄƒ resetaÈ›i visited[] Ã®ntre parcurgeri</li>
                        <li>Nu presupuneÈ›i cÄƒ graful este conex</li>
                        <li>Nu accesaÈ›i memoria dupÄƒ free()</li>
                        <li>Nu ignoraÈ›i warning-urile compilatorului</li>
                        <li>Nu hardcodaÈ›i dimensiunile</li>
                        <li>Nu returnaÈ›i pointeri la variabile locale</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 31: Applications -->
        <div class="slide">
            <h1>ğŸ­ AplicaÈ›ii Ã®n Lumea RealÄƒ</h1>
            <div class="takeaway-grid">
                <div class="takeaway-card">
                    <div class="icon">ğŸŒ</div>
                    <h3>ReÈ›ele Sociale</h3>
                    <p>RecomandÄƒri de prieteni, comunitÄƒÈ›i, influenceri</p>
                </div>
                <div class="takeaway-card">
                    <div class="icon">ğŸ—ºï¸</div>
                    <h3>NavigaÈ›ie GPS</h3>
                    <p>Rute optime, evitare trafic, ETA</p>
                </div>
                <div class="takeaway-card">
                    <div class="icon">ğŸ”§</div>
                    <h3>Compilatoare</h3>
                    <p>DependenÈ›e, ordine de build, optimizÄƒri</p>
                </div>
                <div class="takeaway-card">
                    <div class="icon">ğŸŒ</div>
                    <h3>Internet Routing</h3>
                    <p>BGP, OSPF, cÄƒi optime Ã®ntre routere</p>
                </div>
                <div class="takeaway-card">
                    <div class="icon">ğŸ›’</div>
                    <h3>RecomandÄƒri</h3>
                    <p>Amazon, Netflix â€” grafuri bipartite</p>
                </div>
                <div class="takeaway-card">
                    <div class="icon">ğŸ§¬</div>
                    <h3>BioinformaticÄƒ</h3>
                    <p>ReÈ›ele de proteine, analiza genomului</p>
                </div>
            </div>
        </div>

        <!-- Slide 32: Reading Files -->
        <div class="slide">
            <h1>ğŸ“ Citirea Grafului din FiÈ™ier</h1>
            <div class="two-columns">
                <div class="column">
                    <h3>Format fiÈ™ier</h3>
                    <div class="diagram-box">
5 7          â† N noduri, M muchii
0 1          â† muchie Ã®ntre 0 È™i 1
0 2
1 2
1 3
2 3
2 4
3 4
                    </div>
                </div>
                <div class="column">
                    <div class="code-block">
                        <div class="code-header">
                            <span>Citire graf</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">Graph* read_graph(const char* filename) {
    FILE* f = fopen(filename, "r");
    if (!f) {
        perror("Eroare deschidere");
        return NULL;
    }
    
    int n, m;
    fscanf(f, "%d %d", &n, &m);
    
    Graph* g = create_graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        fscanf(f, "%d %d", &u, &v);
        add_edge(g, u, v);
    }
    
    fclose(f);
    return g;
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 33: Complexity Summary -->
        <div class="slide">
            <h1>ğŸ“Š Rezumat ComplexitÄƒÈ›i</h1>
            <table>
                <tr>
                    <th>Algoritm/OperaÈ›ie</th>
                    <th>Timp</th>
                    <th>SpaÈ›iu</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td>Creare graf (liste)</td>
                    <td><span class="complexity">O(V)</span></td>
                    <td><span class="complexity">O(V)</span></td>
                    <td>Doar structura, fÄƒrÄƒ muchii</td>
                </tr>
                <tr>
                    <td>AdÄƒugare muchie</td>
                    <td><span class="complexity">O(1)</span></td>
                    <td><span class="complexity">O(1)</span></td>
                    <td>Inserare la Ã®nceput</td>
                </tr>
                <tr>
                    <td>BFS complet</td>
                    <td><span class="complexity">O(V + E)</span></td>
                    <td><span class="complexity">O(V)</span></td>
                    <td>CoadÄƒ + visited</td>
                </tr>
                <tr>
                    <td>DFS complet</td>
                    <td><span class="complexity">O(V + E)</span></td>
                    <td><span class="complexity">O(V)</span></td>
                    <td>StivÄƒ/recursie + visited</td>
                </tr>
                <tr>
                    <td>Componente conexe</td>
                    <td><span class="complexity">O(V + E)</span></td>
                    <td><span class="complexity">O(V)</span></td>
                    <td>Un BFS/DFS per componentÄƒ</td>
                </tr>
                <tr>
                    <td>Detectare ciclu</td>
                    <td><span class="complexity">O(V + E)</span></td>
                    <td><span class="complexity">O(V)</span></td>
                    <td>DFS modificat</td>
                </tr>
            </table>
            <div class="info-box note">
                <div class="info-box-title">ğŸ“Œ ObservaÈ›ie cheie</div>
                Pentru grafuri rare (E â‰ˆ V), complexitatea O(V + E) â‰ˆ O(V). Pentru grafuri dense (E â‰ˆ VÂ²), O(V + E) â‰ˆ O(VÂ²).
            </div>
        </div>

        <!-- Slide 34: Lab Preview -->
        <div class="slide">
            <h1>ğŸ”¬ Previzualizare Laborator</h1>
            <div class="two-columns">
                <div class="column">
                    <h3>ExerciÈ›iu 1: Graf cu Liste</h3>
                    <p><strong>Obiectiv:</strong> Implementarea structurii de date pentru grafuri cu liste de adiacenÈ›Äƒ.</p>
                    <ul>
                        <li>Creare È™i iniÈ›ializare graf</li>
                        <li>AdÄƒugare muchii</li>
                        <li>AfiÈ™are structurÄƒ</li>
                        <li>Eliberare memorie</li>
                        <li>Citire din fiÈ™ier</li>
                        <li>Verificare conectivitate</li>
                    </ul>
                    <p><strong>TODO markers:</strong> 8-10</p>
                </div>
                <div class="column">
                    <h3>ExerciÈ›iu 2: BFS È™i DFS</h3>
                    <p><strong>Obiectiv:</strong> Implementarea algoritmilor de parcurgere.</p>
                    <ul>
                        <li>BFS iterativ cu coadÄƒ</li>
                        <li>DFS recursiv</li>
                        <li>DFS iterativ cu stivÄƒ</li>
                        <li>Calculul distanÈ›elor (BFS)</li>
                        <li>NumÄƒrarea componentelor conexe</li>
                        <li>AfiÈ™area drumului minim</li>
                    </ul>
                    <p><strong>TODO markers:</strong> 12-15</p>
                </div>
            </div>
        </div>

        <!-- Slide 35: Key Takeaways -->
        <div class="slide">
            <h1>ğŸ¯ Concluzii Cheie</h1>
            <div class="takeaway-grid">
                <div class="takeaway-card">
                    <div class="icon">ğŸ“</div>
                    <h3>DefiniÈ›ie</h3>
                    <p>G = (V, E)<br>Noduri + Muchii</p>
                </div>
                <div class="takeaway-card">
                    <div class="icon">ğŸ“Š</div>
                    <h3>Matrice</h3>
                    <p>O(VÂ²) spaÈ›iu<br>O(1) verificare</p>
                </div>
                <div class="takeaway-card">
                    <div class="icon">ğŸ“‹</div>
                    <h3>Liste</h3>
                    <p>O(V+E) spaÈ›iu<br>Eficient pentru sparse</p>
                </div>
                <div class="takeaway-card">
                    <div class="icon">ğŸŒŠ</div>
                    <h3>BFS</h3>
                    <p>CoadÄƒ FIFO<br>Drumuri minime</p>
                </div>
                <div class="takeaway-card">
                    <div class="icon">ğŸŒ²</div>
                    <h3>DFS</h3>
                    <p>StivÄƒ/Recursie<br>Cicluri, topological</p>
                </div>
                <div class="takeaway-card">
                    <div class="icon">âš¡</div>
                    <h3>Complexitate</h3>
                    <p>O(V + E)<br>Ambele parcurgeri</p>
                </div>
            </div>
            <div class="quote-box">
                â€Grafurile sunt pretutindeni â€” de la reÈ›ele sociale la compilatoare, de la biologie la logisticÄƒ. StÄƒpÃ¢nirea lor deschide uÈ™i infinite."
                <div class="quote-author">â€” Curs ATP, SÄƒptÄƒmÃ¢na 12</div>
            </div>
        </div>

        <!-- Slide 36: Resources -->
        <div class="slide">
            <h1>ğŸ“š Resurse</h1>
            <h3>LecturÄƒ EsenÈ›ialÄƒ</h3>
            <ul class="resource-list">
                <li>ğŸ“– <strong>CLRS</strong> â€” Introduction to Algorithms, Capitolele 22-23</li>
                <li>ğŸ“– <strong>Sedgewick</strong> â€” Algorithms in C, Part 5: Graph Algorithms</li>
            </ul>
            <h3>Resurse Online</h3>
            <ul class="resource-list">
                <li>ğŸŒ <a href="https://visualgo.net/en/dfsbfs">VisuAlgo â€” Graph Traversal</a> â€” VizualizÄƒri interactive BFS/DFS</li>
                <li>ğŸŒ <a href="https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/">GeeksforGeeks â€” Graph DS</a></li>
                <li>ğŸŒ <a href="https://cp-algorithms.com/graph/breadth-first-search.html">CP-Algorithms â€” BFS</a></li>
            </ul>
            <h3>PracticÄƒ</h3>
            <ul class="resource-list">
                <li>ğŸ’» <strong>LeetCode</strong> â€” Graph problems (easy â†’ medium)</li>
                <li>ğŸ’» <strong>HackerRank</strong> â€” Graph Theory section</li>
            </ul>
        </div>

        <!-- Slide 37: Questions -->
        <div class="slide title-slide">
            <div class="week-badge">ÃNTREBÄ‚RI?</div>
            <h1>MulÈ›umesc pentru atenÈ›ie!</h1>
            <p class="subtitle">SÄƒptÄƒmÃ¢na 13: Algoritmi pe Grafuri â€” Dijkstra, Bellman-Ford</p>
            <p class="course-info" style="margin-top: 3rem;">
                ğŸ“§ ÃntrebÄƒri? ConsultaÈ›i forumul cursului sau orele de consultaÈ›ii.
            </p>
            <p class="course-info">
                ğŸ“ Nu uitaÈ›i: Tema de laborator are deadline la sfÃ¢rÈ™itul sÄƒptÄƒmÃ¢nii 13!
            </p>
        </div>

    </div>

    <!-- Navigation Controls -->
    <div class="nav-controls">
        <button class="nav-btn" onclick="goToSlide(0)" title="Prima (Home)">â®</button>
        <button class="nav-btn" onclick="prevSlide()" title="Ãnapoi (â†)">â—€</button>
        <button class="nav-btn" onclick="nextSlide()" title="Ãnainte (â†’)">â–¶</button>
        <button class="nav-btn" onclick="goToSlide(totalSlides-1)" title="Ultima (End)">â­</button>
    </div>

    <!-- Slide Counter -->
    <div class="slide-counter">
        <span id="currentSlide">1</span> / <span id="totalSlides">37</span>
    </div>

    <script>
        // Initialize highlight.js
        hljs.highlightAll();

        // Slide navigation
        let currentSlideIndex = 0;
        const slides = document.querySelectorAll('.slide');
        const totalSlides = slides.length;
        
        document.getElementById('totalSlides').textContent = totalSlides;

        function showSlide(index) {
            if (index < 0) index = 0;
            if (index >= totalSlides) index = totalSlides - 1;
            
            slides.forEach(slide => slide.classList.remove('active'));
            slides[index].classList.add('active');
            currentSlideIndex = index;
            
            document.getElementById('currentSlide').textContent = index + 1;
            updateProgressBar();
        }

        function nextSlide() {
            showSlide(currentSlideIndex + 1);
        }

        function prevSlide() {
            showSlide(currentSlideIndex - 1);
        }

        function goToSlide(index) {
            showSlide(index);
        }

        function updateProgressBar() {
            const progress = ((currentSlideIndex + 1) / totalSlides) * 100;
            document.getElementById('progressBar').style.width = progress + '%';
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowRight':
                case ' ':
                case 'PageDown':
                    e.preventDefault();
                    nextSlide();
                    break;
                case 'ArrowLeft':
                case 'PageUp':
                    e.preventDefault();
                    prevSlide();
                    break;
                case 'Home':
                    e.preventDefault();
                    goToSlide(0);
                    break;
                case 'End':
                    e.preventDefault();
                    goToSlide(totalSlides - 1);
                    break;
            }
        });

        // Touch support for mobile
        let touchStartX = 0;
        let touchEndX = 0;

        document.addEventListener('touchstart', e => {
            touchStartX = e.changedTouches[0].screenX;
        });

        document.addEventListener('touchend', e => {
            touchEndX = e.changedTouches[0].screenX;
            handleSwipe();
        });

        function handleSwipe() {
            const swipeThreshold = 50;
            const diff = touchStartX - touchEndX;
            
            if (Math.abs(diff) > swipeThreshold) {
                if (diff > 0) {
                    nextSlide();
                } else {
                    prevSlide();
                }
            }
        }

        // Initialize
        updateProgressBar();
    </script>
</body>
</html>
